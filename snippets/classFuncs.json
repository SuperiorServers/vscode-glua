{
  "Angle:Forward": {
    "prefix": "Forward",
    "body": "Forward()$0",
    "description": "(Shared) Method: Angle:Forward\n\nReturns a normal vector facing in the direction that the angle points."
  },
  "Angle:IsZero": {
    "prefix": "IsZero",
    "body": "IsZero()$0",
    "description": "(Shared) Method: Angle:IsZero\n\nReturns whether the pitch, yaw and roll are 0 or not."
  },
  "Angle:Normalize": {
    "prefix": "Normalize",
    "body": "Normalize()$0",
    "description": "(Shared) Method: Angle:Normalize\n\nNormalizes the angles by applying a module with 360 to pitch, yaw and roll."
  },
  "Angle:Right": {
    "prefix": "Right",
    "body": "Right()$0",
    "description": "(Shared) Method: Angle:Right\n\nReturns a normal vector facing in the direction that points right relative to the angle's direction."
  },
  "Angle:RotateAroundAxis": {
    "prefix": "RotateAroundAxis",
    "body": "RotateAroundAxis(${1:Vector axis}, ${2:number rotation})$0",
    "description": "(Shared) Method: Angle:RotateAroundAxis\n\nRotates the angle around the specified axis by the specified degrees."
  },
  "Angle:Set": {
    "prefix": "Set",
    "body": "Set(${1:Angle originalAngle})$0",
    "description": "(Shared) Method: Angle:Set\n\nCopies pitch, yaw and roll from the second angle to the first."
  },
  "Angle:SnapTo": {
    "prefix": "SnapTo",
    "body": "SnapTo(${1:string axis}, ${2:number target})$0",
    "description": "(Shared) Method: Angle:SnapTo\n\nSnaps the angle to nearest interval of degrees."
  },
  "Angle:Up": {
    "prefix": "Up",
    "body": "Up()$0",
    "description": "(Shared) Method: Angle:Up\n\nReturns a normal vector facing in the direction that points up relative to the angle's direction."
  },
  "Angle:Zero": {
    "prefix": "Zero",
    "body": "Zero()$0",
    "description": "(Shared) Method: Angle:Zero\n\nSets pitch, yaw and roll to 0."
  },
  "bf_read:ReadAngle": {
    "prefix": "ReadAngle",
    "body": "ReadAngle()$0",
    "description": "(Client) Method: bf_read:ReadAngle\n\nReads an returns an angle object from the bitstream."
  },
  "bf_read:ReadBool": {
    "prefix": "ReadBool",
    "body": "ReadBool()$0",
    "description": "(Client) Method: bf_read:ReadBool\n\nReads 1 bit an returns a bool representing the bit."
  },
  "bf_read:ReadChar": {
    "prefix": "ReadChar",
    "body": "ReadChar()$0",
    "description": "(Client) Method: bf_read:ReadChar\n\nReads a signed char and returns a number from -127 to 127 representing the ascii value of that char."
  },
  "bf_read:ReadEntity": {
    "prefix": "ReadEntity",
    "body": "ReadEntity()$0",
    "description": "(Client) Method: bf_read:ReadEntity\n\nReads a short representing an entity index and returns the matching entity handle."
  },
  "bf_read:ReadFloat": {
    "prefix": "ReadFloat",
    "body": "ReadFloat()$0",
    "description": "(Client) Method: bf_read:ReadFloat\n\nReads a 4 byte float from the bitstream and returns it."
  },
  "bf_read:ReadLong": {
    "prefix": "ReadLong",
    "body": "ReadLong()$0",
    "description": "(Client) Method: bf_read:ReadLong\n\nReads a 4 byte long from the bitstream and returns it."
  },
  "bf_read:ReadShort": {
    "prefix": "ReadShort",
    "body": "ReadShort()$0",
    "description": "(Client) Method: bf_read:ReadShort\n\nReads a 2 byte short from the bitstream and returns it."
  },
  "bf_read:ReadString": {
    "prefix": "ReadString",
    "body": "ReadString()$0",
    "description": "(Client) Method: bf_read:ReadString\n\nReads a null terminated string from the bitstream."
  },
  "bf_read:ReadVector": {
    "prefix": "ReadVector",
    "body": "ReadVector()$0",
    "description": "(Client) Method: bf_read:ReadVector\n\nReads a special encoded vector from the bitstream and returns it, this function is not suitable to send normals."
  },
  "bf_read:ReadVectorNormal": {
    "prefix": "ReadVectorNormal",
    "body": "ReadVectorNormal()$0",
    "description": "(Client) Method: bf_read:ReadVectorNormal\n\nReads a special encoded vector normal from the bitstream and returns it, this function is not suitable to send vectors that represent a position."
  },
  "bf_read:Reset": {
    "prefix": "Reset",
    "body": "Reset()$0",
    "description": "(Client) Method: bf_read:Reset\n\nRewinds the bitstream so it can be read again."
  },
  "CEffectData:GetAngles": {
    "prefix": "GetAngles",
    "body": "GetAngles()$0",
    "description": "(Shared) Method: CEffectData:GetAngles\n\nReturns the angles of the effect."
  },
  "CEffectData:GetAttachment": {
    "prefix": "GetAttachment",
    "body": "GetAttachment()$0",
    "description": "(Shared) Method: CEffectData:GetAttachment\n\nReturns the attachment ID for the effect."
  },
  "CEffectData:GetColor": {
    "prefix": "GetColor",
    "body": "GetColor()$0",
    "description": "(Shared) Method: CEffectData:GetColor\n\nReturns byte which represents the color of the effect."
  },
  "CEffectData:GetDamageType": {
    "prefix": "GetDamageType",
    "body": "GetDamageType()$0",
    "description": "(Shared) Method: CEffectData:GetDamageType\n\nReturns the damage type of the effect"
  },
  "CEffectData:GetEntIndex": {
    "prefix": "GetEntIndex",
    "body": "GetEntIndex()$0",
    "description": "(Server) Method: CEffectData:GetEntIndex\n\nReturns the entity index of the entity set for the effect."
  },
  "CEffectData:GetEntity": {
    "prefix": "GetEntity",
    "body": "GetEntity()$0",
    "description": "(Shared) Method: CEffectData:GetEntity\n\nReturns the entity assigned to the effect."
  },
  "CEffectData:GetFlags": {
    "prefix": "GetFlags",
    "body": "GetFlags()$0",
    "description": "(Shared) Method: CEffectData:GetFlags\n\nReturns the flags of the effect."
  },
  "CEffectData:GetHitBox": {
    "prefix": "GetHitBox",
    "body": "GetHitBox()$0",
    "description": "(Shared) Method: CEffectData:GetHitBox\n\nReturns the hit box ID of the effect."
  },
  "CEffectData:GetMagnitude": {
    "prefix": "GetMagnitude",
    "body": "GetMagnitude()$0",
    "description": "(Shared) Method: CEffectData:GetMagnitude\n\nReturns the magnitude of the effect."
  },
  "CEffectData:GetMaterialIndex": {
    "prefix": "GetMaterialIndex",
    "body": "GetMaterialIndex()$0",
    "description": "(Shared) Method: CEffectData:GetMaterialIndex\n\nReturns the material ID of the effect."
  },
  "CEffectData:GetNormal": {
    "prefix": "GetNormal",
    "body": "GetNormal()$0",
    "description": "(Shared) Method: CEffectData:GetNormal\n\nReturns the normalized direction vector of the effect."
  },
  "CEffectData:GetOrigin": {
    "prefix": "GetOrigin",
    "body": "GetOrigin()$0",
    "description": "(Shared) Method: CEffectData:GetOrigin\n\nReturns the origin position of the effect."
  },
  "CEffectData:GetRadius": {
    "prefix": "GetRadius",
    "body": "GetRadius()$0",
    "description": "(Shared) Method: CEffectData:GetRadius\n\nReturns the radius of the effect."
  },
  "CEffectData:GetScale": {
    "prefix": "GetScale",
    "body": "GetScale()$0",
    "description": "(Shared) Method: CEffectData:GetScale\n\nReturns the scale of the effect."
  },
  "CEffectData:GetStart": {
    "prefix": "GetStart",
    "body": "GetStart()$0",
    "description": "(Shared) Method: CEffectData:GetStart\n\nReturns the start position of the effect."
  },
  "CEffectData:GetSurfaceProp": {
    "prefix": "GetSurfaceProp",
    "body": "GetSurfaceProp()$0",
    "description": "(Shared) Method: CEffectData:GetSurfaceProp\n\nReturns the surface property index of the effect."
  },
  "CEffectData:SetAngles": {
    "prefix": "SetAngles",
    "body": "SetAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: CEffectData:SetAngles\n\nSets the angles of the effect."
  },
  "CEffectData:SetAttachment": {
    "prefix": "SetAttachment",
    "body": "SetAttachment(${1:number attachment})$0",
    "description": "(Shared) Method: CEffectData:SetAttachment\n\nSets the attachment id of the effect to be created with this effect data."
  },
  "CEffectData:SetColor": {
    "prefix": "SetColor",
    "body": "SetColor(${1:number color})$0",
    "description": "(Shared) Method: CEffectData:SetColor\n\nSets the color of the effect."
  },
  "CEffectData:SetDamageType": {
    "prefix": "SetDamageType",
    "body": "SetDamageType(${1:number damageType})$0",
    "description": "(Shared) Method: CEffectData:SetDamageType\n\nSets the damage type of the effect to be created with this effect data."
  },
  "CEffectData:SetEntIndex": {
    "prefix": "SetEntIndex",
    "body": "SetEntIndex(${1:number entIndex})$0",
    "description": "(Server) Method: CEffectData:SetEntIndex\n\nSets the entity of the effect via its index."
  },
  "CEffectData:SetEntity": {
    "prefix": "SetEntity",
    "body": "SetEntity(${1:Entity entity})$0",
    "description": "(Shared) Method: CEffectData:SetEntity\n\nSets the entity of the effect to be created with this effect data."
  },
  "CEffectData:SetFlags": {
    "prefix": "SetFlags",
    "body": "SetFlags(${1:number flags})$0",
    "description": "(Shared) Method: CEffectData:SetFlags\n\nSets the flags of the effect."
  },
  "CEffectData:SetHitBox": {
    "prefix": "SetHitBox",
    "body": "SetHitBox(${1:number hitBoxIndex})$0",
    "description": "(Shared) Method: CEffectData:SetHitBox\n\nSets the hit box index of the effect."
  },
  "CEffectData:SetMagnitude": {
    "prefix": "SetMagnitude",
    "body": "SetMagnitude(${1:number magnitude})$0",
    "description": "(Shared) Method: CEffectData:SetMagnitude\n\nSets the magnitude of the effect."
  },
  "CEffectData:SetMaterialIndex": {
    "prefix": "SetMaterialIndex",
    "body": "SetMaterialIndex(${1:number materialIndex})$0",
    "description": "(Shared) Method: CEffectData:SetMaterialIndex\n\nSets the material index of the effect."
  },
  "CEffectData:SetNormal": {
    "prefix": "SetNormal",
    "body": "SetNormal(${1:Vector normal})$0",
    "description": "(Shared) Method: CEffectData:SetNormal\n\nSets the normalized direction vector of the effect to be created with this effect data."
  },
  "CEffectData:SetOrigin": {
    "prefix": "SetOrigin",
    "body": "SetOrigin(${1:Vector origin})$0",
    "description": "(Shared) Method: CEffectData:SetOrigin\n\nSets the origin of the effect to be created with this effect data."
  },
  "CEffectData:SetRadius": {
    "prefix": "SetRadius",
    "body": "SetRadius(${1:number radius})$0",
    "description": "(Shared) Method: CEffectData:SetRadius\n\nSets the radius of the effect to be created with this effect data."
  },
  "CEffectData:SetScale": {
    "prefix": "SetScale",
    "body": "SetScale(${1:number scale})$0",
    "description": "(Shared) Method: CEffectData:SetScale\n\nSets the scale of the effect to be created with this effect data."
  },
  "CEffectData:SetStart": {
    "prefix": "SetStart",
    "body": "SetStart(${1:Vector start})$0",
    "description": "(Shared) Method: CEffectData:SetStart\n\nSets the start of the effect to be created with this effect data."
  },
  "CEffectData:SetSurfaceProp": {
    "prefix": "SetSurfaceProp",
    "body": "SetSurfaceProp(${1:number surfaceProperties})$0",
    "description": "(Shared) Method: CEffectData:SetSurfaceProp\n\nSets the surface property index of the effect."
  },
  "CLuaEmitter:Add": {
    "prefix": "Add",
    "body": "Add(${1:string material}, ${2:Vector position})$0",
    "description": "(Client) Method: CLuaEmitter:Add\n\nCreates a new CLuaParticle with the given material and position."
  },
  "CLuaEmitter:Draw": {
    "prefix": "Draw",
    "body": "Draw()$0",
    "description": "(Client) Method: CLuaEmitter:Draw\n\nManually renders all particles the emitter has created."
  },
  "CLuaEmitter:Finish": {
    "prefix": "Finish",
    "body": "Finish()$0",
    "description": "(Client) Method: CLuaEmitter:Finish\n\nRemoves the emitter and all its particles."
  },
  "CLuaEmitter:GetNumActiveParticles": {
    "prefix": "GetNumActiveParticles",
    "body": "GetNumActiveParticles()$0",
    "description": "(Client) Method: CLuaEmitter:GetNumActiveParticles\n\nReturns the amount of active particles of this emitter."
  },
  "CLuaEmitter:GetPos": {
    "prefix": "GetPos",
    "body": "GetPos()$0",
    "description": "(Client) Method: CLuaEmitter:GetPos\n\nReturns the position of this emitter. This is set when creating the emitter with _G.ParticleEmitter."
  },
  "CLuaEmitter:Is3D": {
    "prefix": "Is3D",
    "body": "Is3D()$0",
    "description": "(Client) Method: CLuaEmitter:Is3D\n\nReturns whether this emitter is 3D or not. This is set when creating the emitter with _G.ParticleEmitter."
  },
  "CLuaEmitter:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Client) Method: CLuaEmitter:IsValid\n\nReturns whether this CLuaEmitter is valid or not."
  },
  "CLuaEmitter:SetBBox": {
    "prefix": "SetBBox",
    "body": "SetBBox(${1:Vector mins}, ${2:Vector maxs})$0",
    "description": "(Client) Method: CLuaEmitter:SetBBox\n\nSets the bounding box for this emitter."
  },
  "CLuaEmitter:SetNearClip": {
    "prefix": "SetNearClip",
    "body": "SetNearClip(${1:number distanceMin}, ${2:number distanceMax})$0",
    "description": "(Client) Method: CLuaEmitter:SetNearClip\n\nThis function sets the the distance between the render camera and the emitter at which the particles should start fading and at which distance fade ends ( alpha becomes 0 )."
  },
  "CLuaEmitter:SetNoDraw": {
    "prefix": "SetNoDraw",
    "body": "SetNoDraw(${1:boolean noDraw})$0",
    "description": "(Client) Method: CLuaEmitter:SetNoDraw\n\nPrevents all particles of the emitter from automatically drawing."
  },
  "CLuaEmitter:SetParticleCullRadius": {
    "prefix": "SetParticleCullRadius",
    "body": "SetParticleCullRadius(${1:number radius})$0",
    "description": "(Client) Method: CLuaEmitter:SetParticleCullRadius\n\nThe function name has not much in common with its actual function, it applies a radius to every particles that affects the building of the bounding box, as it, usually is constructed by the particle that has the lowest x, y and z and the highest x, y and z, this function just adds/subtracts the radius and inflates the bounding box."
  },
  "CLuaEmitter:SetPos": {
    "prefix": "SetPos",
    "body": "SetPos(${1:Vector position})$0",
    "description": "(Client) Method: CLuaEmitter:SetPos\n\nSets the position of the particle emitter."
  },
  "CLuaLocomotion:Approach": {
    "prefix": "Approach",
    "body": "Approach(${1:Vector goal}, ${2:number goalweight})$0",
    "description": "(Server) Method: CLuaLocomotion:Approach\n\nSets the location we want to get to"
  },
  "CLuaLocomotion:ClearStuck": {
    "prefix": "ClearStuck",
    "body": "ClearStuck()$0",
    "description": "(Server) Method: CLuaLocomotion:ClearStuck\n\nRemoves the stuck status from the bot"
  },
  "CLuaLocomotion:FaceTowards": {
    "prefix": "FaceTowards",
    "body": "FaceTowards(${1:Vector goal})$0",
    "description": "(Server) Method: CLuaLocomotion:FaceTowards\n\nSets the direction we want to face"
  },
  "CLuaLocomotion:GetAcceleration": {
    "prefix": "GetAcceleration",
    "body": "GetAcceleration()$0",
    "description": "(Server) Method: CLuaLocomotion:GetAcceleration\n\nReturns the acceleration speed"
  },
  "CLuaLocomotion:GetCurrentAcceleration": {
    "prefix": "GetCurrentAcceleration",
    "body": "GetCurrentAcceleration()$0",
    "description": "(Server) Method: CLuaLocomotion:GetCurrentAcceleration\n\nReturns the current acceleration as a vector"
  },
  "CLuaLocomotion:GetDeathDropHeight": {
    "prefix": "GetDeathDropHeight",
    "body": "GetDeathDropHeight()$0",
    "description": "(Server) Method: CLuaLocomotion:GetDeathDropHeight\n\nGets the height the bot is scared to fall from"
  },
  "CLuaLocomotion:GetDeceleration": {
    "prefix": "GetDeceleration",
    "body": "GetDeceleration()$0",
    "description": "(Server) Method: CLuaLocomotion:GetDeceleration\n\nGets the deceleration speed"
  },
  "CLuaLocomotion:GetGroundMotionVector": {
    "prefix": "GetGroundMotionVector",
    "body": "GetGroundMotionVector()$0",
    "description": "(Server) Method: CLuaLocomotion:GetGroundMotionVector\n\nReturn unit vector in XY plane describing our direction of motion - even if we are currently not moving"
  },
  "CLuaLocomotion:GetJumpHeight": {
    "prefix": "GetJumpHeight",
    "body": "GetJumpHeight()$0",
    "description": "(Server) Method: CLuaLocomotion:GetJumpHeight\n\nGets the height of the bot's jump"
  },
  "CLuaLocomotion:GetMaxJumpHeight": {
    "prefix": "GetMaxJumpHeight",
    "body": "GetMaxJumpHeight()$0",
    "description": "(Server) Method: CLuaLocomotion:GetMaxJumpHeight\n\nReturns maximum jump height of this CLuaLocomotion."
  },
  "CLuaLocomotion:GetMaxYawRate": {
    "prefix": "GetMaxYawRate",
    "body": "GetMaxYawRate()$0",
    "description": "(Server) Method: CLuaLocomotion:GetMaxYawRate\n\nReturns the max rate at which the NextBot can visually rotate."
  },
  "CLuaLocomotion:GetStepHeight": {
    "prefix": "GetStepHeight",
    "body": "GetStepHeight()$0",
    "description": "(Server) Method: CLuaLocomotion:GetStepHeight\n\nGets the max height the bot can step up"
  },
  "CLuaLocomotion:GetVelocity": {
    "prefix": "GetVelocity",
    "body": "GetVelocity()$0",
    "description": "(Server) Method: CLuaLocomotion:GetVelocity\n\nReturns the current movement velocity as a vector"
  },
  "CLuaLocomotion:IsAreaTraversable": {
    "prefix": "IsAreaTraversable",
    "body": "IsAreaTraversable(${1:CNavArea area})$0",
    "description": "(Server) Method: CLuaLocomotion:IsAreaTraversable\n\nReturns whether this CLuaLocomotion can reach and/or traverse/move in given Type.CNavArea."
  },
  "CLuaLocomotion:IsAttemptingToMove": {
    "prefix": "IsAttemptingToMove",
    "body": "IsAttemptingToMove()$0",
    "description": "(Server) Method: CLuaLocomotion:IsAttemptingToMove\n\nReturns true if we're trying to move."
  },
  "CLuaLocomotion:IsClimbingOrJumping": {
    "prefix": "IsClimbingOrJumping",
    "body": "IsClimbingOrJumping()$0",
    "description": "(Server) Method: CLuaLocomotion:IsClimbingOrJumping\n\nReturns true of the locomotion engine is jumping or climbing"
  },
  "CLuaLocomotion:IsOnGround": {
    "prefix": "IsOnGround",
    "body": "IsOnGround()$0",
    "description": "(Server) Method: CLuaLocomotion:IsOnGround\n\nReturns whether the locomotion/nextbot is on ground or not."
  },
  "CLuaLocomotion:IsStuck": {
    "prefix": "IsStuck",
    "body": "IsStuck()$0",
    "description": "(Server) Method: CLuaLocomotion:IsStuck\n\nReturns true if we're stuck"
  },
  "CLuaLocomotion:IsUsingLadder": {
    "prefix": "IsUsingLadder",
    "body": "IsUsingLadder()$0",
    "description": "(Server) Method: CLuaLocomotion:IsUsingLadder\n\n"
  },
  "CLuaLocomotion:Jump": {
    "prefix": "Jump",
    "body": "Jump()$0",
    "description": "(Server) Method: CLuaLocomotion:Jump\n\nMakes the bot jump"
  },
  "CLuaLocomotion:JumpAcrossGap": {
    "prefix": "JumpAcrossGap",
    "body": "JumpAcrossGap(${1:Vector landingGoal}, ${2:Vector landingForward})$0",
    "description": "(Server) Method: CLuaLocomotion:JumpAcrossGap\n\n"
  },
  "CLuaLocomotion:SetAcceleration": {
    "prefix": "SetAcceleration",
    "body": "SetAcceleration(${1:number speed})$0",
    "description": "(Server) Method: CLuaLocomotion:SetAcceleration\n\nSets the acceleration speed"
  },
  "CLuaLocomotion:SetDeathDropHeight": {
    "prefix": "SetDeathDropHeight",
    "body": "SetDeathDropHeight(${1:number height})$0",
    "description": "(Server) Method: CLuaLocomotion:SetDeathDropHeight\n\nSets the height the bot is scared to fall from."
  },
  "CLuaLocomotion:SetDeceleration": {
    "prefix": "SetDeceleration",
    "body": "SetDeceleration(${1:number deceleration})$0",
    "description": "(Server) Method: CLuaLocomotion:SetDeceleration\n\nSets the deceleration speed."
  },
  "CLuaLocomotion:SetDesiredSpeed": {
    "prefix": "SetDesiredSpeed",
    "body": "SetDesiredSpeed(${1:number speed})$0",
    "description": "(Server) Method: CLuaLocomotion:SetDesiredSpeed\n\nSets movement speed."
  },
  "CLuaLocomotion:SetJumpHeight": {
    "prefix": "SetJumpHeight",
    "body": "SetJumpHeight(${1:number height})$0",
    "description": "(Server) Method: CLuaLocomotion:SetJumpHeight\n\nSets the height of the bot's jump"
  },
  "CLuaLocomotion:SetMaxYawRate": {
    "prefix": "SetMaxYawRate",
    "body": "SetMaxYawRate(${1:number yawRate})$0",
    "description": "(Server) Method: CLuaLocomotion:SetMaxYawRate\n\nSets the max rate at which the NextBot can visually rotate. This will not affect moving or pathing."
  },
  "CLuaLocomotion:SetStepHeight": {
    "prefix": "SetStepHeight",
    "body": "SetStepHeight(${1:number height})$0",
    "description": "(Server) Method: CLuaLocomotion:SetStepHeight\n\nSets the max height the bot can step up"
  },
  "CLuaLocomotion:SetVelocity": {
    "prefix": "SetVelocity",
    "body": "SetVelocity(${1:Vector velocity})$0",
    "description": "(Server) Method: CLuaLocomotion:SetVelocity\n\nSets the current movement velocity"
  },
  "CLuaParticle:GetAirResistance": {
    "prefix": "GetAirResistance",
    "body": "GetAirResistance()$0",
    "description": "(Client) Method: CLuaParticle:GetAirResistance\n\nReturns the air resistance of the particle."
  },
  "CLuaParticle:GetAngles": {
    "prefix": "GetAngles",
    "body": "GetAngles()$0",
    "description": "(Client) Method: CLuaParticle:GetAngles\n\nReturns the current orientation of the particle."
  },
  "CLuaParticle:GetAngleVelocity": {
    "prefix": "GetAngleVelocity",
    "body": "GetAngleVelocity()$0",
    "description": "(Client) Method: CLuaParticle:GetAngleVelocity\n\nReturns the angular velocity of the particle"
  },
  "CLuaParticle:GetBounce": {
    "prefix": "GetBounce",
    "body": "GetBounce()$0",
    "description": "(Client) Method: CLuaParticle:GetBounce\n\nReturns the 'bounciness' of the particle."
  },
  "CLuaParticle:GetColor": {
    "prefix": "GetColor",
    "body": "GetColor()$0",
    "description": "(Client) Method: CLuaParticle:GetColor\n\nReturns the color of the particle."
  },
  "CLuaParticle:GetDieTime": {
    "prefix": "GetDieTime",
    "body": "GetDieTime()$0",
    "description": "(Client) Method: CLuaParticle:GetDieTime\n\nReturns the amount of time in seconds after which the particle will be destroyed."
  },
  "CLuaParticle:GetEndAlpha": {
    "prefix": "GetEndAlpha",
    "body": "GetEndAlpha()$0",
    "description": "(Client) Method: CLuaParticle:GetEndAlpha\n\nReturns the alpha value that the particle will reach on its death."
  },
  "CLuaParticle:GetEndLength": {
    "prefix": "GetEndLength",
    "body": "GetEndLength()$0",
    "description": "(Client) Method: CLuaParticle:GetEndLength\n\nReturns the length that the particle will reach on its death."
  },
  "CLuaParticle:GetEndSize": {
    "prefix": "GetEndSize",
    "body": "GetEndSize()$0",
    "description": "(Client) Method: CLuaParticle:GetEndSize\n\nReturns the size that the particle will reach on its death."
  },
  "CLuaParticle:GetGravity": {
    "prefix": "GetGravity",
    "body": "GetGravity()$0",
    "description": "(Client) Method: CLuaParticle:GetGravity\n\nReturns the gravity of the particle."
  },
  "CLuaParticle:GetLifeTime": {
    "prefix": "GetLifeTime",
    "body": "GetLifeTime()$0",
    "description": "(Client) Method: CLuaParticle:GetLifeTime\n\nReturns the 'life time' of the particle, how long the particle existed since its creation."
  },
  "CLuaParticle:GetPos": {
    "prefix": "GetPos",
    "body": "GetPos()$0",
    "description": "(Client) Method: CLuaParticle:GetPos\n\nReturns the absolute position of the particle."
  },
  "CLuaParticle:GetRoll": {
    "prefix": "GetRoll",
    "body": "GetRoll()$0",
    "description": "(Client) Method: CLuaParticle:GetRoll\n\nReturns the current rotation of the particle in radians, this should only be used for 2D particles."
  },
  "CLuaParticle:GetRollDelta": {
    "prefix": "GetRollDelta",
    "body": "GetRollDelta()$0",
    "description": "(Client) Method: CLuaParticle:GetRollDelta\n\nReturns the current rotation speed of the particle in radians, this should only be used for 2D particles."
  },
  "CLuaParticle:GetStartAlpha": {
    "prefix": "GetStartAlpha",
    "body": "GetStartAlpha()$0",
    "description": "(Client) Method: CLuaParticle:GetStartAlpha\n\nReturns the alpha value which the particle has when it's created."
  },
  "CLuaParticle:GetStartLength": {
    "prefix": "GetStartLength",
    "body": "GetStartLength()$0",
    "description": "(Client) Method: CLuaParticle:GetStartLength\n\nReturns the length which the particle has when it's created."
  },
  "CLuaParticle:GetStartSize": {
    "prefix": "GetStartSize",
    "body": "GetStartSize()$0",
    "description": "(Client) Method: CLuaParticle:GetStartSize\n\nReturns the size which the particle has when it's created."
  },
  "CLuaParticle:GetVelocity": {
    "prefix": "GetVelocity",
    "body": "GetVelocity()$0",
    "description": "(Client) Method: CLuaParticle:GetVelocity\n\nReturns the current velocity of the particle."
  },
  "CLuaParticle:SetAirResistance": {
    "prefix": "SetAirResistance",
    "body": "SetAirResistance(${1:number airResistance})$0",
    "description": "(Client) Method: CLuaParticle:SetAirResistance\n\nSets the air resistance of the the particle."
  },
  "CLuaParticle:SetAngles": {
    "prefix": "SetAngles",
    "body": "SetAngles(${1:Angle ang})$0",
    "description": "(Client) Method: CLuaParticle:SetAngles\n\nSets the angles of the particle."
  },
  "CLuaParticle:SetAngleVelocity": {
    "prefix": "SetAngleVelocity",
    "body": "SetAngleVelocity(${1:Angle angVel})$0",
    "description": "(Client) Method: CLuaParticle:SetAngleVelocity\n\nSets the angular velocity of the the particle."
  },
  "CLuaParticle:SetBounce": {
    "prefix": "SetBounce",
    "body": "SetBounce(${1:number bounce})$0",
    "description": "(Client) Method: CLuaParticle:SetBounce\n\nSets the 'bounciness' of the the particle."
  },
  "CLuaParticle:SetCollide": {
    "prefix": "SetCollide",
    "body": "SetCollide(${1:boolean shouldCollide})$0",
    "description": "(Client) Method: CLuaParticle:SetCollide\n\nSets the whether the particle should collide with the world or not."
  },
  "CLuaParticle:SetCollideCallback": {
    "prefix": "SetCollideCallback",
    "body": "SetCollideCallback(${1:function collideFunc})$0",
    "description": "(Client) Method: CLuaParticle:SetCollideCallback\n\nSets the function that gets called whenever the particle collides with the world."
  },
  "CLuaParticle:SetColor": {
    "prefix": "SetColor",
    "body": "SetColor(${1:number r}, ${2:number g}, ${3:number b})$0",
    "description": "(Client) Method: CLuaParticle:SetColor\n\nSets the color of the particle."
  },
  "CLuaParticle:SetDieTime": {
    "prefix": "SetDieTime",
    "body": "SetDieTime(${1:number dieTime})$0",
    "description": "(Client) Method: CLuaParticle:SetDieTime\n\nSets the time where the particle will be removed."
  },
  "CLuaParticle:SetEndAlpha": {
    "prefix": "SetEndAlpha",
    "body": "SetEndAlpha(${1:number endAlpha})$0",
    "description": "(Client) Method: CLuaParticle:SetEndAlpha\n\nSets the alpha value of the particle that it will reach when it dies."
  },
  "CLuaParticle:SetEndLength": {
    "prefix": "SetEndLength",
    "body": "SetEndLength(${1:number endLength})$0",
    "description": "(Client) Method: CLuaParticle:SetEndLength\n\nSets the length of the particle that it will reach when it dies."
  },
  "CLuaParticle:SetEndSize": {
    "prefix": "SetEndSize",
    "body": "SetEndSize(${1:number endSize})$0",
    "description": "(Client) Method: CLuaParticle:SetEndSize\n\nSets the size of the particle that it will reach when it dies."
  },
  "CLuaParticle:SetGravity": {
    "prefix": "SetGravity",
    "body": "SetGravity(${1:Vector gravity})$0",
    "description": "(Client) Method: CLuaParticle:SetGravity\n\nSets the directional gravity aka. acceleration of the particle."
  },
  "CLuaParticle:SetLifeTime": {
    "prefix": "SetLifeTime",
    "body": "SetLifeTime(${1:number lifeTime})$0",
    "description": "(Client) Method: CLuaParticle:SetLifeTime\n\nSets the 'life time' of the particle, how long the particle existed since its creation."
  },
  "CLuaParticle:SetLighting": {
    "prefix": "SetLighting",
    "body": "SetLighting(${1:boolean useLighting})$0",
    "description": "(Client) Method: CLuaParticle:SetLighting\n\nSets whether the particle should be lighted."
  },
  "CLuaParticle:SetNextThink": {
    "prefix": "SetNextThink",
    "body": "SetNextThink(${1:number nextThink})$0",
    "description": "(Client) Method: CLuaParticle:SetNextThink\n\nSets when the particles think function should be called next, this uses the synchronized server time returned by _G.CurTime."
  },
  "CLuaParticle:SetPos": {
    "prefix": "SetPos",
    "body": "SetPos(${1:Vector pos})$0",
    "description": "(Client) Method: CLuaParticle:SetPos\n\nSets the absolute position of the particle."
  },
  "CLuaParticle:SetRoll": {
    "prefix": "SetRoll",
    "body": "SetRoll(${1:number roll})$0",
    "description": "(Client) Method: CLuaParticle:SetRoll\n\nSets the roll of the particle in radians. This should only be used for 2D particles."
  },
  "CLuaParticle:SetRollDelta": {
    "prefix": "SetRollDelta",
    "body": "SetRollDelta(${1:number rollDelta})$0",
    "description": "(Client) Method: CLuaParticle:SetRollDelta\n\nSets the rotation speed of the particle in radians. This should only be used for 2D particles."
  },
  "CLuaParticle:SetStartAlpha": {
    "prefix": "SetStartAlpha",
    "body": "SetStartAlpha(${1:number startAlpha})$0",
    "description": "(Client) Method: CLuaParticle:SetStartAlpha\n\nSets the initial alpha value of the particle."
  },
  "CLuaParticle:SetStartLength": {
    "prefix": "SetStartLength",
    "body": "SetStartLength(${1:number startLength})$0",
    "description": "(Client) Method: CLuaParticle:SetStartLength\n\nSets the initial length value of the particle."
  },
  "CLuaParticle:SetStartSize": {
    "prefix": "SetStartSize",
    "body": "SetStartSize(${1:number startSize})$0",
    "description": "(Client) Method: CLuaParticle:SetStartSize\n\nSets the initial size value of the particle."
  },
  "CLuaParticle:SetThinkFunction": {
    "prefix": "SetThinkFunction",
    "body": "SetThinkFunction(${1:function thinkFunc})$0",
    "description": "(Client) Method: CLuaParticle:SetThinkFunction\n\nSets the think function of the particle."
  },
  "CLuaParticle:SetVelocity": {
    "prefix": "SetVelocity",
    "body": "SetVelocity(${1:Vector vel})$0",
    "description": "(Client) Method: CLuaParticle:SetVelocity\n\nSets the velocity of the particle."
  },
  "CLuaParticle:SetVelocityScale": {
    "prefix": "SetVelocityScale",
    "body": "SetVelocityScale(${1:boolean doScale=false})$0",
    "description": "(Client) Method: CLuaParticle:SetVelocityScale\n\nScales the velocity based on the particle speed."
  },
  "CMoveData:AddKey": {
    "prefix": "AddKey",
    "body": "AddKey(${1:number keys})$0",
    "description": "(Shared) Method: CMoveData:AddKey\n\nAdds keys to the move data, as if player pressed them."
  },
  "CMoveData:GetAbsMoveAngles": {
    "prefix": "GetAbsMoveAngles",
    "body": "GetAbsMoveAngles()$0",
    "description": "(Shared) Method: CMoveData:GetAbsMoveAngles\n\nGets the aim angle. Seems to be same as CMoveData.GetAngles."
  },
  "CMoveData:GetAngles": {
    "prefix": "GetAngles",
    "body": "GetAngles()$0",
    "description": "(Shared) Method: CMoveData:GetAngles\n\nGets the aim angle. On client is the same as Entity.GetAngles."
  },
  "CMoveData:GetButtons": {
    "prefix": "GetButtons",
    "body": "GetButtons()$0",
    "description": "(Shared) Method: CMoveData:GetButtons\n\nGets which buttons are down"
  },
  "CMoveData:GetConstraintRadius": {
    "prefix": "GetConstraintRadius",
    "body": "GetConstraintRadius()$0",
    "description": "(Shared) Method: CMoveData:GetConstraintRadius\n\nReturns the radius that constrains the players movement."
  },
  "CMoveData:GetForwardSpeed": {
    "prefix": "GetForwardSpeed",
    "body": "GetForwardSpeed()$0",
    "description": "(Shared) Method: CMoveData:GetForwardSpeed\n\nReturns the players forward speed."
  },
  "CMoveData:GetImpulseCommand": {
    "prefix": "GetImpulseCommand",
    "body": "GetImpulseCommand()$0",
    "description": "(Shared) Method: CMoveData:GetImpulseCommand\n\nGets the number passed to \"impulse\" console command"
  },
  "CMoveData:GetMaxClientSpeed": {
    "prefix": "GetMaxClientSpeed",
    "body": "GetMaxClientSpeed()$0",
    "description": "(Shared) Method: CMoveData:GetMaxClientSpeed\n\nReturns the maximum client speed of the player"
  },
  "CMoveData:GetMaxSpeed": {
    "prefix": "GetMaxSpeed",
    "body": "GetMaxSpeed()$0",
    "description": "(Shared) Method: CMoveData:GetMaxSpeed\n\nReturns the maximum speed of the player."
  },
  "CMoveData:GetMoveAngles": {
    "prefix": "GetMoveAngles",
    "body": "GetMoveAngles()$0",
    "description": "(Shared) Method: CMoveData:GetMoveAngles\n\nReturns the angle the player is moving at. For more info, see CMoveData.SetMoveAngles."
  },
  "CMoveData:GetOldAngles": {
    "prefix": "GetOldAngles",
    "body": "GetOldAngles()$0",
    "description": "(Shared) Method: CMoveData:GetOldAngles\n\nGets the aim angle. Only works clientside, server returns same as CMoveData.GetAngles."
  },
  "CMoveData:GetOldButtons": {
    "prefix": "GetOldButtons",
    "body": "GetOldButtons()$0",
    "description": "(Shared) Method: CMoveData:GetOldButtons\n\nGet which buttons were down last frame"
  },
  "CMoveData:GetOrigin": {
    "prefix": "GetOrigin",
    "body": "GetOrigin()$0",
    "description": "(Shared) Method: CMoveData:GetOrigin\n\nGets the player's position."
  },
  "CMoveData:GetSideSpeed": {
    "prefix": "GetSideSpeed",
    "body": "GetSideSpeed()$0",
    "description": "(Shared) Method: CMoveData:GetSideSpeed\n\nReturns the strafe speed of the player."
  },
  "CMoveData:GetUpSpeed": {
    "prefix": "GetUpSpeed",
    "body": "GetUpSpeed()$0",
    "description": "(Shared) Method: CMoveData:GetUpSpeed\n\nReturns the vertical speed of the player. ( Z axis of CMoveData.GetVelocity )"
  },
  "CMoveData:GetVelocity": {
    "prefix": "GetVelocity",
    "body": "GetVelocity()$0",
    "description": "(Shared) Method: CMoveData:GetVelocity\n\nGets the players velocity."
  },
  "CMoveData:KeyDown": {
    "prefix": "KeyDown",
    "body": "KeyDown(${1:number key})$0",
    "description": "(Shared) Method: CMoveData:KeyDown\n\nReturns whether the key is down or not"
  },
  "CMoveData:KeyPressed": {
    "prefix": "KeyPressed",
    "body": "KeyPressed(${1:number key})$0",
    "description": "(Shared) Method: CMoveData:KeyPressed\n\nReturns whether the key was pressed. If you want to check if the key is held down, try CMoveData.KeyDown"
  },
  "CMoveData:KeyReleased": {
    "prefix": "KeyReleased",
    "body": "KeyReleased(${1:number key})$0",
    "description": "(Shared) Method: CMoveData:KeyReleased\n\nReturns whether the key was released"
  },
  "CMoveData:KeyWasDown": {
    "prefix": "KeyWasDown",
    "body": "KeyWasDown(${1:number key})$0",
    "description": "(Shared) Method: CMoveData:KeyWasDown\n\nReturns whether the key was down or not."
  },
  "CMoveData:SetAbsMoveAngles": {
    "prefix": "SetAbsMoveAngles",
    "body": "SetAbsMoveAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: CMoveData:SetAbsMoveAngles\n\nSets absolute move angles.( ? ) Doesn't seem to do anything."
  },
  "CMoveData:SetAngles": {
    "prefix": "SetAngles",
    "body": "SetAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: CMoveData:SetAngles\n\nSets angles ( ? ). Doesn't seem to be doing anything."
  },
  "CMoveData:SetButtons": {
    "prefix": "SetButtons",
    "body": "SetButtons(${1:number buttons})$0",
    "description": "(Shared) Method: CMoveData:SetButtons\n\nSets the pressed buttons on the move data"
  },
  "CMoveData:SetConstraintRadius": {
    "prefix": "SetConstraintRadius",
    "body": "SetConstraintRadius(${1:number radius})$0",
    "description": "(Shared) Method: CMoveData:SetConstraintRadius\n\nSets the radius that constrains the players movement."
  },
  "CMoveData:SetForwardSpeed": {
    "prefix": "SetForwardSpeed",
    "body": "SetForwardSpeed(${1:number speed})$0",
    "description": "(Shared) Method: CMoveData:SetForwardSpeed\n\nSets players forward speed."
  },
  "CMoveData:SetImpulseCommand": {
    "prefix": "SetImpulseCommand",
    "body": "SetImpulseCommand(${1:number impulse})$0",
    "description": "(Shared) Method: CMoveData:SetImpulseCommand\n\nSets the impulse command. This isn't actually utilised in the engine anywhere."
  },
  "CMoveData:SetMaxClientSpeed": {
    "prefix": "SetMaxClientSpeed",
    "body": "SetMaxClientSpeed(${1:number maxSpeed})$0",
    "description": "(Shared) Method: CMoveData:SetMaxClientSpeed\n\nSets the maximum player speed. Player won't be able to run or sprint faster then this value."
  },
  "CMoveData:SetMaxSpeed": {
    "prefix": "SetMaxSpeed",
    "body": "SetMaxSpeed(${1:number maxSpeed})$0",
    "description": "(Shared) Method: CMoveData:SetMaxSpeed\n\nSets the maximum speed of the player. This must match with CMoveData.SetMaxClientSpeed both, on server and client."
  },
  "CMoveData:SetMoveAngles": {
    "prefix": "SetMoveAngles",
    "body": "SetMoveAngles(${1:Angle dir})$0",
    "description": "(Shared) Method: CMoveData:SetMoveAngles\n\nSets the serverside move angles. Means movement keys will act as if player was facing that direction."
  },
  "CMoveData:SetOldAngles": {
    "prefix": "SetOldAngles",
    "body": "SetOldAngles(${1:Angle aimAng})$0",
    "description": "(Shared) Method: CMoveData:SetOldAngles\n\nSets old aim angles. ( ? ) Doesn't seem to be doing anything."
  },
  "CMoveData:SetOldButtons": {
    "prefix": "SetOldButtons",
    "body": "SetOldButtons(${1:number buttons})$0",
    "description": "(Shared) Method: CMoveData:SetOldButtons\n\nSets the 'old' pressed buttons on the move data. These buttons are used to work out which buttons have been released, which have just been pressed and which are being held down."
  },
  "CMoveData:SetOrigin": {
    "prefix": "SetOrigin",
    "body": "SetOrigin(${1:Vector pos})$0",
    "description": "(Shared) Method: CMoveData:SetOrigin\n\nSets the players position."
  },
  "CMoveData:SetSideSpeed": {
    "prefix": "SetSideSpeed",
    "body": "SetSideSpeed(${1:number speed})$0",
    "description": "(Shared) Method: CMoveData:SetSideSpeed\n\nSets players strafe speed."
  },
  "CMoveData:SetUpSpeed": {
    "prefix": "SetUpSpeed",
    "body": "SetUpSpeed(${1:number speed})$0",
    "description": "(Shared) Method: CMoveData:SetUpSpeed\n\nSets vertical speed of the player. ( Z axis of CMoveData.SetVelocity )"
  },
  "CMoveData:SetVelocity": {
    "prefix": "SetVelocity",
    "body": "SetVelocity(${1:Vector velocity})$0",
    "description": "(Shared) Method: CMoveData:SetVelocity\n\nSets the player's velocity"
  },
  "CNavArea:AddToClosedList": {
    "prefix": "AddToClosedList",
    "body": "AddToClosedList()$0",
    "description": "(Server) Method: CNavArea:AddToClosedList\n\nAdds this CNavArea to the list of areas that have been checked by Type.NextBot's [https://en.wikipedia.org/wiki/A*_search_algorithm A* search algorithm], the closed list."
  },
  "CNavArea:AddToOpenList": {
    "prefix": "AddToOpenList",
    "body": "AddToOpenList()$0",
    "description": "(Server) Method: CNavArea:AddToOpenList\n\nAdds this CNavArea to the Open List."
  },
  "CNavArea:ClearSearchLists": {
    "prefix": "ClearSearchLists",
    "body": "ClearSearchLists()$0",
    "description": "(Server) Method: CNavArea:ClearSearchLists\n\nClears the open and closed lists for a new search."
  },
  "CNavArea:ComputeAdjacentConnectionHeightChange": {
    "prefix": "ComputeAdjacentConnectionHeightChange",
    "body": "ComputeAdjacentConnectionHeightChange(${1:CNavArea navarea})$0",
    "description": "(Server) Method: CNavArea:ComputeAdjacentConnectionHeightChange\n\nReturns the height difference between the edges of two connected navareas."
  },
  "CNavArea:ComputeDirection": {
    "prefix": "ComputeDirection",
    "body": "ComputeDirection(${1:Vector pos})$0",
    "description": "(Server) Method: CNavArea:ComputeDirection\n\nReturns the Enum.NavDir direction that the given vector faces on this CNavArea."
  },
  "CNavArea:ComputeGroundHeightChange": {
    "prefix": "ComputeGroundHeightChange",
    "body": "ComputeGroundHeightChange(${1:CNavArea navArea})$0",
    "description": "(Server) Method: CNavArea:ComputeGroundHeightChange\n\nReturns the height difference on the Z axis of the two CNavAreas. This is calculated from the center most point on both Type.CNavAreas."
  },
  "CNavArea:ConnectTo": {
    "prefix": "ConnectTo",
    "body": "ConnectTo(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavArea:ConnectTo\n\nConnects this CNavArea to another Type.CNavArea or Type.CNavLadder with a one way connection. ( From this area to the target )"
  },
  "CNavArea:Contains": {
    "prefix": "Contains",
    "body": "Contains(${1:Vector pos})$0",
    "description": "(Server) Method: CNavArea:Contains\n\nReturns true if this CNavArea contains the given vector."
  },
  "CNavArea:Disconnect": {
    "prefix": "Disconnect",
    "body": "Disconnect(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavArea:Disconnect\n\nDisconnects this nav area from given area or ladder. ( Only disconnects one way )"
  },
  "CNavArea:Draw": {
    "prefix": "Draw",
    "body": "Draw()$0",
    "description": "(Server) Method: CNavArea:Draw\n\nDraws this navarea on debug overlay."
  },
  "CNavArea:DrawSpots": {
    "prefix": "DrawSpots",
    "body": "DrawSpots()$0",
    "description": "(Server) Method: CNavArea:DrawSpots\n\nDraws the hiding spots on debug overlay. This includes sniper/exposed spots too!"
  },
  "CNavArea:GetAdjacentAreas": {
    "prefix": "GetAdjacentAreas",
    "body": "GetAdjacentAreas()$0",
    "description": "(Server) Method: CNavArea:GetAdjacentAreas\n\nReturns a table of all the CNavAreas that have a  ( one and two way ) connection '''from''' this Type.CNavArea."
  },
  "CNavArea:GetAdjacentAreasAtSide": {
    "prefix": "GetAdjacentAreasAtSide",
    "body": "GetAdjacentAreasAtSide(${1:number navDir})$0",
    "description": "(Server) Method: CNavArea:GetAdjacentAreasAtSide\n\nReturns a table of all the CNavAreas that have a ( one and two way ) connection '''from''' this Type.CNavArea in given direction."
  },
  "CNavArea:GetAdjacentCount": {
    "prefix": "GetAdjacentCount",
    "body": "GetAdjacentCount()$0",
    "description": "(Server) Method: CNavArea:GetAdjacentCount\n\nReturns the amount of CNavAreas that have a connection ( one and two way ) '''from''' this Type.CNavArea."
  },
  "CNavArea:GetAdjacentCountAtSide": {
    "prefix": "GetAdjacentCountAtSide",
    "body": "GetAdjacentCountAtSide(${1:number navDir})$0",
    "description": "(Server) Method: CNavArea:GetAdjacentCountAtSide\n\nReturns the amount of CNavAreas that have a connection ( one or two way ) '''from''' this Type.CNavArea in given direction."
  },
  "CNavArea:GetAttributes": {
    "prefix": "GetAttributes",
    "body": "GetAttributes()$0",
    "description": "(Server) Method: CNavArea:GetAttributes\n\nReturns the attribute mask for the given CNavArea."
  },
  "CNavArea:GetCenter": {
    "prefix": "GetCenter",
    "body": "GetCenter()$0",
    "description": "(Server) Method: CNavArea:GetCenter\n\nReturns the center most vector point for the given CNavArea."
  },
  "CNavArea:GetClosestPointOnArea": {
    "prefix": "GetClosestPointOnArea",
    "body": "GetClosestPointOnArea(${1:Vector pos})$0",
    "description": "(Server) Method: CNavArea:GetClosestPointOnArea\n\nReturns the closest point of this Nav Area from the given position."
  },
  "CNavArea:GetCorner": {
    "prefix": "GetCorner",
    "body": "GetCorner(${1:number cornerid})$0",
    "description": "(Server) Method: CNavArea:GetCorner\n\nReturns the vector position of the corner for the given CNavArea."
  },
  "CNavArea:GetCostSoFar": {
    "prefix": "GetCostSoFar",
    "body": "GetCostSoFar()$0",
    "description": "(Server) Method: CNavArea:GetCostSoFar\n\nInternal function used when generating a path from one point to another in PathFollower.Compute."
  },
  "CNavArea:GetExposedSpots": {
    "prefix": "GetExposedSpots",
    "body": "GetExposedSpots()$0",
    "description": "(Server) Method: CNavArea:GetExposedSpots\n\nReturns a table of very bad hiding spots in this area"
  },
  "CNavArea:GetExtentInfo": {
    "prefix": "GetExtentInfo",
    "body": "GetExtentInfo()$0",
    "description": "(Server) Method: CNavArea:GetExtentInfo\n\n"
  },
  "CNavArea:GetHidingSpots": {
    "prefix": "GetHidingSpots",
    "body": "GetHidingSpots()$0",
    "description": "(Server) Method: CNavArea:GetHidingSpots\n\nReturns a table of good hiding spots in this area"
  },
  "CNavArea:GetID": {
    "prefix": "GetID",
    "body": "GetID()$0",
    "description": "(Server) Method: CNavArea:GetID\n\nReturns this CNavAreas unique ID."
  },
  "CNavArea:GetIncomingConnections": {
    "prefix": "GetIncomingConnections",
    "body": "GetIncomingConnections()$0",
    "description": "(Server) Method: CNavArea:GetIncomingConnections\n\nReturns a table of all the CNavAreas that have a one-way connection '''to''' this Type.CNavArea."
  },
  "CNavArea:GetIncomingConnectionsAtSide": {
    "prefix": "GetIncomingConnectionsAtSide",
    "body": "GetIncomingConnectionsAtSide(${1:number navDir})$0",
    "description": "(Server) Method: CNavArea:GetIncomingConnectionsAtSide\n\nReturns a table of all the CNavAreas that have a one-way connection '''to''' this Type.CNavArea from given direction."
  },
  "CNavArea:GetLadders": {
    "prefix": "GetLadders",
    "body": "GetLadders()$0",
    "description": "(Server) Method: CNavArea:GetLadders\n\nReturns all CNavLadders that have a ( one or two way ) connection '''from''' this Type.CNavArea."
  },
  "CNavArea:GetLaddersAtSide": {
    "prefix": "GetLaddersAtSide",
    "body": "GetLaddersAtSide(${1:number navDir})$0",
    "description": "(Server) Method: CNavArea:GetLaddersAtSide\n\nReturns all CNavLadders that have a ( one or two way ) connection '''from''' ( one and two way ) this Type.CNavArea in given direction."
  },
  "CNavArea:GetParent": {
    "prefix": "GetParent",
    "body": "GetParent()$0",
    "description": "(Server) Method: CNavArea:GetParent\n\nReturns the parent CNavArea"
  },
  "CNavArea:GetParentHow": {
    "prefix": "GetParentHow",
    "body": "GetParentHow()$0",
    "description": "(Server) Method: CNavArea:GetParentHow\n\nReturns how this CNavArea is connected to its parent."
  },
  "CNavArea:GetRandomAdjacentAreaAtSide": {
    "prefix": "GetRandomAdjacentAreaAtSide",
    "body": "GetRandomAdjacentAreaAtSide(${1:number navDir})$0",
    "description": "(Server) Method: CNavArea:GetRandomAdjacentAreaAtSide\n\nReturns a random CNavArea that has an outgoing ( one or two way ) connection '''from''' this Type.CNavArea in given direction."
  },
  "CNavArea:GetRandomPoint": {
    "prefix": "GetRandomPoint",
    "body": "GetRandomPoint()$0",
    "description": "(Server) Method: CNavArea:GetRandomPoint\n\nReturns a random point on the nav area."
  },
  "CNavArea:GetSizeX": {
    "prefix": "GetSizeX",
    "body": "GetSizeX()$0",
    "description": "(Server) Method: CNavArea:GetSizeX\n\nReturns the width this Nav Area."
  },
  "CNavArea:GetSizeY": {
    "prefix": "GetSizeY",
    "body": "GetSizeY()$0",
    "description": "(Server) Method: CNavArea:GetSizeY\n\nReturns the height of this Nav Area."
  },
  "CNavArea:GetTotalCost": {
    "prefix": "GetTotalCost",
    "body": "GetTotalCost()$0",
    "description": "(Server) Method: CNavArea:GetTotalCost\n\nReturns the total cost of the path."
  },
  "CNavArea:GetZ": {
    "prefix": "GetZ",
    "body": "GetZ(${1:Vector pos})$0",
    "description": "(Server) Method: CNavArea:GetZ\n\nReturns the elevation of this Nav Area at the given position."
  },
  "CNavArea:HasAttributes": {
    "prefix": "HasAttributes",
    "body": "HasAttributes(${1:number attribs})$0",
    "description": "(Server) Method: CNavArea:HasAttributes\n\nReturns true if the given CNavArea has this attribute flag set."
  },
  "CNavArea:IsBlocked": {
    "prefix": "IsBlocked",
    "body": "IsBlocked(${1:number teamID}, ${2:boolean ignoreNavBlockers=false})$0",
    "description": "(Server) Method: CNavArea:IsBlocked\n\n"
  },
  "CNavArea:IsClosed": {
    "prefix": "IsClosed",
    "body": "IsClosed()$0",
    "description": "(Server) Method: CNavArea:IsClosed\n\nReturns whether this node is in the Closed List."
  },
  "CNavArea:IsConnected": {
    "prefix": "IsConnected",
    "body": "IsConnected(${1:CNavArea navArea})$0",
    "description": "(Server) Method: CNavArea:IsConnected\n\nReturns whether this CNavArea has an outgoing ( one or two way ) connection '''to''' given Type.CNavArea."
  },
  "CNavArea:IsConnectedAtSide": {
    "prefix": "IsConnectedAtSide",
    "body": "IsConnectedAtSide(${1:CNavArea navArea}, ${2:number navDirType})$0",
    "description": "(Server) Method: CNavArea:IsConnectedAtSide\n\nReturns whether this CNavArea has an outgoing ( one or two way ) connection '''to''' given Type.CNavArea in given direction."
  },
  "CNavArea:IsCoplanar": {
    "prefix": "IsCoplanar",
    "body": "IsCoplanar(${1:CNavArea navArea})$0",
    "description": "(Server) Method: CNavArea:IsCoplanar\n\nReturns whether this Nav Area is in the same plane as the given one."
  },
  "CNavArea:IsFlat": {
    "prefix": "IsFlat",
    "body": "IsFlat()$0",
    "description": "(Server) Method: CNavArea:IsFlat\n\nReturns whether this Nav Area is flat within the tolerance of the '''nav_coplanar_slope_limit_displacement''' and '''nav_coplanar_slope_limit''' convars."
  },
  "CNavArea:IsOpen": {
    "prefix": "IsOpen",
    "body": "IsOpen()$0",
    "description": "(Server) Method: CNavArea:IsOpen\n\nReturns whether this area is in the Open List."
  },
  "CNavArea:IsOpenListEmpty": {
    "prefix": "IsOpenListEmpty",
    "body": "IsOpenListEmpty()$0",
    "description": "(Server) Method: CNavArea:IsOpenListEmpty\n\nReturns whether the Open List is empty or not."
  },
  "CNavArea:IsOverlapping": {
    "prefix": "IsOverlapping",
    "body": "IsOverlapping(${1:Vector pos}, ${2:number tolerance=0})$0",
    "description": "(Server) Method: CNavArea:IsOverlapping\n\nReturns if this position overlaps the Nav Area within the given tolerance."
  },
  "CNavArea:IsOverlappingArea": {
    "prefix": "IsOverlappingArea",
    "body": "IsOverlappingArea(${1:CNavArea navArea})$0",
    "description": "(Server) Method: CNavArea:IsOverlappingArea\n\nReturns true if this CNavArea is overlapping the given Type.CNavArea."
  },
  "CNavArea:IsRoughlySquare": {
    "prefix": "IsRoughlySquare",
    "body": "IsRoughlySquare()$0",
    "description": "(Server) Method: CNavArea:IsRoughlySquare\n\nReturns if we're shaped like a square."
  },
  "CNavArea:IsUnderwater": {
    "prefix": "IsUnderwater",
    "body": "IsUnderwater()$0",
    "description": "(Server) Method: CNavArea:IsUnderwater\n\nWhether this Nav Area is placed underwater."
  },
  "CNavArea:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Server) Method: CNavArea:IsValid\n\nReturns whether this CNavArea is valid or not."
  },
  "CNavArea:IsVisible": {
    "prefix": "IsVisible",
    "body": "IsVisible(${1:Vector pos})$0",
    "description": "(Server) Method: CNavArea:IsVisible\n\nReturns whether we can be seen from the given position."
  },
  "CNavArea:PlaceOnGround": {
    "prefix": "PlaceOnGround",
    "body": "PlaceOnGround(${1:number corner})$0",
    "description": "(Server) Method: CNavArea:PlaceOnGround\n\nDrops a corner or all corners of a CNavArea to the ground below it."
  },
  "CNavArea:PopOpenList": {
    "prefix": "PopOpenList",
    "body": "PopOpenList()$0",
    "description": "(Server) Method: CNavArea:PopOpenList\n\nRemoves a CNavArea from the Open List with the lowest cost to traverse to from the starting node, and returns it."
  },
  "CNavArea:Remove": {
    "prefix": "Remove",
    "body": "Remove()$0",
    "description": "(Server) Method: CNavArea:Remove\n\nRemoves the given nav area."
  },
  "CNavArea:RemoveFromClosedList": {
    "prefix": "RemoveFromClosedList",
    "body": "RemoveFromClosedList()$0",
    "description": "(Server) Method: CNavArea:RemoveFromClosedList\n\nRemoves this node from the Closed List."
  },
  "CNavArea:SetAttributes": {
    "prefix": "SetAttributes",
    "body": "SetAttributes(${1:number attribs})$0",
    "description": "(Server) Method: CNavArea:SetAttributes\n\nSets the attributes for given CNavArea."
  },
  "CNavArea:SetCorner": {
    "prefix": "SetCorner",
    "body": "SetCorner(${1:number corner}, ${2:Vector position})$0",
    "description": "(Server) Method: CNavArea:SetCorner\n\nSets the position of a corner of a nav area."
  },
  "CNavArea:SetParent": {
    "prefix": "SetParent",
    "body": "SetParent(${1:CNavArea parent})$0",
    "description": "(Server) Method: CNavArea:SetParent\n\nSets the new parent of this CNavArea."
  },
  "CNavArea:SetTotalCost": {
    "prefix": "SetTotalCost",
    "body": "SetTotalCost(${1:number cost})$0",
    "description": "(Server) Method: CNavArea:SetTotalCost\n\nSets the total cost of the path."
  },
  "CNavArea:UpdateOnOpenList": {
    "prefix": "UpdateOnOpenList",
    "body": "UpdateOnOpenList()$0",
    "description": "(Server) Method: CNavArea:UpdateOnOpenList\n\n\"A smaller value has been found, update this area on the open list\""
  },
  "CNavLadder:ConnectTo": {
    "prefix": "ConnectTo",
    "body": "ConnectTo(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavLadder:ConnectTo\n\nConnects this ladder to a CNavArea with a one way connection. ( From this ladder to the target area )."
  },
  "CNavLadder:Disconnect": {
    "prefix": "Disconnect",
    "body": "Disconnect(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavLadder:Disconnect\n\nDisconnects this ladder from given area. ( Only disconnects one way )"
  },
  "CNavLadder:GetBottomArea": {
    "prefix": "GetBottomArea",
    "body": "GetBottomArea()$0",
    "description": "(Server) Method: CNavLadder:GetBottomArea\n\nReturns the bottom area of the CNavLadder."
  },
  "CNavLadder:GetID": {
    "prefix": "GetID",
    "body": "GetID()$0",
    "description": "(Server) Method: CNavLadder:GetID\n\nReturns this CNavLadders unique ID."
  },
  "CNavLadder:GetLength": {
    "prefix": "GetLength",
    "body": "GetLength()$0",
    "description": "(Server) Method: CNavLadder:GetLength\n\nReturns the length of the ladder."
  },
  "CNavLadder:GetNormal": {
    "prefix": "GetNormal",
    "body": "GetNormal()$0",
    "description": "(Server) Method: CNavLadder:GetNormal\n\nReturns the direction of this CNavLadder. ( The direction in which players back will be facing if they are looking directly at the ladder )"
  },
  "CNavLadder:GetPosAtHeight": {
    "prefix": "GetPosAtHeight",
    "body": "GetPosAtHeight(${1:number height})$0",
    "description": "(Server) Method: CNavLadder:GetPosAtHeight\n\nReturns the world position based on given height relative to the ladder."
  },
  "CNavLadder:GetTopBehindArea": {
    "prefix": "GetTopBehindArea",
    "body": "GetTopBehindArea()$0",
    "description": "(Server) Method: CNavLadder:GetTopBehindArea\n\nReturns the top behind CNavArea of the Type.CNavLadder."
  },
  "CNavLadder:GetTopForwardArea": {
    "prefix": "GetTopForwardArea",
    "body": "GetTopForwardArea()$0",
    "description": "(Server) Method: CNavLadder:GetTopForwardArea\n\nReturns the top forward CNavArea of the Type.CNavLadder."
  },
  "CNavLadder:GetTopLeftArea": {
    "prefix": "GetTopLeftArea",
    "body": "GetTopLeftArea()$0",
    "description": "(Server) Method: CNavLadder:GetTopLeftArea\n\nReturns the top left CNavArea of the Type.CNavLadder."
  },
  "CNavLadder:GetTopRightArea": {
    "prefix": "GetTopRightArea",
    "body": "GetTopRightArea()$0",
    "description": "(Server) Method: CNavLadder:GetTopRightArea\n\nReturns the top right CNavArea of the Type.CNavLadder."
  },
  "CNavLadder:IsConnectedAtSide": {
    "prefix": "IsConnectedAtSide",
    "body": "IsConnectedAtSide(${1:CNavArea navArea}, ${2:number navDirType})$0",
    "description": "(Server) Method: CNavLadder:IsConnectedAtSide\n\nReturns whether this CNavLadder has an outgoing ( one or two way ) connection '''to''' given Type.CNavArea in given direction."
  },
  "CNavLadder:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Server) Method: CNavLadder:IsValid\n\nReturns whether this CNavLadder is valid or not."
  },
  "CNavLadder:Remove": {
    "prefix": "Remove",
    "body": "Remove()$0",
    "description": "(Server) Method: CNavLadder:Remove\n\nRemoves the given nav ladder."
  },
  "CNavLadder:SetBottomArea": {
    "prefix": "SetBottomArea",
    "body": "SetBottomArea(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavLadder:SetBottomArea\n\nSets the bottom area of the CNavLadder."
  },
  "CNavLadder:SetTopBehindArea": {
    "prefix": "SetTopBehindArea",
    "body": "SetTopBehindArea(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavLadder:SetTopBehindArea\n\nSets the top behind area of the CNavLadder."
  },
  "CNavLadder:SetTopForwardArea": {
    "prefix": "SetTopForwardArea",
    "body": "SetTopForwardArea(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavLadder:SetTopForwardArea\n\nSets the top forward area of the CNavLadder."
  },
  "CNavLadder:SetTopLeftArea": {
    "prefix": "SetTopLeftArea",
    "body": "SetTopLeftArea(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavLadder:SetTopLeftArea\n\nSets the top left area of the CNavLadder."
  },
  "CNavLadder:SetTopRightArea": {
    "prefix": "SetTopRightArea",
    "body": "SetTopRightArea(${1:CNavArea area})$0",
    "description": "(Server) Method: CNavLadder:SetTopRightArea\n\nSets the top right area of the CNavLadder."
  },
  "CNewParticleEffect:AddControlPoint": {
    "prefix": "AddControlPoint",
    "body": "AddControlPoint(${1:number cpID}, ${2:Entity ent}, ${3:number partAttachment}, ${4:number entAttachment=0}, ${5:Vector offset=Vector( 0, 0, 0 )})$0",
    "description": "(Client) Method: CNewParticleEffect:AddControlPoint\n\nAdds a control point to the particle system."
  },
  "CNewParticleEffect:GetAutoUpdateBBox": {
    "prefix": "GetAutoUpdateBBox",
    "body": "GetAutoUpdateBBox()$0",
    "description": "(Client) Method: CNewParticleEffect:GetAutoUpdateBBox\n\n"
  },
  "CNewParticleEffect:GetEffectName": {
    "prefix": "GetEffectName",
    "body": "GetEffectName()$0",
    "description": "(Client) Method: CNewParticleEffect:GetEffectName\n\nReturns the name of the particle effect this system is set to emit."
  },
  "CNewParticleEffect:GetHighestControlPoint": {
    "prefix": "GetHighestControlPoint",
    "body": "GetHighestControlPoint()$0",
    "description": "(Client) Method: CNewParticleEffect:GetHighestControlPoint\n\nReturns the highest control point number for given particle system."
  },
  "CNewParticleEffect:GetOwner": {
    "prefix": "GetOwner",
    "body": "GetOwner()$0",
    "description": "(Client) Method: CNewParticleEffect:GetOwner\n\nReturns the owner of the particle system, the entity the particle system is attached to."
  },
  "CNewParticleEffect:IsFinished": {
    "prefix": "IsFinished",
    "body": "IsFinished()$0",
    "description": "(Client) Method: CNewParticleEffect:IsFinished\n\nReturns whether the particle system has finished emitting particles or not."
  },
  "CNewParticleEffect:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Client) Method: CNewParticleEffect:IsValid\n\nReturns whether the particle system is valid or not."
  },
  "CNewParticleEffect:IsViewModelEffect": {
    "prefix": "IsViewModelEffect",
    "body": "IsViewModelEffect()$0",
    "description": "(Client) Method: CNewParticleEffect:IsViewModelEffect\n\nReturns whether the particle system is intended to be used on a view model?"
  },
  "CNewParticleEffect:Render": {
    "prefix": "Render",
    "body": "Render()$0",
    "description": "(Client) Method: CNewParticleEffect:Render\n\nForces the particle system to render using current rendering context."
  },
  "CNewParticleEffect:Restart": {
    "prefix": "Restart",
    "body": "Restart()$0",
    "description": "(Client) Method: CNewParticleEffect:Restart\n\nForces the particle system to restart emitting particles."
  },
  "CNewParticleEffect:SetControlPoint": {
    "prefix": "SetControlPoint",
    "body": "SetControlPoint(${1:number cpID}, ${2:Vector value})$0",
    "description": "(Client) Method: CNewParticleEffect:SetControlPoint\n\nSets a value for given control point."
  },
  "CNewParticleEffect:SetControlPointEntity": {
    "prefix": "SetControlPointEntity",
    "body": "SetControlPointEntity(${1:number child}, ${2:Entity parent})$0",
    "description": "(Client) Method: CNewParticleEffect:SetControlPointEntity\n\nEssentially makes child control point follow the parent entity."
  },
  "CNewParticleEffect:SetControlPointForwardVector": {
    "prefix": "SetControlPointForwardVector",
    "body": "SetControlPointForwardVector(${1:number cpID}, ${2:Vector forward})$0",
    "description": "(Client) Method: CNewParticleEffect:SetControlPointForwardVector\n\nSets the forward direction for given control point."
  },
  "CNewParticleEffect:SetControlPointOrientation": {
    "prefix": "SetControlPointOrientation",
    "body": "SetControlPointOrientation(${1:number cpID}, ${2:Vector forward}, ${3:Vector right}, ${4:Vector up})$0",
    "description": "(Client) Method: CNewParticleEffect:SetControlPointOrientation\n\nSets the orientation for given control point."
  },
  "CNewParticleEffect:SetControlPointParent": {
    "prefix": "SetControlPointParent",
    "body": "SetControlPointParent(${1:number child}, ${2:number parent})$0",
    "description": "(Client) Method: CNewParticleEffect:SetControlPointParent\n\nEssentially makes child control point follow the parent control point."
  },
  "CNewParticleEffect:SetControlPointRightVector": {
    "prefix": "SetControlPointRightVector",
    "body": "SetControlPointRightVector(${1:number cpID}, ${2:Vector right})$0",
    "description": "(Client) Method: CNewParticleEffect:SetControlPointRightVector\n\nSets the right direction for given control point."
  },
  "CNewParticleEffect:SetControlPointUpVector": {
    "prefix": "SetControlPointUpVector",
    "body": "SetControlPointUpVector(${1:number cpID}, ${2:Vector upward})$0",
    "description": "(Client) Method: CNewParticleEffect:SetControlPointUpVector\n\nSets the upward direction for given control point."
  },
  "CNewParticleEffect:SetIsViewModelEffect": {
    "prefix": "SetIsViewModelEffect",
    "body": "SetIsViewModelEffect(${1:boolean isViewModel})$0",
    "description": "(Client) Method: CNewParticleEffect:SetIsViewModelEffect\n\n"
  },
  "CNewParticleEffect:SetShouldDraw": {
    "prefix": "SetShouldDraw",
    "body": "SetShouldDraw(${1:boolean should})$0",
    "description": "(Client) Method: CNewParticleEffect:SetShouldDraw\n\nForces the particle system to stop automatically rendering."
  },
  "CNewParticleEffect:SetSortOrigin": {
    "prefix": "SetSortOrigin",
    "body": "SetSortOrigin(${1:Vector origin})$0",
    "description": "(Client) Method: CNewParticleEffect:SetSortOrigin\n\nSets the sort origin for given particle system. This is used as a helper to determine which particles are in front of which."
  },
  "CNewParticleEffect:StartEmission": {
    "prefix": "StartEmission",
    "body": "StartEmission(${1:boolean infiniteOnly=false})$0",
    "description": "(Client) Method: CNewParticleEffect:StartEmission\n\nStarts the particle emission."
  },
  "CNewParticleEffect:StopEmission": {
    "prefix": "StopEmission",
    "body": "StopEmission(${1:boolean infiniteOnly=false}, ${2:boolean removeAllParticles=false}, ${3:boolean wakeOnStop=false})$0",
    "description": "(Client) Method: CNewParticleEffect:StopEmission\n\nStops the particle emission."
  },
  "CNewParticleEffect:StopEmissionAndDestroyImmediately": {
    "prefix": "StopEmissionAndDestroyImmediately",
    "body": "StopEmissionAndDestroyImmediately()$0",
    "description": "(Client) Method: CNewParticleEffect:StopEmissionAndDestroyImmediately\n\nStops particle emission and destroys all particles instantly."
  },
  "ConVar:GetBool": {
    "prefix": "GetBool",
    "body": "GetBool()$0",
    "description": "(Shared) Method: ConVar:GetBool\n\nTries to convert the current string value of a ConVar to a boolean."
  },
  "ConVar:GetDefault": {
    "prefix": "GetDefault",
    "body": "GetDefault()$0",
    "description": "(Shared) Method: ConVar:GetDefault\n\nReturns the default value of the ConVar"
  },
  "ConVar:GetFloat": {
    "prefix": "GetFloat",
    "body": "GetFloat()$0",
    "description": "(Shared) Method: ConVar:GetFloat\n\nAttempts to convert the ConVar value to a float"
  },
  "ConVar:GetHelpText": {
    "prefix": "GetHelpText",
    "body": "GetHelpText()$0",
    "description": "(Shared) Method: ConVar:GetHelpText\n\nReturns the help text assigned to that convar."
  },
  "ConVar:GetInt": {
    "prefix": "GetInt",
    "body": "GetInt()$0",
    "description": "(Shared) Method: ConVar:GetInt\n\nAttempts to convert the ConVar value to a integer."
  },
  "ConVar:GetName": {
    "prefix": "GetName",
    "body": "GetName()$0",
    "description": "(Shared) Method: ConVar:GetName\n\nReturns the name of the ConVar."
  },
  "ConVar:GetString": {
    "prefix": "GetString",
    "body": "GetString()$0",
    "description": "(Shared) Method: ConVar:GetString\n\nReturns the current ConVar value as a string."
  },
  "ConVar:SetBool": {
    "prefix": "SetBool",
    "body": "SetBool(${1:boolean value})$0",
    "description": "(Shared) Method: ConVar:SetBool\n\nSets a ConVar's value to 1 or 0 based on the input boolean. This can only be ran on ConVars created from within Lua."
  },
  "ConVar:SetFloat": {
    "prefix": "SetFloat",
    "body": "SetFloat(${1:number value})$0",
    "description": "(Shared) Method: ConVar:SetFloat\n\nSets a ConVar's value to to the input number. This can only be ran on ConVars created from within Lua."
  },
  "ConVar:SetInt": {
    "prefix": "SetInt",
    "body": "SetInt(${1:number value})$0",
    "description": "(Shared) Method: ConVar:SetInt\n\nSets a ConVar's value to the input number after converting it to an integer. This can only be ran on ConVars created from within Lua."
  },
  "ConVar:SetString": {
    "prefix": "SetString",
    "body": "SetString(${1:string value})$0",
    "description": "(Shared) Method: ConVar:SetString\n\nSets a ConVar's value to the input string. This can only be ran on ConVars created from within Lua."
  },
  "CRecipientFilter:AddAllPlayers": {
    "prefix": "AddAllPlayers",
    "body": "AddAllPlayers()$0",
    "description": "(Server) Method: CRecipientFilter:AddAllPlayers\n\nAdds all players to the recipient filter."
  },
  "CRecipientFilter:AddPAS": {
    "prefix": "AddPAS",
    "body": "AddPAS(${1:Vector pos})$0",
    "description": "(Server) Method: CRecipientFilter:AddPAS\n\nAdds all players that are in the same PAS as this position."
  },
  "CRecipientFilter:AddPlayer": {
    "prefix": "AddPlayer",
    "body": "AddPlayer(${1:Player Player})$0",
    "description": "(Server) Method: CRecipientFilter:AddPlayer\n\nAdds a player to the recipient filter"
  },
  "CRecipientFilter:AddPVS": {
    "prefix": "AddPVS",
    "body": "AddPVS(${1:Vector Position})$0",
    "description": "(Server) Method: CRecipientFilter:AddPVS\n\nAdds all players that are in the same PVS as this position."
  },
  "CRecipientFilter:AddRecipientsByTeam": {
    "prefix": "AddRecipientsByTeam",
    "body": "AddRecipientsByTeam(${1:number teamid})$0",
    "description": "(Server) Method: CRecipientFilter:AddRecipientsByTeam\n\nAdds all players that are on the given team to the filter."
  },
  "CRecipientFilter:GetCount": {
    "prefix": "GetCount",
    "body": "GetCount()$0",
    "description": "(Server) Method: CRecipientFilter:GetCount\n\nReturns the number of valid players in the recipient filter."
  },
  "CRecipientFilter:GetPlayers": {
    "prefix": "GetPlayers",
    "body": "GetPlayers()$0",
    "description": "(Server) Method: CRecipientFilter:GetPlayers\n\nReturns a table of all valid players currently in the recipient filter."
  },
  "CRecipientFilter:RemoveAllPlayers": {
    "prefix": "RemoveAllPlayers",
    "body": "RemoveAllPlayers()$0",
    "description": "(Server) Method: CRecipientFilter:RemoveAllPlayers\n\nRemoves all players from the recipient filter."
  },
  "CRecipientFilter:RemovePAS": {
    "prefix": "RemovePAS",
    "body": "RemovePAS(${1:Vector position})$0",
    "description": "(Server) Method: CRecipientFilter:RemovePAS\n\nRemoves all players from the filter that are in Potentially Audible Set for given position."
  },
  "CRecipientFilter:RemovePlayer": {
    "prefix": "RemovePlayer",
    "body": "RemovePlayer(${1:Player Player})$0",
    "description": "(Server) Method: CRecipientFilter:RemovePlayer\n\nRemoves the player from the recipient filter."
  },
  "CRecipientFilter:RemovePVS": {
    "prefix": "RemovePVS",
    "body": "RemovePVS(${1:Vector pos})$0",
    "description": "(Server) Method: CRecipientFilter:RemovePVS\n\nRemoves all players that can see this PVS from the recipient filter."
  },
  "CRecipientFilter:RemoveRecipientsByTeam": {
    "prefix": "RemoveRecipientsByTeam",
    "body": "RemoveRecipientsByTeam(${1:number teamid})$0",
    "description": "(Server) Method: CRecipientFilter:RemoveRecipientsByTeam\n\nRemoves all players that are on the given team from the filter."
  },
  "CRecipientFilter:RemoveRecipientsNotOnTeam": {
    "prefix": "RemoveRecipientsNotOnTeam",
    "body": "RemoveRecipientsNotOnTeam(${1:number teamid})$0",
    "description": "(Server) Method: CRecipientFilter:RemoveRecipientsNotOnTeam\n\nRemoves all players that are not on the given team from the filter."
  },
  "CSEnt:Remove": {
    "prefix": "Remove",
    "body": "Remove()$0",
    "description": "(Client) Method: CSEnt:Remove\n\nRemoves the clientside entity"
  },
  "CSoundPatch:ChangePitch": {
    "prefix": "ChangePitch",
    "body": "ChangePitch(${1:number pitch}, ${2:number deltaTime=0})$0",
    "description": "(Shared) Method: CSoundPatch:ChangePitch\n\nAdjust the pitch, alias the speed at which the sound is being played."
  },
  "CSoundPatch:ChangeVolume": {
    "prefix": "ChangeVolume",
    "body": "ChangeVolume(${1:number volume}, ${2:number deltaTime=0})$0",
    "description": "(Shared) Method: CSoundPatch:ChangeVolume\n\nAdjusts the volume of the sound played."
  },
  "CSoundPatch:FadeOut": {
    "prefix": "FadeOut",
    "body": "FadeOut(${1:number seconds})$0",
    "description": "(Shared) Method: CSoundPatch:FadeOut\n\nFades out the volume of the sound from the current volume to 0 in the given amount of seconds."
  },
  "CSoundPatch:GetDSP": {
    "prefix": "GetDSP",
    "body": "GetDSP()$0",
    "description": "(Shared) Method: CSoundPatch:GetDSP\n\nReturns the DSP ( Digital Signal Processor ) effect for the sound."
  },
  "CSoundPatch:GetPitch": {
    "prefix": "GetPitch",
    "body": "GetPitch()$0",
    "description": "(Shared) Method: CSoundPatch:GetPitch\n\nReturns the current pitch."
  },
  "CSoundPatch:GetSoundLevel": {
    "prefix": "GetSoundLevel",
    "body": "GetSoundLevel()$0",
    "description": "(Shared) Method: CSoundPatch:GetSoundLevel\n\nReturns the current sound level."
  },
  "CSoundPatch:GetVolume": {
    "prefix": "GetVolume",
    "body": "GetVolume()$0",
    "description": "(Shared) Method: CSoundPatch:GetVolume\n\nReturns the current volume."
  },
  "CSoundPatch:IsPlaying": {
    "prefix": "IsPlaying",
    "body": "IsPlaying()$0",
    "description": "(Shared) Method: CSoundPatch:IsPlaying\n\nReturns whenever the sound is being played."
  },
  "CSoundPatch:Play": {
    "prefix": "Play",
    "body": "Play()$0",
    "description": "(Shared) Method: CSoundPatch:Play\n\nStarts to play the sound."
  },
  "CSoundPatch:PlayEx": {
    "prefix": "PlayEx",
    "body": "PlayEx(${1:number volume}, ${2:number pitch})$0",
    "description": "(Shared) Method: CSoundPatch:PlayEx\n\nSame as CSoundPatch.Play but with 2 extra arguments allowing to set volume and pitch directly."
  },
  "CSoundPatch:SetDSP": {
    "prefix": "SetDSP",
    "body": "SetDSP(${1:number dsp})$0",
    "description": "(Shared) Method: CSoundPatch:SetDSP\n\nSets the DSP ( Digital Signal Processor ) effect for the sound. Similar to Player.SetDSP"
  },
  "CSoundPatch:SetSoundLevel": {
    "prefix": "SetSoundLevel",
    "body": "SetSoundLevel(${1:number level})$0",
    "description": "(Shared) Method: CSoundPatch:SetSoundLevel\n\nSets the sound level in decibel."
  },
  "CSoundPatch:Stop": {
    "prefix": "Stop",
    "body": "Stop()$0",
    "description": "(Shared) Method: CSoundPatch:Stop\n\nStops the sound from being played."
  },
  "CTakeDamageInfo:AddDamage": {
    "prefix": "AddDamage",
    "body": "AddDamage(${1:number damageIncrease})$0",
    "description": "(Shared) Method: CTakeDamageInfo:AddDamage\n\nIncreases the damage by damageIncrease."
  },
  "CTakeDamageInfo:GetAmmoType": {
    "prefix": "GetAmmoType",
    "body": "GetAmmoType()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetAmmoType\n\nReturns the ammo type used by the weapon that inflicted the damage."
  },
  "CTakeDamageInfo:GetAttacker": {
    "prefix": "GetAttacker",
    "body": "GetAttacker()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetAttacker\n\nReturns the attacker ( character who originated the attack ), for example a player or an NPC that shot the weapon."
  },
  "CTakeDamageInfo:GetBaseDamage": {
    "prefix": "GetBaseDamage",
    "body": "GetBaseDamage()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetBaseDamage\n\nReturns the initial unmodified by skill level ( game.GetSkillLevel ) damage."
  },
  "CTakeDamageInfo:GetDamage": {
    "prefix": "GetDamage",
    "body": "GetDamage()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetDamage\n\nReturns the total damage."
  },
  "CTakeDamageInfo:GetDamageBonus": {
    "prefix": "GetDamageBonus",
    "body": "GetDamageBonus()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetDamageBonus\n\n"
  },
  "CTakeDamageInfo:GetDamageCustom": {
    "prefix": "GetDamageCustom",
    "body": "GetDamageCustom()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetDamageCustom\n\n"
  },
  "CTakeDamageInfo:GetDamageForce": {
    "prefix": "GetDamageForce",
    "body": "GetDamageForce()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetDamageForce\n\nReturns a vector representing the damage force."
  },
  "CTakeDamageInfo:GetDamagePosition": {
    "prefix": "GetDamagePosition",
    "body": "GetDamagePosition()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetDamagePosition\n\nReturns the position where the damage was or is going to be applied to."
  },
  "CTakeDamageInfo:GetDamageType": {
    "prefix": "GetDamageType",
    "body": "GetDamageType()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetDamageType\n\nReturns a bitflag which indicates the damage type(s) of the damage."
  },
  "CTakeDamageInfo:GetInflictor": {
    "prefix": "GetInflictor",
    "body": "GetInflictor()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetInflictor\n\nReturns the inflictor of the damage. This is not necessarily a weapon."
  },
  "CTakeDamageInfo:GetMaxDamage": {
    "prefix": "GetMaxDamage",
    "body": "GetMaxDamage()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetMaxDamage\n\nReturns the maximum damage."
  },
  "CTakeDamageInfo:GetReportedPosition": {
    "prefix": "GetReportedPosition",
    "body": "GetReportedPosition()$0",
    "description": "(Shared) Method: CTakeDamageInfo:GetReportedPosition\n\nReturns the initial, unmodified position where the damage occured."
  },
  "CTakeDamageInfo:IsBulletDamage": {
    "prefix": "IsBulletDamage",
    "body": "IsBulletDamage()$0",
    "description": "(Shared) Method: CTakeDamageInfo:IsBulletDamage\n\nReturns true if the damage was caused by a bullet."
  },
  "CTakeDamageInfo:IsDamageType": {
    "prefix": "IsDamageType",
    "body": "IsDamageType(${1:number dmgType})$0",
    "description": "(Shared) Method: CTakeDamageInfo:IsDamageType\n\nReturns whenever the damageinfo contains the damage type specified."
  },
  "CTakeDamageInfo:IsExplosionDamage": {
    "prefix": "IsExplosionDamage",
    "body": "IsExplosionDamage()$0",
    "description": "(Shared) Method: CTakeDamageInfo:IsExplosionDamage\n\nReturns whenever the damageinfo contains explosion damage."
  },
  "CTakeDamageInfo:IsFallDamage": {
    "prefix": "IsFallDamage",
    "body": "IsFallDamage()$0",
    "description": "(Shared) Method: CTakeDamageInfo:IsFallDamage\n\nReturns whenever the damageinfo contains fall damage."
  },
  "CTakeDamageInfo:ScaleDamage": {
    "prefix": "ScaleDamage",
    "body": "ScaleDamage(${1:number scale})$0",
    "description": "(Shared) Method: CTakeDamageInfo:ScaleDamage\n\nScales the damage by the given value."
  },
  "CTakeDamageInfo:SetAmmoType": {
    "prefix": "SetAmmoType",
    "body": "SetAmmoType(${1:number ammoType})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetAmmoType\n\nChanges the ammo type used by the weapon that inflicted the damage."
  },
  "CTakeDamageInfo:SetAttacker": {
    "prefix": "SetAttacker",
    "body": "SetAttacker(${1:Entity ent})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetAttacker\n\nSets the attacker ( character who originated the attack ) of the damage, for example a player or an NPC."
  },
  "CTakeDamageInfo:SetDamage": {
    "prefix": "SetDamage",
    "body": "SetDamage(${1:number damage})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetDamage\n\nSets the amount of damage."
  },
  "CTakeDamageInfo:SetDamageBonus": {
    "prefix": "SetDamageBonus",
    "body": "SetDamageBonus(${1:number damage})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetDamageBonus\n\nAdds bonus damage, like CTakeDamageInfo.AddDamage does."
  },
  "CTakeDamageInfo:SetDamageCustom": {
    "prefix": "SetDamageCustom",
    "body": "SetDamageCustom(${1:number })$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetDamageCustom\n\n"
  },
  "CTakeDamageInfo:SetDamageForce": {
    "prefix": "SetDamageForce",
    "body": "SetDamageForce(${1:Vector force})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetDamageForce\n\nSets the directional force of the damage."
  },
  "CTakeDamageInfo:SetDamagePosition": {
    "prefix": "SetDamagePosition",
    "body": "SetDamagePosition(${1:Vector pos})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetDamagePosition\n\nSets the position of where the damage gets applied to."
  },
  "CTakeDamageInfo:SetDamageType": {
    "prefix": "SetDamageType",
    "body": "SetDamageType(${1:number type})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetDamageType\n\nSets the damage type."
  },
  "CTakeDamageInfo:SetInflictor": {
    "prefix": "SetInflictor",
    "body": "SetInflictor(${1:Entity inflictor})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetInflictor\n\nSets the inflictor of the damage for example a weapon."
  },
  "CTakeDamageInfo:SetMaxDamage": {
    "prefix": "SetMaxDamage",
    "body": "SetMaxDamage(${1:number maxDamage})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetMaxDamage\n\nSets the maximum damage the object can cause."
  },
  "CTakeDamageInfo:SetReportedPosition": {
    "prefix": "SetReportedPosition",
    "body": "SetReportedPosition(${1:Vector pos})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SetReportedPosition\n\nSets the origin of the damage."
  },
  "CTakeDamageInfo:SubtractDamage": {
    "prefix": "SubtractDamage",
    "body": "SubtractDamage(${1:number damage})$0",
    "description": "(Shared) Method: CTakeDamageInfo:SubtractDamage\n\nSubtracts the specified amount from the damage."
  },
  "CUserCmd:ClearButtons": {
    "prefix": "ClearButtons",
    "body": "ClearButtons()$0",
    "description": "(Shared) Method: CUserCmd:ClearButtons\n\nRemoves all keys from the command."
  },
  "CUserCmd:ClearMovement": {
    "prefix": "ClearMovement",
    "body": "ClearMovement()$0",
    "description": "(Shared) Method: CUserCmd:ClearMovement\n\nClears the movement from the command."
  },
  "CUserCmd:CommandNumber": {
    "prefix": "CommandNumber",
    "body": "CommandNumber()$0",
    "description": "(Shared) Method: CUserCmd:CommandNumber\n\nReturns an increasing number representing the index of the user cmd. The value returned is occasionally 0 inside GM.CreateMove, so it's advised to check for a non-zero value if you wish to get the correct number."
  },
  "CUserCmd:GetButtons": {
    "prefix": "GetButtons",
    "body": "GetButtons()$0",
    "description": "(Shared) Method: CUserCmd:GetButtons\n\nReturns a bitflag indicating which buttons are pressed."
  },
  "CUserCmd:GetForwardMove": {
    "prefix": "GetForwardMove",
    "body": "GetForwardMove()$0",
    "description": "(Shared) Method: CUserCmd:GetForwardMove\n\nThe speed the client wishes to move forward with, negative if the clients wants to move backwards."
  },
  "CUserCmd:GetImpulse": {
    "prefix": "GetImpulse",
    "body": "GetImpulse()$0",
    "description": "(Shared) Method: CUserCmd:GetImpulse\n\nGets the current impulse from the client, usually 0."
  },
  "CUserCmd:GetMouseWheel": {
    "prefix": "GetMouseWheel",
    "body": "GetMouseWheel()$0",
    "description": "(Shared) Method: CUserCmd:GetMouseWheel\n\nReturns the scroll delta as whole number."
  },
  "CUserCmd:GetMouseX": {
    "prefix": "GetMouseX",
    "body": "GetMouseX()$0",
    "description": "(Shared) Method: CUserCmd:GetMouseX\n\nReturns the delta of the angular horizontal mouse movement of the player."
  },
  "CUserCmd:GetMouseY": {
    "prefix": "GetMouseY",
    "body": "GetMouseY()$0",
    "description": "(Shared) Method: CUserCmd:GetMouseY\n\nReturns the delta of the angular vertical mouse movement of the player."
  },
  "CUserCmd:GetSideMove": {
    "prefix": "GetSideMove",
    "body": "GetSideMove()$0",
    "description": "(Shared) Method: CUserCmd:GetSideMove\n\nThe speed the client wishes to move sideways with, positive if it wants to move right, negative if it wants to move left."
  },
  "CUserCmd:GetUpMove": {
    "prefix": "GetUpMove",
    "body": "GetUpMove()$0",
    "description": "(Shared) Method: CUserCmd:GetUpMove\n\nThe speed the client wishes to move up with, negative if the clients wants to move down."
  },
  "CUserCmd:GetViewAngles": {
    "prefix": "GetViewAngles",
    "body": "GetViewAngles()$0",
    "description": "(Shared) Method: CUserCmd:GetViewAngles\n\nGets the direction the player is looking in."
  },
  "CUserCmd:IsForced": {
    "prefix": "IsForced",
    "body": "IsForced()$0",
    "description": "(Shared) Method: CUserCmd:IsForced\n\nWhen players are not sending usercommands to the server (often due to lag), their last usercommand will be executed multiple times as a backup. This function returns true if that is happening."
  },
  "CUserCmd:KeyDown": {
    "prefix": "KeyDown",
    "body": "KeyDown(${1:number key})$0",
    "description": "(Shared) Method: CUserCmd:KeyDown\n\nReturns true if the specified button(s) is pressed."
  },
  "CUserCmd:RemoveKey": {
    "prefix": "RemoveKey",
    "body": "RemoveKey(${1:number button})$0",
    "description": "(Shared) Method: CUserCmd:RemoveKey\n\nRemoved a key bit from the current key bitflag."
  },
  "CUserCmd:SelectWeapon": {
    "prefix": "SelectWeapon",
    "body": "SelectWeapon(${1:Weapon weapon})$0",
    "description": "(Shared) Method: CUserCmd:SelectWeapon\n\nForces the associated player to select a weapon."
  },
  "CUserCmd:SetButtons": {
    "prefix": "SetButtons",
    "body": "SetButtons(${1:number buttons})$0",
    "description": "(Shared) Method: CUserCmd:SetButtons\n\nSets the buttons as a bitflag. See also CUserCmd.GetButtons."
  },
  "CUserCmd:SetForwardMove": {
    "prefix": "SetForwardMove",
    "body": "SetForwardMove(${1:number speed})$0",
    "description": "(Shared) Method: CUserCmd:SetForwardMove\n\nSets speed the client wishes to move forward with, negative if the clients wants to move backwards."
  },
  "CUserCmd:SetImpulse": {
    "prefix": "SetImpulse",
    "body": "SetImpulse(${1:number speed})$0",
    "description": "(Shared) Method: CUserCmd:SetImpulse\n\nSets the impulse command to be sent to the server."
  },
  "CUserCmd:SetMouseWheel": {
    "prefix": "SetMouseWheel",
    "body": "SetMouseWheel(${1:number speed})$0",
    "description": "(Shared) Method: CUserCmd:SetMouseWheel\n\nSets the scroll delta."
  },
  "CUserCmd:SetMouseX": {
    "prefix": "SetMouseX",
    "body": "SetMouseX(${1:number speed})$0",
    "description": "(Shared) Method: CUserCmd:SetMouseX\n\nSets the delta of the angular horizontal mouse movement of the player."
  },
  "CUserCmd:SetMouseY": {
    "prefix": "SetMouseY",
    "body": "SetMouseY(${1:number speed})$0",
    "description": "(Shared) Method: CUserCmd:SetMouseY\n\nSets the delta of the angular vertical mouse movement of the player."
  },
  "CUserCmd:SetSideMove": {
    "prefix": "SetSideMove",
    "body": "SetSideMove(${1:number speed})$0",
    "description": "(Shared) Method: CUserCmd:SetSideMove\n\nSets speed the client wishes to move sidewards with, positive to move right, negative to move left."
  },
  "CUserCmd:SetUpMove": {
    "prefix": "SetUpMove",
    "body": "SetUpMove(${1:number speed})$0",
    "description": "(Shared) Method: CUserCmd:SetUpMove\n\nSets speed the client wishes to move upwards with, negative to move down."
  },
  "CUserCmd:SetViewAngles": {
    "prefix": "SetViewAngles",
    "body": "SetViewAngles(${1:Angle viewAngle})$0",
    "description": "(Shared) Method: CUserCmd:SetViewAngles\n\nSets the direction the client wants to move in."
  },
  "CUserCmd:TickCount": {
    "prefix": "TickCount",
    "body": "TickCount()$0",
    "description": "(Shared) Method: CUserCmd:TickCount\n\nReturns tick count since joining the server."
  },
  "DFrame:GetTitle": {
    "prefix": "GetTitle",
    "body": "GetTitle()$0",
    "description": "(Client) Method: DFrame:GetTitle\n\nGets the title of the frame."
  },
  "Entity:Activate": {
    "prefix": "Activate",
    "body": "Activate()$0",
    "description": "(Shared) Method: Entity:Activate\n\nActivates the entity. This needs to be used on some entities (like constraints) after being spawned."
  },
  "Entity:AddCallback": {
    "prefix": "AddCallback",
    "body": "AddCallback(${1:string hook}, ${2:function func})$0",
    "description": "(Shared) Method: Entity:AddCallback\n\nAdd a callback function to a specific event. This is used instead of hooks to avoid calling empty functions unnecessarily."
  },
  "Entity:AddEffects": {
    "prefix": "AddEffects",
    "body": "AddEffects(${1:number effect})$0",
    "description": "(Shared) Method: Entity:AddEffects\n\nApplies an engine effect to an entity."
  },
  "Entity:AddEFlags": {
    "prefix": "AddEFlags",
    "body": "AddEFlags(${1:number flag})$0",
    "description": "(Shared) Method: Entity:AddEFlags\n\nAdds engine flags."
  },
  "Entity:AddFlags": {
    "prefix": "AddFlags",
    "body": "AddFlags(${1:number flag})$0",
    "description": "(Shared) Method: Entity:AddFlags\n\nAdds flags to the entity."
  },
  "Entity:AddGesture": {
    "prefix": "AddGesture",
    "body": "AddGesture(${1:number activity}, ${2:boolean autokill=true})$0",
    "description": "(Server) Method: Entity:AddGesture\n\nAdds a gesture animation to the entity and plays it."
  },
  "Entity:AddGestureSequence": {
    "prefix": "AddGestureSequence",
    "body": "AddGestureSequence(${1:number sequence}, ${2:boolean autokill=true})$0",
    "description": "(Server) Method: Entity:AddGestureSequence\n\nAdds a gesture animation to the entity and plays it."
  },
  "Entity:AddLayeredSequence": {
    "prefix": "AddLayeredSequence",
    "body": "AddLayeredSequence(${1:number sequence}, ${2:number priority})$0",
    "description": "(Server) Method: Entity:AddLayeredSequence\n\nAdds a gesture animation to the entity and plays it."
  },
  "Entity:AddSolidFlags": {
    "prefix": "AddSolidFlags",
    "body": "AddSolidFlags(${1:number flags})$0",
    "description": "(Shared) Method: Entity:AddSolidFlags\n\nAdds solid flag(s) to the entity."
  },
  "Entity:AddToMotionController": {
    "prefix": "AddToMotionController",
    "body": "AddToMotionController(${1:PhysObj physObj})$0",
    "description": "(Shared) Method: Entity:AddToMotionController\n\nAdds a PhysObject to the entity's motion controller so that ENTITY.PhysicsSimulate will be called for given Type.PhysObject as well."
  },
  "Entity:AlignAngles": {
    "prefix": "AlignAngles",
    "body": "AlignAngles(${1:Angle from}, ${2:Angle to})$0",
    "description": "(Shared) Method: Entity:AlignAngles\n\nReturns an angle based on the ones inputted that you can use to align an object."
  },
  "Entity:BecomeRagdollOnClient": {
    "prefix": "BecomeRagdollOnClient",
    "body": "BecomeRagdollOnClient()$0",
    "description": "(Client) Method: Entity:BecomeRagdollOnClient\n\nSpawns a clientside ragdoll for the entity, positioning it in place of the original entity, and makes the entity invisible. It doesn't preserve flex values (face posing) as CSRagdolls don't support flex."
  },
  "Entity:Blocked": {
    "prefix": "Blocked",
    "body": "Blocked(${1:Entity entity})$0",
    "description": "(Server) Method: Entity:Blocked\n\n[Internal]  Dispatches blocked events to this entity's blocked handler. This function is only useful when interacting with entities like func_movelinear."
  },
  "Entity:BodyTarget": {
    "prefix": "BodyTarget",
    "body": "BodyTarget(${1:Vector origin}, ${2:boolean noisy=false})$0",
    "description": "(Server) Method: Entity:BodyTarget\n\nReturns a centered vector of this entity, NPCs use this internally to aim at their targets."
  },
  "Entity:BoneHasFlag": {
    "prefix": "BoneHasFlag",
    "body": "BoneHasFlag(${1:number boneID}, ${2:number flag})$0",
    "description": "(Shared) Method: Entity:BoneHasFlag\n\nReturns whether the entity's bone has the flag or not."
  },
  "Entity:BoneLength": {
    "prefix": "BoneLength",
    "body": "BoneLength(${1:number boneID})$0",
    "description": "(Shared) Method: Entity:BoneLength\n\nThis function takes the boneID and returns the length of it in an unrounded decimal"
  },
  "Entity:BoundingRadius": {
    "prefix": "BoundingRadius",
    "body": "BoundingRadius()$0",
    "description": "(Shared) Method: Entity:BoundingRadius\n\nReturns the distance between the center of the bounding box and the furthest bounding box corner."
  },
  "Entity:CallOnRemove": {
    "prefix": "CallOnRemove",
    "body": "CallOnRemove(${1:string identifier}, ${2:function removeFunc}, ${3:vararg argn...})$0",
    "description": "(Shared) Method: Entity:CallOnRemove\n\nCauses a specified function to be run if the entity is removed by any means."
  },
  "Entity:ClearPoseParameters": {
    "prefix": "ClearPoseParameters",
    "body": "ClearPoseParameters()$0",
    "description": "(Shared) Method: Entity:ClearPoseParameters\n\nResets all pose parameters such as aim_yaw, aim_pitch and rotation."
  },
  "Entity:CollisionRulesChanged": {
    "prefix": "CollisionRulesChanged",
    "body": "CollisionRulesChanged()$0",
    "description": "(Shared) Method: Entity:CollisionRulesChanged\n\nDeclares that the collision rules of the entity have changed, and subsequent calls for GM.ShouldCollide with this entity may return a different value than they did previously."
  },
  "Entity:CreatedByMap": {
    "prefix": "CreatedByMap",
    "body": "CreatedByMap()$0",
    "description": "(Server) Method: Entity:CreatedByMap\n\nReturns whether the entity was created by map or not."
  },
  "Entity:CreateParticleEffect": {
    "prefix": "CreateParticleEffect",
    "body": "CreateParticleEffect(${1:string particle}, ${2:number attachment}, ${3:table options=nil})$0",
    "description": "(Client) Method: Entity:CreateParticleEffect\n\nCreates a clientside particle system attached to the entity."
  },
  "Entity:CreateShadow": {
    "prefix": "CreateShadow",
    "body": "CreateShadow()$0",
    "description": "(Shared) Method: Entity:CreateShadow\n\nDraws the shadow of an entity."
  },
  "Entity:DeleteOnRemove": {
    "prefix": "DeleteOnRemove",
    "body": "DeleteOnRemove(${1:Entity entityToRemove})$0",
    "description": "(Server) Method: Entity:DeleteOnRemove\n\nWhenever the entity is removed, entityToRemove will be removed also."
  },
  "Entity:DestroyShadow": {
    "prefix": "DestroyShadow",
    "body": "DestroyShadow()$0",
    "description": "(Client) Method: Entity:DestroyShadow\n\nRemoves the shadow for the entity."
  },
  "Entity:DisableMatrix": {
    "prefix": "DisableMatrix",
    "body": "DisableMatrix(${1:string matrixType})$0",
    "description": "(Client) Method: Entity:DisableMatrix\n\nDisables an active matrix."
  },
  "Entity:DispatchTraceAttack": {
    "prefix": "DispatchTraceAttack",
    "body": "DispatchTraceAttack(${1:CTakeDamageInfo damageInfo}, ${2:table traceRes}, ${3:Vector dir=traceRes.HitNormal})$0",
    "description": "(Shared) Method: Entity:DispatchTraceAttack\n\nPerforms a trace attack."
  },
  "Entity:DontDeleteOnRemove": {
    "prefix": "DontDeleteOnRemove",
    "body": "DontDeleteOnRemove(${1:Entity entityToUnremove})$0",
    "description": "(Server) Method: Entity:DontDeleteOnRemove\n\nThis removes the argument entity from an ent's list of entities to 'delete on remove'"
  },
  "Entity:DrawModel": {
    "prefix": "DrawModel",
    "body": "DrawModel()$0",
    "description": "(Client) Method: Entity:DrawModel\n\nDraws the entity or model."
  },
  "Entity:DrawShadow": {
    "prefix": "DrawShadow",
    "body": "DrawShadow(${1:boolean shouldDraw})$0",
    "description": "(Shared) Method: Entity:DrawShadow\n\nSets whether an entity's shadow should be drawn."
  },
  "Entity:DropToFloor": {
    "prefix": "DropToFloor",
    "body": "DropToFloor()$0",
    "description": "(Server) Method: Entity:DropToFloor\n\nMove an entity down until it collides with something."
  },
  "Entity:DTVar": {
    "prefix": "DTVar",
    "body": "DTVar(${1:string Type}, ${2:number ID}, ${3:string Name})$0",
    "description": "(Shared) Method: Entity:DTVar\n\n[Internal] "
  },
  "Entity:EmitSound": {
    "prefix": "EmitSound",
    "body": "EmitSound(${1:string soundName}, ${2:number soundLevel=75}, ${3:number pitchPercent=100}, ${4:number volume=1}, ${5:number channel=CHAN_AUTO})$0",
    "description": "(Shared) Method: Entity:EmitSound\n\nPlays a sound on an entity. If run clientside, the sound will only be heard locally."
  },
  "Entity:EnableConstraints": {
    "prefix": "EnableConstraints",
    "body": "EnableConstraints(${1:boolean toggleConstraints})$0",
    "description": "(Server) Method: Entity:EnableConstraints\n\nToggles the constraints of this ragdoll entity on and off."
  },
  "Entity:EnableCustomCollisions": {
    "prefix": "EnableCustomCollisions",
    "body": "EnableCustomCollisions(${1:boolean useCustom})$0",
    "description": "(Shared) Method: Entity:EnableCustomCollisions\n\nFlags an entity as using custom lua defined collisions. Fixes entities having spongy player collisions or not hitting traces, such as after Entity.PhysicsFromMesh"
  },
  "Entity:EnableMatrix": {
    "prefix": "EnableMatrix",
    "body": "EnableMatrix(${1:string matrixType}, ${2:VMatrix matrix})$0",
    "description": "(Client) Method: Entity:EnableMatrix\n\nCan be used to apply a custom VMatrix to the entity, mostly used for scaling the model by a Type.Vector."
  },
  "Entity:EntIndex": {
    "prefix": "EntIndex",
    "body": "EntIndex()$0",
    "description": "(Shared) Method: Entity:EntIndex\n\nGets the unique entity index of an entity."
  },
  "Entity:Extinguish": {
    "prefix": "Extinguish",
    "body": "Extinguish()$0",
    "description": "(Server) Method: Entity:Extinguish\n\nExtinguishes the entity if it is on fire."
  },
  "Entity:EyeAngles": {
    "prefix": "EyeAngles",
    "body": "EyeAngles()$0",
    "description": "(Shared) Method: Entity:EyeAngles\n\nReturns the direction a player/npc/ragdoll is looking as a world-oriented angle."
  },
  "Entity:EyePos": {
    "prefix": "EyePos",
    "body": "EyePos()$0",
    "description": "(Shared) Method: Entity:EyePos\n\nReturns the position of an Player/NPC's view, or two vectors for ragdolls (one for each eye)"
  },
  "Entity:FindBodygroupByName": {
    "prefix": "FindBodygroupByName",
    "body": "FindBodygroupByName(${1:string name})$0",
    "description": "(Shared) Method: Entity:FindBodygroupByName\n\nSearches for bodygroup with given name."
  },
  "Entity:FindTransitionSequence": {
    "prefix": "FindTransitionSequence",
    "body": "FindTransitionSequence(${1:number currentSequence}, ${2:number goalSequence})$0",
    "description": "(Shared) Method: Entity:FindTransitionSequence\n\nReturns a transition from the given start and end sequence."
  },
  "Entity:Fire": {
    "prefix": "Fire",
    "body": "Fire(${1:string input}, ${2:string param=\"\"}, ${3:number delay=0})$0",
    "description": "(Server) Method: Entity:Fire\n\nFires an entity's input. You can find inputs for most entities on the [https://developer.valvesoftware.com/wiki/Output Valve Developer Wiki]"
  },
  "Entity:FireBullets": {
    "prefix": "FireBullets",
    "body": "FireBullets(${1:table bulletInfo}, ${2:boolean suppressHostEvents=false})$0",
    "description": "(Shared) Method: Entity:FireBullets\n\nFires a bullet."
  },
  "Entity:FollowBone": {
    "prefix": "FollowBone",
    "body": "FollowBone(${1:Entity parent=NULL}, ${2:number boneid})$0",
    "description": "(Shared) Method: Entity:FollowBone\n\nMakes an entity follow another entity's bone."
  },
  "Entity:ForcePlayerDrop": {
    "prefix": "ForcePlayerDrop",
    "body": "ForcePlayerDrop()$0",
    "description": "(Shared) Method: Entity:ForcePlayerDrop\n\nForces the Entity to be dropped, when it is being held by a player's gravitygun or physgun."
  },
  "Entity:FrameAdvance": {
    "prefix": "FrameAdvance",
    "body": "FrameAdvance(${1:number delta})$0",
    "description": "(Shared) Method: Entity:FrameAdvance\n\nAdvances the cycle of an animated entity by the given delta. Since cycle is a value between 0 and 1, delta should be as well."
  },
  "Entity:GetAbsVelocity": {
    "prefix": "GetAbsVelocity",
    "body": "GetAbsVelocity()$0",
    "description": "(Shared) Method: Entity:GetAbsVelocity\n\nReturns the velocity of the entity, in coordinates relative to the world."
  },
  "Entity:GetAngles": {
    "prefix": "GetAngles",
    "body": "GetAngles()$0",
    "description": "(Shared) Method: Entity:GetAngles\n\nGets the angles of given entity."
  },
  "Entity:GetAnimInfo": {
    "prefix": "GetAnimInfo",
    "body": "GetAnimInfo(${1:number animIndex})$0",
    "description": "(Shared) Method: Entity:GetAnimInfo\n\nReturns a table containing the number of frames, flags, name, and FPS of an entity's animation ID."
  },
  "Entity:GetAnimTime": {
    "prefix": "GetAnimTime",
    "body": "GetAnimTime()$0",
    "description": "(Client) Method: Entity:GetAnimTime\n\nReturns the last time the entity had an animation update. Returns 0 if the entity doesn't animate."
  },
  "Entity:GetAttachment": {
    "prefix": "GetAttachment",
    "body": "GetAttachment(${1:number attachmentId})$0",
    "description": "(Shared) Method: Entity:GetAttachment\n\nGets the orientation and position of the attachment by its ID, returns nothing if the attachment does not exist."
  },
  "Entity:GetAttachments": {
    "prefix": "GetAttachments",
    "body": "GetAttachments()$0",
    "description": "(Shared) Method: Entity:GetAttachments\n\nReturns a table containing all attachments of the given entitys model."
  },
  "Entity:GetBaseVelocity": {
    "prefix": "GetBaseVelocity",
    "body": "GetBaseVelocity()$0",
    "description": "(Shared) Method: Entity:GetBaseVelocity\n\nReturns the base velocity of the entity. \"Velocity of the thing we're standing on\"."
  },
  "Entity:GetBloodColor": {
    "prefix": "GetBloodColor",
    "body": "GetBloodColor()$0",
    "description": "(Server) Method: Entity:GetBloodColor\n\nReturns the blood color of this entity. This can be set with Entity.SetBloodColor."
  },
  "Entity:GetBodygroup": {
    "prefix": "GetBodygroup",
    "body": "GetBodygroup(${1:number id})$0",
    "description": "(Shared) Method: Entity:GetBodygroup\n\nGets the exact value for specific bodygroup of given entity."
  },
  "Entity:GetBodygroupCount": {
    "prefix": "GetBodygroupCount",
    "body": "GetBodygroupCount(${1:number bodygroup})$0",
    "description": "(Shared) Method: Entity:GetBodygroupCount\n\nReturns the count of possible values for this bodygroup."
  },
  "Entity:GetBodygroupName": {
    "prefix": "GetBodygroupName",
    "body": "GetBodygroupName(${1:number id})$0",
    "description": "(Shared) Method: Entity:GetBodygroupName\n\nGets the name of specific bodygroup for given entity."
  },
  "Entity:GetBodyGroups": {
    "prefix": "GetBodyGroups",
    "body": "GetBodyGroups()$0",
    "description": "(Shared) Method: Entity:GetBodyGroups\n\nReturns a list of all attachments of the entity."
  },
  "Entity:GetBoneController": {
    "prefix": "GetBoneController",
    "body": "GetBoneController(${1:number boneID})$0",
    "description": "(Shared) Method: Entity:GetBoneController\n\nReturns the value of the bone controller with the specified ID."
  },
  "Entity:GetBoneCount": {
    "prefix": "GetBoneCount",
    "body": "GetBoneCount()$0",
    "description": "(Shared) Method: Entity:GetBoneCount\n\nReturns the amount of bones in the entity."
  },
  "Entity:GetBoneMatrix": {
    "prefix": "GetBoneMatrix",
    "body": "GetBoneMatrix(${1:number boneID})$0",
    "description": "(Shared) Method: Entity:GetBoneMatrix\n\nReturns the matrix ( position / rotation transform ) of a given bone entity."
  },
  "Entity:GetBoneName": {
    "prefix": "GetBoneName",
    "body": "GetBoneName(${1:number index})$0",
    "description": "(Shared) Method: Entity:GetBoneName\n\nReturns name of given bone id."
  },
  "Entity:GetBoneParent": {
    "prefix": "GetBoneParent",
    "body": "GetBoneParent(${1:number bone})$0",
    "description": "(Shared) Method: Entity:GetBoneParent\n\nReturns parent bone of given bone."
  },
  "Entity:GetBonePosition": {
    "prefix": "GetBonePosition",
    "body": "GetBonePosition(${1:number boneIndex})$0",
    "description": "(Shared) Method: Entity:GetBonePosition\n\nReturns the position and angle of the given attachment, relative to the world."
  },
  "Entity:GetBrushPlane": {
    "prefix": "GetBrushPlane",
    "body": "GetBrushPlane(${1:number id})$0",
    "description": "(Shared) Method: Entity:GetBrushPlane\n\nReturns info about given plane of non-nodraw brush model surfaces of the entity's model."
  },
  "Entity:GetBrushPlaneCount": {
    "prefix": "GetBrushPlaneCount",
    "body": "GetBrushPlaneCount()$0",
    "description": "(Shared) Method: Entity:GetBrushPlaneCount\n\nReturns the amount of planes of non-nodraw brush model surfaces of the entity's model."
  },
  "Entity:GetCallbacks": {
    "prefix": "GetCallbacks",
    "body": "GetCallbacks(${1:string hook})$0",
    "description": "(Shared) Method: Entity:GetCallbacks\n\nReturns the specified hook callbacks for this entity added with Entity.AddCallback"
  },
  "Entity:GetChildBones": {
    "prefix": "GetChildBones",
    "body": "GetChildBones(${1:number boneid})$0",
    "description": "(Shared) Method: Entity:GetChildBones\n\nReturns ids of child bones of given bone."
  },
  "Entity:GetChildren": {
    "prefix": "GetChildren",
    "body": "GetChildren()$0",
    "description": "(Shared) Method: Entity:GetChildren\n\nGets the children of the entity - that is, every entity whose parent is this entity."
  },
  "Entity:GetClass": {
    "prefix": "GetClass",
    "body": "GetClass()$0",
    "description": "(Shared) Method: Entity:GetClass\n\nReturns the classname of a entity. This is often the name of the Lua file or folder containing the files for the entity"
  },
  "Entity:GetCollisionBounds": {
    "prefix": "GetCollisionBounds",
    "body": "GetCollisionBounds()$0",
    "description": "(Shared) Method: Entity:GetCollisionBounds\n\nReturns an entity's collision bounding box. In most cases, this will return the same bounding box as Entity.GetModelBounds unless the entity does not have a physics mesh or it has a PhysObj different from the default."
  },
  "Entity:GetCollisionGroup": {
    "prefix": "GetCollisionGroup",
    "body": "GetCollisionGroup()$0",
    "description": "(Shared) Method: Entity:GetCollisionGroup\n\nReturns the entity's collision group"
  },
  "Entity:GetColor": {
    "prefix": "GetColor",
    "body": "GetColor()$0",
    "description": "(Shared) Method: Entity:GetColor\n\nReturns the color the entity is set to."
  },
  "Entity:GetConstrainedEntities": {
    "prefix": "GetConstrainedEntities",
    "body": "GetConstrainedEntities()$0",
    "description": "(Server) Method: Entity:GetConstrainedEntities\n\nReturns the two entities involved in a constraint ent"
  },
  "Entity:GetConstrainedPhysObjects": {
    "prefix": "GetConstrainedPhysObjects",
    "body": "GetConstrainedPhysObjects()$0",
    "description": "(Server) Method: Entity:GetConstrainedPhysObjects\n\nReturns the two entities physobjects involved in a constraint ent"
  },
  "Entity:GetCreationID": {
    "prefix": "GetCreationID",
    "body": "GetCreationID()$0",
    "description": "(Server) Method: Entity:GetCreationID\n\nReturns entity's creation ID. Unlike Entity.EntIndex or  Entity.MapCreationID, it will always increase and old values won't be reused."
  },
  "Entity:GetCreationTime": {
    "prefix": "GetCreationTime",
    "body": "GetCreationTime()$0",
    "description": "(Shared) Method: Entity:GetCreationTime\n\nReturns the time the entity was created on, relative to _G.CurTime."
  },
  "Entity:GetCreator": {
    "prefix": "GetCreator",
    "body": "GetCreator()$0",
    "description": "(Server) Method: Entity:GetCreator\n\nGets the creator of the SENT."
  },
  "Entity:GetCustomCollisionCheck": {
    "prefix": "GetCustomCollisionCheck",
    "body": "GetCustomCollisionCheck()$0",
    "description": "(Shared) Method: Entity:GetCustomCollisionCheck\n\nReturns whether this entity uses custom collision check set by Entity.SetCustomCollisionCheck."
  },
  "Entity:GetCycle": {
    "prefix": "GetCycle",
    "body": "GetCycle()$0",
    "description": "(Shared) Method: Entity:GetCycle\n\nReturns the frame of the currently played sequence."
  },
  "Entity:GetDTAngle": {
    "prefix": "GetDTAngle",
    "body": "GetDTAngle(${1:number key})$0",
    "description": "(Shared) Method: Entity:GetDTAngle\n\n[Internal] "
  },
  "Entity:GetDTBool": {
    "prefix": "GetDTBool",
    "body": "GetDTBool(${1:number key})$0",
    "description": "(Shared) Method: Entity:GetDTBool\n\n[Internal] "
  },
  "Entity:GetDTEntity": {
    "prefix": "GetDTEntity",
    "body": "GetDTEntity(${1:number key})$0",
    "description": "(Shared) Method: Entity:GetDTEntity\n\n[Internal] "
  },
  "Entity:GetDTFloat": {
    "prefix": "GetDTFloat",
    "body": "GetDTFloat(${1:number key})$0",
    "description": "(Shared) Method: Entity:GetDTFloat\n\n[Internal] "
  },
  "Entity:GetDTInt": {
    "prefix": "GetDTInt",
    "body": "GetDTInt(${1:number key})$0",
    "description": "(Shared) Method: Entity:GetDTInt\n\n[Internal] "
  },
  "Entity:GetDTString": {
    "prefix": "GetDTString",
    "body": "GetDTString(${1:number key})$0",
    "description": "(Shared) Method: Entity:GetDTString\n\n[Internal] "
  },
  "Entity:GetDTVector": {
    "prefix": "GetDTVector",
    "body": "GetDTVector(${1:number key})$0",
    "description": "(Shared) Method: Entity:GetDTVector\n\n[Internal] "
  },
  "Entity:GetEffects": {
    "prefix": "GetEffects",
    "body": "GetEffects()$0",
    "description": "(Shared) Method: Entity:GetEffects\n\nReturns a bit flag of all engine effect flags of the entity."
  },
  "Entity:GetEFlags": {
    "prefix": "GetEFlags",
    "body": "GetEFlags()$0",
    "description": "(Shared) Method: Entity:GetEFlags\n\nReturns a bit flag of all engine flags of the entity."
  },
  "Entity:GetElasticity": {
    "prefix": "GetElasticity",
    "body": "GetElasticity()$0",
    "description": "(Shared) Method: Entity:GetElasticity\n\nReturns the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding."
  },
  "Entity:GetFlags": {
    "prefix": "GetFlags",
    "body": "GetFlags()$0",
    "description": "(Shared) Method: Entity:GetFlags\n\nReturns all flags of given entity."
  },
  "Entity:GetFlexBounds": {
    "prefix": "GetFlexBounds",
    "body": "GetFlexBounds(${1:number flex})$0",
    "description": "(Shared) Method: Entity:GetFlexBounds\n\nReturns acceptable value range for the flex."
  },
  "Entity:GetFlexIDByName": {
    "prefix": "GetFlexIDByName",
    "body": "GetFlexIDByName(${1:string name})$0",
    "description": "(Shared) Method: Entity:GetFlexIDByName\n\nReturns the ID of the flex based on given name."
  },
  "Entity:GetFlexName": {
    "prefix": "GetFlexName",
    "body": "GetFlexName(${1:number id})$0",
    "description": "(Shared) Method: Entity:GetFlexName\n\nReturns flex name."
  },
  "Entity:GetFlexNum": {
    "prefix": "GetFlexNum",
    "body": "GetFlexNum()$0",
    "description": "(Shared) Method: Entity:GetFlexNum\n\nReturns the number of flexes this entity has."
  },
  "Entity:GetFlexScale": {
    "prefix": "GetFlexScale",
    "body": "GetFlexScale()$0",
    "description": "(Shared) Method: Entity:GetFlexScale\n\nReturns the flex scale of the entity."
  },
  "Entity:GetFlexWeight": {
    "prefix": "GetFlexWeight",
    "body": "GetFlexWeight(${1:number flex})$0",
    "description": "(Shared) Method: Entity:GetFlexWeight\n\nReturns current weight ( value ) of the flex."
  },
  "Entity:GetForward": {
    "prefix": "GetForward",
    "body": "GetForward()$0",
    "description": "(Shared) Method: Entity:GetForward\n\nReturns the forward vector of the entity, as a normalized direction vector"
  },
  "Entity:GetFriction": {
    "prefix": "GetFriction",
    "body": "GetFriction()$0",
    "description": "(Server) Method: Entity:GetFriction\n\nReturns how much friction an entity has. Entities default to 1 (100%) and can be higher or even negative."
  },
  "Entity:GetGravity": {
    "prefix": "GetGravity",
    "body": "GetGravity()$0",
    "description": "(Shared) Method: Entity:GetGravity\n\nGets the gravity multiplier of the entity."
  },
  "Entity:GetGroundEntity": {
    "prefix": "GetGroundEntity",
    "body": "GetGroundEntity()$0",
    "description": "(Shared) Method: Entity:GetGroundEntity\n\nReturns the object the entity is standing on."
  },
  "Entity:GetGroundSpeedVelocity": {
    "prefix": "GetGroundSpeedVelocity",
    "body": "GetGroundSpeedVelocity()$0",
    "description": "(Server) Method: Entity:GetGroundSpeedVelocity\n\nReturns the entity's ground speed velocity, which is based on the entity's walk/run speed and/or the ground speed of their sequence ( Entity.GetSequenceGroundSpeed ). Will return an empty Vector if the entity isn't moving on the ground."
  },
  "Entity:GetHitBoxBone": {
    "prefix": "GetHitBoxBone",
    "body": "GetHitBoxBone(${1:number hitbox}, ${2:number group})$0",
    "description": "(Shared) Method: Entity:GetHitBoxBone\n\nGets the bone of a hit box"
  },
  "Entity:GetHitboxBone": {
    "prefix": "GetHitboxBone",
    "body": "GetHitboxBone()$0",
    "description": "(Server) Method: Entity:GetHitboxBone\n\n[Deprecated] .You should use Entity.GetHitBoxBone instead."
  },
  "Entity:GetHitBoxBounds": {
    "prefix": "GetHitBoxBounds",
    "body": "GetHitBoxBounds(${1:number hitbox}, ${2:number group})$0",
    "description": "(Shared) Method: Entity:GetHitBoxBounds\n\nGets the bounding box of a hit box"
  },
  "Entity:GetHitBoxCount": {
    "prefix": "GetHitBoxCount",
    "body": "GetHitBoxCount(${1:number group})$0",
    "description": "(Shared) Method: Entity:GetHitBoxCount\n\nGets how many hit boxes are in a given hit box group"
  },
  "Entity:GetHitBoxGroupCount": {
    "prefix": "GetHitBoxGroupCount",
    "body": "GetHitBoxGroupCount()$0",
    "description": "(Shared) Method: Entity:GetHitBoxGroupCount\n\nReturns the number of hit box groups that an entity has."
  },
  "Entity:GetHitboxSet": {
    "prefix": "GetHitboxSet",
    "body": "GetHitboxSet()$0",
    "description": "(Shared) Method: Entity:GetHitboxSet\n\nReturns entity's current hit box set"
  },
  "Entity:GetHitboxSetCount": {
    "prefix": "GetHitboxSetCount",
    "body": "GetHitboxSetCount()$0",
    "description": "(Shared) Method: Entity:GetHitboxSetCount\n\nReturns the amount of hitbox sets in the entity."
  },
  "Entity:GetInternalVariable": {
    "prefix": "GetInternalVariable",
    "body": "GetInternalVariable(${1:string VariableName})$0",
    "description": "(Shared) Method: Entity:GetInternalVariable\n\nAn interface for accessing internal key values on entities."
  },
  "Entity:GetKeyValues": {
    "prefix": "GetKeyValues",
    "body": "GetKeyValues()$0",
    "description": "(Server) Method: Entity:GetKeyValues\n\nReturns a table containing all key values the entity has."
  },
  "Entity:GetLayerCycle": {
    "prefix": "GetLayerCycle",
    "body": "GetLayerCycle(${1:number layerID})$0",
    "description": "(Server) Method: Entity:GetLayerCycle\n\nReturns the animation cycle/frame for given layer."
  },
  "Entity:GetLayerDuration": {
    "prefix": "GetLayerDuration",
    "body": "GetLayerDuration(${1:number layerID})$0",
    "description": "(Server) Method: Entity:GetLayerDuration\n\nReturns the duration of given layer."
  },
  "Entity:GetLayerWeight": {
    "prefix": "GetLayerWeight",
    "body": "GetLayerWeight(${1:number layerID})$0",
    "description": "(Server) Method: Entity:GetLayerWeight\n\nReturns the current weight of the layer. See Entity.SetLayerWeight for more information."
  },
  "Entity:GetLocalAngles": {
    "prefix": "GetLocalAngles",
    "body": "GetLocalAngles()$0",
    "description": "(Shared) Method: Entity:GetLocalAngles\n\nReturns the rotation of the entity relative to its parent entity."
  },
  "Entity:GetLocalAngularVelocity": {
    "prefix": "GetLocalAngularVelocity",
    "body": "GetLocalAngularVelocity()$0",
    "description": "(Shared) Method: Entity:GetLocalAngularVelocity\n\nReturns the non-VPhysics angular velocity of the entity relative to its parent entity."
  },
  "Entity:GetLocalPos": {
    "prefix": "GetLocalPos",
    "body": "GetLocalPos()$0",
    "description": "(Shared) Method: Entity:GetLocalPos\n\nReturns entity's position relative to it's parent."
  },
  "Entity:GetManipulateBoneAngles": {
    "prefix": "GetManipulateBoneAngles",
    "body": "GetManipulateBoneAngles(${1:number boneID})$0",
    "description": "(Shared) Method: Entity:GetManipulateBoneAngles\n\nGets the entity's angle manipulation of the given bone. This is relative to the default angle, so the angle is zero when unmodified."
  },
  "Entity:GetManipulateBoneJiggle": {
    "prefix": "GetManipulateBoneJiggle",
    "body": "GetManipulateBoneJiggle(${1:number boneID})$0",
    "description": "(Shared) Method: Entity:GetManipulateBoneJiggle\n\n"
  },
  "Entity:GetManipulateBonePosition": {
    "prefix": "GetManipulateBonePosition",
    "body": "GetManipulateBonePosition(${1:number boneId})$0",
    "description": "(Shared) Method: Entity:GetManipulateBonePosition\n\nGets the entity's position manipulation of the given bone. This is relative to the default position, so it is zero when unmodified."
  },
  "Entity:GetManipulateBoneScale": {
    "prefix": "GetManipulateBoneScale",
    "body": "GetManipulateBoneScale(${1:number boneID})$0",
    "description": "(Shared) Method: Entity:GetManipulateBoneScale\n\nGets the entity's scale manipulation of the given bone. Normal scale is Vector( 1, 1, 1 )"
  },
  "Entity:GetMaterial": {
    "prefix": "GetMaterial",
    "body": "GetMaterial()$0",
    "description": "(Shared) Method: Entity:GetMaterial\n\nReturns the material override for this entity. "
  },
  "Entity:GetMaterials": {
    "prefix": "GetMaterials",
    "body": "GetMaterials()$0",
    "description": "(Shared) Method: Entity:GetMaterials\n\nReturns all materials of the entity's model."
  },
  "Entity:GetMaterialType": {
    "prefix": "GetMaterialType",
    "body": "GetMaterialType()$0",
    "description": "(Server) Method: Entity:GetMaterialType\n\nReturns the surface material of this entity."
  },
  "Entity:GetMaxHealth": {
    "prefix": "GetMaxHealth",
    "body": "GetMaxHealth()$0",
    "description": "(Shared) Method: Entity:GetMaxHealth\n\nReturns the max health that the entity was given. It can be set via Entity.SetMaxHealth."
  },
  "Entity:GetModel": {
    "prefix": "GetModel",
    "body": "GetModel()$0",
    "description": "(Shared) Method: Entity:GetModel\n\nGets the model of given entity."
  },
  "Entity:GetModelBounds": {
    "prefix": "GetModelBounds",
    "body": "GetModelBounds()$0",
    "description": "(Shared) Method: Entity:GetModelBounds\n\nReturns the entity's model bounds. This is different than the collision bounds/hull. This is not scaled with Entity.SetModelScale, and will return the model's original, unmodified mins and maxs."
  },
  "Entity:GetModelPhysBoneCount": {
    "prefix": "GetModelPhysBoneCount",
    "body": "GetModelPhysBoneCount()$0",
    "description": "(Client) Method: Entity:GetModelPhysBoneCount\n\nGets the physics bone count of the entity's model."
  },
  "Entity:GetModelRadius": {
    "prefix": "GetModelRadius",
    "body": "GetModelRadius()$0",
    "description": "(Shared) Method: Entity:GetModelRadius\n\nGets the models radius."
  },
  "Entity:GetModelRenderBounds": {
    "prefix": "GetModelRenderBounds",
    "body": "GetModelRenderBounds()$0",
    "description": "(Shared) Method: Entity:GetModelRenderBounds\n\n"
  },
  "Entity:GetModelScale": {
    "prefix": "GetModelScale",
    "body": "GetModelScale()$0",
    "description": "(Shared) Method: Entity:GetModelScale\n\nGets the selected entity's model scale."
  },
  "Entity:GetMomentaryRotButtonPos": {
    "prefix": "GetMomentaryRotButtonPos",
    "body": "GetMomentaryRotButtonPos(${1:Angle turnAngle})$0",
    "description": "(Server) Method: Entity:GetMomentaryRotButtonPos\n\nReturns the amount a momentary_rot_button entity is turned based on the given Angle turnAngle. 0 meaning completely turned closed, 1 meaning completely turned open."
  },
  "Entity:GetMoveCollide": {
    "prefix": "GetMoveCollide",
    "body": "GetMoveCollide()$0",
    "description": "(Shared) Method: Entity:GetMoveCollide\n\nReturns the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide?"
  },
  "Entity:GetMoveParent": {
    "prefix": "GetMoveParent",
    "body": "GetMoveParent()$0",
    "description": "(Shared) Method: Entity:GetMoveParent\n\nReturns the movement parent of this entity."
  },
  "Entity:GetMoveType": {
    "prefix": "GetMoveType",
    "body": "GetMoveType()$0",
    "description": "(Shared) Method: Entity:GetMoveType\n\nReturns the entity's movetype"
  },
  "Entity:GetName": {
    "prefix": "GetName",
    "body": "GetName()$0",
    "description": "(Server) Method: Entity:GetName\n\nReturns the mapping name of this entity."
  },
  "Entity:GetNetworkAngles": {
    "prefix": "GetNetworkAngles",
    "body": "GetNetworkAngles()$0",
    "description": "(Client) Method: Entity:GetNetworkAngles\n\nGets networked angles for entity."
  },
  "Entity:GetNetworkedAngle": {
    "prefix": "GetNetworkedAngle",
    "body": "GetNetworkedAngle(${1:string key}, ${2:Angle fallback=Angle( 0, 0, 0 )})$0",
    "description": "(Shared) Method: Entity:GetNetworkedAngle\n\n[Deprecated] .You should use Entity.GetNWAngle instead."
  },
  "Entity:GetNetworkedBool": {
    "prefix": "GetNetworkedBool",
    "body": "GetNetworkedBool(${1:string key}, ${2:boolean fallback=false})$0",
    "description": "(Shared) Method: Entity:GetNetworkedBool\n\n[Deprecated] .You should use Entity.GetNWBool instead."
  },
  "Entity:GetNetworkedEntity": {
    "prefix": "GetNetworkedEntity",
    "body": "GetNetworkedEntity(${1:string key}, ${2:Entity fallback=NULL})$0",
    "description": "(Shared) Method: Entity:GetNetworkedEntity\n\n[Deprecated] .You should use Entity.GetNWEntity instead."
  },
  "Entity:GetNetworkedFloat": {
    "prefix": "GetNetworkedFloat",
    "body": "GetNetworkedFloat(${1:string key}, ${2:number fallback=0})$0",
    "description": "(Shared) Method: Entity:GetNetworkedFloat\n\n[Deprecated] .You should use Entity.GetNWFloat instead."
  },
  "Entity:GetNetworkedInt": {
    "prefix": "GetNetworkedInt",
    "body": "GetNetworkedInt(${1:string key}, ${2:number fallback=0})$0",
    "description": "(Shared) Method: Entity:GetNetworkedInt\n\n[Deprecated] .You should use Entity.GetNWInt instead."
  },
  "Entity:GetNetworkedString": {
    "prefix": "GetNetworkedString",
    "body": "GetNetworkedString(${1:string key}, ${2:string fallback=\"\"})$0",
    "description": "(Shared) Method: Entity:GetNetworkedString\n\n[Deprecated] .You should use Entity.GetNWString instead."
  },
  "Entity:GetNetworkedVarProxy": {
    "prefix": "GetNetworkedVarProxy",
    "body": "GetNetworkedVarProxy(${1:string name})$0",
    "description": "(Shared) Method: Entity:GetNetworkedVarProxy\n\n[Deprecated] .You should be using Entity.GetNWVarProxy instead."
  },
  "Entity:GetNetworkedVarTable": {
    "prefix": "GetNetworkedVarTable",
    "body": "GetNetworkedVarTable()$0",
    "description": "(Shared) Method: Entity:GetNetworkedVarTable\n\n[Deprecated] .You should be using Entity.GetNWVarTable instead."
  },
  "Entity:GetNetworkedVector": {
    "prefix": "GetNetworkedVector",
    "body": "GetNetworkedVector(${1:string key}, ${2:Vector fallback=Vector( 0, 0, 0 )})$0",
    "description": "(Shared) Method: Entity:GetNetworkedVector\n\n[Deprecated] .You should use Entity.GetNWVector instead."
  },
  "Entity:GetNetworkOrigin": {
    "prefix": "GetNetworkOrigin",
    "body": "GetNetworkOrigin()$0",
    "description": "(Shared) Method: Entity:GetNetworkOrigin\n\nGets networked origin for entity."
  },
  "Entity:GetNoDraw": {
    "prefix": "GetNoDraw",
    "body": "GetNoDraw()$0",
    "description": "(Shared) Method: Entity:GetNoDraw\n\nReturns if the entity's rendering and transmitting has been disabled."
  },
  "Entity:GetNumBodyGroups": {
    "prefix": "GetNumBodyGroups",
    "body": "GetNumBodyGroups()$0",
    "description": "(Shared) Method: Entity:GetNumBodyGroups\n\nReturns the body group count of the entity."
  },
  "Entity:GetNumPoseParameters": {
    "prefix": "GetNumPoseParameters",
    "body": "GetNumPoseParameters()$0",
    "description": "(Shared) Method: Entity:GetNumPoseParameters\n\nReturns the number of pose parameters this entity has."
  },
  "Entity:GetNWAngle": {
    "prefix": "GetNWAngle",
    "body": "GetNWAngle(${1:string key}, ${2:Angle fallback=Angle( 0, 0, 0 )})$0",
    "description": "(Shared) Method: Entity:GetNWAngle\n\nRetrieves a networked angle value at specified index on the entity that is set by Entity.SetNWAngle."
  },
  "Entity:GetNWBool": {
    "prefix": "GetNWBool",
    "body": "GetNWBool(${1:string key}, ${2:boolean fallback=false})$0",
    "description": "(Shared) Method: Entity:GetNWBool\n\nRetrieves a networked boolean value at specified index on the entity that is set by Entity.SetNWBool."
  },
  "Entity:GetNWEntity": {
    "prefix": "GetNWEntity",
    "body": "GetNWEntity(${1:string key}, ${2:Entity fallback=NULL})$0",
    "description": "(Shared) Method: Entity:GetNWEntity\n\nRetrieves a networked entity value at specified index on the entity that is set by Entity.SetNWEntity."
  },
  "Entity:GetNWFloat": {
    "prefix": "GetNWFloat",
    "body": "GetNWFloat(${1:string key}, ${2:number fallback=0})$0",
    "description": "(Shared) Method: Entity:GetNWFloat\n\nRetrieves a networked float value at specified index on the entity that is set by Entity.SetNWFloat."
  },
  "Entity:GetNWInt": {
    "prefix": "GetNWInt",
    "body": "GetNWInt(${1:string key}, ${2:number fallback=0})$0",
    "description": "(Shared) Method: Entity:GetNWInt\n\nRetrieves a networked integer (whole number) value that was previously set by Entity.SetNWInt."
  },
  "Entity:GetNWString": {
    "prefix": "GetNWString",
    "body": "GetNWString(${1:string key}, ${2:string fallback=\"\"})$0",
    "description": "(Shared) Method: Entity:GetNWString\n\nRetrieves a networked string value at specified index on the entity that is set by Entity.SetNWString."
  },
  "Entity:GetNWVarProxy": {
    "prefix": "GetNWVarProxy",
    "body": "GetNWVarProxy(${1:string name})$0",
    "description": "(Shared) Method: Entity:GetNWVarProxy\n\nReturns callback function for given NWVar of this entity."
  },
  "Entity:GetNWVarTable": {
    "prefix": "GetNWVarTable",
    "body": "GetNWVarTable()$0",
    "description": "(Shared) Method: Entity:GetNWVarTable\n\nReturns all the networked variables in an entity."
  },
  "Entity:GetNWVector": {
    "prefix": "GetNWVector",
    "body": "GetNWVector(${1:string key}, ${2:Vector fallback=Vector( 0, 0, 0 )})$0",
    "description": "(Shared) Method: Entity:GetNWVector\n\nRetrieves a networked vector value at specified index on the entity that is set by Entity.SetNWVector."
  },
  "Entity:GetOwner": {
    "prefix": "GetOwner",
    "body": "GetOwner()$0",
    "description": "(Shared) Method: Entity:GetOwner\n\nReturns the owner entity of this entity. See Entity.SetOwner for more info."
  },
  "Entity:GetParent": {
    "prefix": "GetParent",
    "body": "GetParent()$0",
    "description": "(Shared) Method: Entity:GetParent\n\nReturns the parent entity of this entity."
  },
  "Entity:GetParentAttachment": {
    "prefix": "GetParentAttachment",
    "body": "GetParentAttachment()$0",
    "description": "(Shared) Method: Entity:GetParentAttachment\n\nReturns the attachment index of the entity's parent. Returns 0 if the entity is not parented to a specific attachment or if it isn't parented at all."
  },
  "Entity:GetParentPhysNum": {
    "prefix": "GetParentPhysNum",
    "body": "GetParentPhysNum()$0",
    "description": "(Shared) Method: Entity:GetParentPhysNum\n\nIf the entity is parented to an entity that has a model with multiple physics objects (like a ragdoll), this is used to retrieve what physics object number the entity is parented to on it's parent."
  },
  "Entity:GetPersistent": {
    "prefix": "GetPersistent",
    "body": "GetPersistent()$0",
    "description": "(Shared) Method: Entity:GetPersistent\n\nReturns whether the entity is persistent or not."
  },
  "Entity:GetPhysicsAttacker": {
    "prefix": "GetPhysicsAttacker",
    "body": "GetPhysicsAttacker(${1:number timeLimit})$0",
    "description": "(Server) Method: Entity:GetPhysicsAttacker\n\nReturns player who is claiming kills of physics damage the entity deals."
  },
  "Entity:GetPhysicsObject": {
    "prefix": "GetPhysicsObject",
    "body": "GetPhysicsObject()$0",
    "description": "(Shared) Method: Entity:GetPhysicsObject\n\nReturns the entity's physics object, if the entity has physics."
  },
  "Entity:GetPhysicsObjectCount": {
    "prefix": "GetPhysicsObjectCount",
    "body": "GetPhysicsObjectCount()$0",
    "description": "(Shared) Method: Entity:GetPhysicsObjectCount\n\nReturns the number of physics objects an entity has (usually 1 for non-ragdolls)"
  },
  "Entity:GetPhysicsObjectNum": {
    "prefix": "GetPhysicsObjectNum",
    "body": "GetPhysicsObjectNum(${1:number physNum})$0",
    "description": "(Shared) Method: Entity:GetPhysicsObjectNum\n\nReturns a specific physics object from an entity with multiple PhysObjects (like ragdolls)"
  },
  "Entity:GetPlaybackRate": {
    "prefix": "GetPlaybackRate",
    "body": "GetPlaybackRate()$0",
    "description": "(Shared) Method: Entity:GetPlaybackRate\n\nReturns the playback rate of the main sequence on this entity, with 1.0 being the default speed."
  },
  "Entity:GetPos": {
    "prefix": "GetPos",
    "body": "GetPos()$0",
    "description": "(Shared) Method: Entity:GetPos\n\nGets the position of entity in world."
  },
  "Entity:GetPoseParameter": {
    "prefix": "GetPoseParameter",
    "body": "GetPoseParameter(${1:string name})$0",
    "description": "(Shared) Method: Entity:GetPoseParameter\n\nReturns the pose parameter value"
  },
  "Entity:GetPoseParameterName": {
    "prefix": "GetPoseParameterName",
    "body": "GetPoseParameterName(${1:number id})$0",
    "description": "(Shared) Method: Entity:GetPoseParameterName\n\nReturns name of given pose parameter"
  },
  "Entity:GetPoseParameterRange": {
    "prefix": "GetPoseParameterRange",
    "body": "GetPoseParameterRange(${1:number id})$0",
    "description": "(Shared) Method: Entity:GetPoseParameterRange\n\nReturns pose parameter range"
  },
  "Entity:GetPredictable": {
    "prefix": "GetPredictable",
    "body": "GetPredictable()$0",
    "description": "(Client) Method: Entity:GetPredictable\n\nReturns whether this entity is predictable or not."
  },
  "Entity:GetRagdollOwner": {
    "prefix": "GetRagdollOwner",
    "body": "GetRagdollOwner()$0",
    "description": "(Shared) Method: Entity:GetRagdollOwner\n\nReturns the entity which the ragdoll came from. The opposite of Player.GetRagdollEntity."
  },
  "Entity:GetRenderAngles": {
    "prefix": "GetRenderAngles",
    "body": "GetRenderAngles()$0",
    "description": "(Client) Method: Entity:GetRenderAngles\n\nReturns the entity's render angles, set by Entity.SetRenderAngles in a drawing hook."
  },
  "Entity:GetRenderBounds": {
    "prefix": "GetRenderBounds",
    "body": "GetRenderBounds()$0",
    "description": "(Client) Method: Entity:GetRenderBounds\n\nReturns render bounds of the entity. Can be overridden by Entity.SetRenderBounds."
  },
  "Entity:GetRenderFX": {
    "prefix": "GetRenderFX",
    "body": "GetRenderFX()$0",
    "description": "(Shared) Method: Entity:GetRenderFX\n\nReturns current render FX of the entity."
  },
  "Entity:GetRenderGroup": {
    "prefix": "GetRenderGroup",
    "body": "GetRenderGroup()$0",
    "description": "(Client) Method: Entity:GetRenderGroup\n\nReturns the render group of the entity."
  },
  "Entity:GetRenderMode": {
    "prefix": "GetRenderMode",
    "body": "GetRenderMode()$0",
    "description": "(Shared) Method: Entity:GetRenderMode\n\nReturns the render mode of the entity."
  },
  "Entity:GetRenderOrigin": {
    "prefix": "GetRenderOrigin",
    "body": "GetRenderOrigin()$0",
    "description": "(Client) Method: Entity:GetRenderOrigin\n\nReturns the entity's render origin, set by Entity.SetRenderOrigin in a drawing hook."
  },
  "Entity:GetRight": {
    "prefix": "GetRight",
    "body": "GetRight()$0",
    "description": "(Shared) Method: Entity:GetRight\n\nReturns the rightward vector of the entity, as a normalized direction vector"
  },
  "Entity:GetRotatedAABB": {
    "prefix": "GetRotatedAABB",
    "body": "GetRotatedAABB(${1:Vector min}, ${2:Vector max})$0",
    "description": "(Shared) Method: Entity:GetRotatedAABB\n\nReturns the min and max of the entity's axis-aligned bounding box."
  },
  "Entity:GetSaveTable": {
    "prefix": "GetSaveTable",
    "body": "GetSaveTable()$0",
    "description": "(Shared) Method: Entity:GetSaveTable\n\nReturns a table of save values for an entity."
  },
  "Entity:GetSequence": {
    "prefix": "GetSequence",
    "body": "GetSequence()$0",
    "description": "(Shared) Method: Entity:GetSequence\n\nReturn the index of the model sequence that is currently active for the entity."
  },
  "Entity:GetSequenceActivity": {
    "prefix": "GetSequenceActivity",
    "body": "GetSequenceActivity(${1:number seq})$0",
    "description": "(Shared) Method: Entity:GetSequenceActivity\n\nReturn activity id out of sequence id. Opposite of Entity.SelectWeightedSequence."
  },
  "Entity:GetSequenceActivityName": {
    "prefix": "GetSequenceActivityName",
    "body": "GetSequenceActivityName(${1:number sequenceId})$0",
    "description": "(Shared) Method: Entity:GetSequenceActivityName\n\nReturns the activity name for the given sequence id."
  },
  "Entity:GetSequenceCount": {
    "prefix": "GetSequenceCount",
    "body": "GetSequenceCount()$0",
    "description": "(Shared) Method: Entity:GetSequenceCount\n\nReturns the amount of sequences ( animations ) the entity's model has."
  },
  "Entity:GetSequenceGroundSpeed": {
    "prefix": "GetSequenceGroundSpeed",
    "body": "GetSequenceGroundSpeed(${1:number sequenceId})$0",
    "description": "(Shared) Method: Entity:GetSequenceGroundSpeed\n\nReturns the ground speed of the entity's sequence."
  },
  "Entity:GetSequenceInfo": {
    "prefix": "GetSequenceInfo",
    "body": "GetSequenceInfo(${1:number sequenceId})$0",
    "description": "(Shared) Method: Entity:GetSequenceInfo\n\nReturns a table of information about an entity's sequence."
  },
  "Entity:GetSequenceList": {
    "prefix": "GetSequenceList",
    "body": "GetSequenceList()$0",
    "description": "(Shared) Method: Entity:GetSequenceList\n\nReturns a list of all sequences ( animations ) the model has."
  },
  "Entity:GetSequenceMoveDist": {
    "prefix": "GetSequenceMoveDist",
    "body": "GetSequenceMoveDist(${1:number sequenceId})$0",
    "description": "(Server) Method: Entity:GetSequenceMoveDist\n\nReturns an entity's sequence move distance (the change in position over the course of the entire sequence)."
  },
  "Entity:GetSequenceMoveYaw": {
    "prefix": "GetSequenceMoveYaw",
    "body": "GetSequenceMoveYaw(${1:number })$0",
    "description": "(Server) Method: Entity:GetSequenceMoveYaw\n\n"
  },
  "Entity:GetSequenceName": {
    "prefix": "GetSequenceName",
    "body": "GetSequenceName(${1:number index})$0",
    "description": "(Shared) Method: Entity:GetSequenceName\n\nReturn the name of the sequence for the index provided."
  },
  "Entity:GetShouldPlayPickupSound": {
    "prefix": "GetShouldPlayPickupSound",
    "body": "GetShouldPlayPickupSound()$0",
    "description": "(Shared) Method: Entity:GetShouldPlayPickupSound\n\nReturns true or false depending on whether or not the entity plays a physics contact sound when being picked up by a player."
  },
  "Entity:GetShouldServerRagdoll": {
    "prefix": "GetShouldServerRagdoll",
    "body": "GetShouldServerRagdoll()$0",
    "description": "(Shared) Method: Entity:GetShouldServerRagdoll\n\nReturns if entity should create a server ragdoll on death or a client one."
  },
  "Entity:GetSkin": {
    "prefix": "GetSkin",
    "body": "GetSkin()$0",
    "description": "(Shared) Method: Entity:GetSkin\n\nReturns the skin index of the current skin."
  },
  "Entity:GetSolid": {
    "prefix": "GetSolid",
    "body": "GetSolid()$0",
    "description": "(Shared) Method: Entity:GetSolid\n\nReturns solid type of an entity."
  },
  "Entity:GetSolidFlags": {
    "prefix": "GetSolidFlags",
    "body": "GetSolidFlags()$0",
    "description": "(Shared) Method: Entity:GetSolidFlags\n\nReturns solid flag(s) of an entity."
  },
  "Entity:GetSpawnEffect": {
    "prefix": "GetSpawnEffect",
    "body": "GetSpawnEffect()$0",
    "description": "(Shared) Method: Entity:GetSpawnEffect\n\nReturns if we should show a spawn effect on this entity."
  },
  "Entity:GetSpawnFlags": {
    "prefix": "GetSpawnFlags",
    "body": "GetSpawnFlags()$0",
    "description": "(Shared) Method: Entity:GetSpawnFlags\n\nReturns the bitwise spawn flags used by the entity."
  },
  "Entity:GetSubMaterial": {
    "prefix": "GetSubMaterial",
    "body": "GetSubMaterial(${1:number index})$0",
    "description": "(Shared) Method: Entity:GetSubMaterial\n\nReturns the material override for the given index. "
  },
  "Entity:GetSubModels": {
    "prefix": "GetSubModels",
    "body": "GetSubModels()$0",
    "description": "(Shared) Method: Entity:GetSubModels\n\nReturns a list of models included into the entity's model in the .qc file."
  },
  "Entity:GetTable": {
    "prefix": "GetTable",
    "body": "GetTable()$0",
    "description": "(Shared) Method: Entity:GetTable\n\nReturns the table that contains all values saved within the entity."
  },
  "Entity:GetTouchTrace": {
    "prefix": "GetTouchTrace",
    "body": "GetTouchTrace()$0",
    "description": "(Shared) Method: Entity:GetTouchTrace\n\nReturns the last trace used in the collision callbacks such as ENTITY.StartTouch, ENTITY.Touch and ENTITY.EndTouch."
  },
  "Entity:GetTransmitWithParent": {
    "prefix": "GetTransmitWithParent",
    "body": "GetTransmitWithParent()$0",
    "description": "(Shared) Method: Entity:GetTransmitWithParent\n\nReturns true if the TransmitWithParent flag is set or not."
  },
  "Entity:GetUnFreezable": {
    "prefix": "GetUnFreezable",
    "body": "GetUnFreezable()$0",
    "description": "(Server) Method: Entity:GetUnFreezable\n\nReturns if the entity is unfreezable, meaning it can't be frozen with the physgun. By default props are freezable, so this function will typically return nil."
  },
  "Entity:GetUp": {
    "prefix": "GetUp",
    "body": "GetUp()$0",
    "description": "(Shared) Method: Entity:GetUp\n\nReturns the upward vector of the entity, as a normalized direction vector"
  },
  "Entity:GetVar": {
    "prefix": "GetVar",
    "body": "GetVar(${1:string name}, ${2:any default})$0",
    "description": "(Shared) Method: Entity:GetVar\n\nRetrieves a value from entity's Entity.GetTable. Set by Entity.SetVar."
  },
  "Entity:GetVelocity": {
    "prefix": "GetVelocity",
    "body": "GetVelocity()$0",
    "description": "(Shared) Method: Entity:GetVelocity\n\nReturns the directional velocity of the entity."
  },
  "Entity:GetWorkshopID": {
    "prefix": "GetWorkshopID",
    "body": "GetWorkshopID()$0",
    "description": "(Server) Method: Entity:GetWorkshopID\n\n[Deprecated] Returns ID of workshop addon that the entity is from."
  },
  "Entity:GibBreakClient": {
    "prefix": "GibBreakClient",
    "body": "GibBreakClient(${1:Vector force})$0",
    "description": "(Shared) Method: Entity:GibBreakClient\n\nCauses the entity to break into its current models gibs, if it has any."
  },
  "Entity:GibBreakServer": {
    "prefix": "GibBreakServer",
    "body": "GibBreakServer(${1:Vector force})$0",
    "description": "(Shared) Method: Entity:GibBreakServer\n\nCauses the entity to break into its current models gibs, if it has any."
  },
  "Entity:HasBoneManipulations": {
    "prefix": "HasBoneManipulations",
    "body": "HasBoneManipulations()$0",
    "description": "(Shared) Method: Entity:HasBoneManipulations\n\nReturns whether or not the bone manipulation functions have ever been called on given  entity."
  },
  "Entity:HasFlexManipulatior": {
    "prefix": "HasFlexManipulatior",
    "body": "HasFlexManipulatior()$0",
    "description": "(Shared) Method: Entity:HasFlexManipulatior\n\nReturns whether or not the the entity has had flex manipulations performed with Entity.SetFlexWeight or Entity.SetFlexScale."
  },
  "Entity:HasSpawnFlags": {
    "prefix": "HasSpawnFlags",
    "body": "HasSpawnFlags(${1:number spawnFlags})$0",
    "description": "(Shared) Method: Entity:HasSpawnFlags\n\nReturns whether this entity has the specified spawnflags bits set."
  },
  "Entity:HeadTarget": {
    "prefix": "HeadTarget",
    "body": "HeadTarget(${1:Vector origin})$0",
    "description": "(Server) Method: Entity:HeadTarget\n\nReturns the position of the head of this entity, NPCs use this internally to aim at their targets."
  },
  "Entity:Health": {
    "prefix": "Health",
    "body": "Health()$0",
    "description": "(Shared) Method: Entity:Health\n\nReturns the health of the entity."
  },
  "Entity:Ignite": {
    "prefix": "Ignite",
    "body": "Ignite(${1:number length}, ${2:number radius})$0",
    "description": "(Server) Method: Entity:Ignite\n\nSets the entity on fire."
  },
  "Entity:InitializeAsClientEntity": {
    "prefix": "InitializeAsClientEntity",
    "body": "InitializeAsClientEntity()$0",
    "description": "(Client) Method: Entity:InitializeAsClientEntity\n\nInitializes this entity as being clientside only."
  },
  "Entity:Input": {
    "prefix": "Input",
    "body": "Input(${1:string input}, ${2:Entity activator}, ${3:Entity inflictor}, ${4:any param=nil})$0",
    "description": "(Server) Method: Entity:Input\n\nFires input to the entity with the ability to make another entity responsible. Similar to Entity.Fire"
  },
  "Entity:InstallDataTable": {
    "prefix": "InstallDataTable",
    "body": "InstallDataTable()$0",
    "description": "(Shared) Method: Entity:InstallDataTable\n\n[Internal]  Sets up Data Tables from entity to use with Entity.NetworkVar."
  },
  "Entity:InvalidateBoneCache": {
    "prefix": "InvalidateBoneCache",
    "body": "InvalidateBoneCache()$0",
    "description": "(Client) Method: Entity:InvalidateBoneCache\n\nResets the entity's bone cache values in order to prepare for a model change."
  },
  "Entity:IsConstrained": {
    "prefix": "IsConstrained",
    "body": "IsConstrained()$0",
    "description": "(Shared) Method: Entity:IsConstrained\n\nReturns true if the entity has constraints attached to it"
  },
  "Entity:IsConstraint": {
    "prefix": "IsConstraint",
    "body": "IsConstraint()$0",
    "description": "(Server) Method: Entity:IsConstraint\n\nReturns if entity is constraint or not"
  },
  "Entity:IsDormant": {
    "prefix": "IsDormant",
    "body": "IsDormant()$0",
    "description": "(Shared) Method: Entity:IsDormant\n\nReturns whether the entity is dormant or not. Client/server entities become dormant when they leave the PVS on the server. Client side entities can decide for themselves whether to become dormant. This mainly applies to PVS."
  },
  "Entity:IsEffectActive": {
    "prefix": "IsEffectActive",
    "body": "IsEffectActive(${1:number effect})$0",
    "description": "(Shared) Method: Entity:IsEffectActive\n\nReturns whether an entity has engine effect applied or not."
  },
  "Entity:IsEFlagSet": {
    "prefix": "IsEFlagSet",
    "body": "IsEFlagSet(${1:number flag})$0",
    "description": "(Shared) Method: Entity:IsEFlagSet\n\nChecks if given flag is set or not."
  },
  "Entity:IsFlagSet": {
    "prefix": "IsFlagSet",
    "body": "IsFlagSet(${1:number flag})$0",
    "description": "(Shared) Method: Entity:IsFlagSet\n\nChecks if given flag(s) is set or not."
  },
  "Entity:IsInWorld": {
    "prefix": "IsInWorld",
    "body": "IsInWorld()$0",
    "description": "(Server) Method: Entity:IsInWorld\n\nReturns whether the entity is inside a wall or outside of the map."
  },
  "Entity:IsLagCompensated": {
    "prefix": "IsLagCompensated",
    "body": "IsLagCompensated()$0",
    "description": "(Server) Method: Entity:IsLagCompensated\n\nReturns whether the entity is lag compensated or not. "
  },
  "Entity:IsLineOfSightClear": {
    "prefix": "IsLineOfSightClear",
    "body": "IsLineOfSightClear(${1:Vector target})$0",
    "description": "(Shared) Method: Entity:IsLineOfSightClear\n\nReturns true if the target is in line of sight. This will only work on CBaseCombatCharacter entities."
  },
  "Entity:IsNPC": {
    "prefix": "IsNPC",
    "body": "IsNPC()$0",
    "description": "(Shared) Method: Entity:IsNPC\n\nChecks if the entity is an NPC or not."
  },
  "Entity:IsOnFire": {
    "prefix": "IsOnFire",
    "body": "IsOnFire()$0",
    "description": "(Shared) Method: Entity:IsOnFire\n\nReturns whether the entity is on fire."
  },
  "Entity:IsOnGround": {
    "prefix": "IsOnGround",
    "body": "IsOnGround()$0",
    "description": "(Shared) Method: Entity:IsOnGround\n\nReturns whether the entity is on ground or not."
  },
  "Entity:IsPlayer": {
    "prefix": "IsPlayer",
    "body": "IsPlayer()$0",
    "description": "(Shared) Method: Entity:IsPlayer\n\nChecks if the entity is a player or not."
  },
  "Entity:IsPlayerHolding": {
    "prefix": "IsPlayerHolding",
    "body": "IsPlayerHolding()$0",
    "description": "(Server) Method: Entity:IsPlayerHolding\n\nReturns true if the entity is being held by a player. Either by Physics gun, Gravity gun or Use-key."
  },
  "Entity:IsPlayingGesture": {
    "prefix": "IsPlayingGesture",
    "body": "IsPlayingGesture(${1:number activity})$0",
    "description": "(Server) Method: Entity:IsPlayingGesture\n\nReturns whether there's a gesture is given activity being played."
  },
  "Entity:IsRagdoll": {
    "prefix": "IsRagdoll",
    "body": "IsRagdoll()$0",
    "description": "(Shared) Method: Entity:IsRagdoll\n\nChecks if the entity is a ragdoll."
  },
  "Entity:IsSolid": {
    "prefix": "IsSolid",
    "body": "IsSolid()$0",
    "description": "(Shared) Method: Entity:IsSolid\n\nReturns if the entity is solid or not."
  },
  "Entity:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Shared) Method: Entity:IsValid\n\nReturns whether the entity is a valid entity or not."
  },
  "Entity:IsValidLayer": {
    "prefix": "IsValidLayer",
    "body": "IsValidLayer(${1:number layerID})$0",
    "description": "(Server) Method: Entity:IsValidLayer\n\nReturns whether the given layer ID is valid and exists on this entity."
  },
  "Entity:IsVehicle": {
    "prefix": "IsVehicle",
    "body": "IsVehicle()$0",
    "description": "(Shared) Method: Entity:IsVehicle\n\nChecks if the entity is a vehicle or not."
  },
  "Entity:IsWeapon": {
    "prefix": "IsWeapon",
    "body": "IsWeapon()$0",
    "description": "(Shared) Method: Entity:IsWeapon\n\nChecks if the entity is a weapon or not."
  },
  "Entity:IsWidget": {
    "prefix": "IsWidget",
    "body": "IsWidget()$0",
    "description": "(Shared) Method: Entity:IsWidget\n\nReturns whether the entity is a widget or not."
  },
  "Entity:IsWorld": {
    "prefix": "IsWorld",
    "body": "IsWorld()$0",
    "description": "(Shared) Method: Entity:IsWorld\n\nReturns if the entity is the map's Entity[0] worldspawn"
  },
  "Entity:LocalToWorld": {
    "prefix": "LocalToWorld",
    "body": "LocalToWorld(${1:Vector lpos})$0",
    "description": "(Shared) Method: Entity:LocalToWorld\n\nConverts a vector local to an entity into a worldspace vector"
  },
  "Entity:LocalToWorldAngles": {
    "prefix": "LocalToWorldAngles",
    "body": "LocalToWorldAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: Entity:LocalToWorldAngles\n\nConverts a local angle (local to the entity) to a world angle."
  },
  "Entity:LookupAttachment": {
    "prefix": "LookupAttachment",
    "body": "LookupAttachment(${1:string attachmentName})$0",
    "description": "(Shared) Method: Entity:LookupAttachment\n\nGets the attachment index of the given attachment name, returns 0 if the attachment does not exist, or -1 if the model is invalid."
  },
  "Entity:LookupBone": {
    "prefix": "LookupBone",
    "body": "LookupBone(${1:string boneName})$0",
    "description": "(Shared) Method: Entity:LookupBone\n\nGets the bone index of the given bone name, returns nothing if the bone does not exist."
  },
  "Entity:LookupSequence": {
    "prefix": "LookupSequence",
    "body": "LookupSequence(${1:string name})$0",
    "description": "(Shared) Method: Entity:LookupSequence\n\nReturns sequence ID from its name."
  },
  "Entity:MakePhysicsObjectAShadow": {
    "prefix": "MakePhysicsObjectAShadow",
    "body": "MakePhysicsObjectAShadow(${1:boolean allowPhysicsMovement}, ${2:boolean allowPhysicsRotation})$0",
    "description": "(Shared) Method: Entity:MakePhysicsObjectAShadow\n\nTurns the Entity.GetPhysicsObject into a physics shadow."
  },
  "Entity:ManipulateBoneAngles": {
    "prefix": "ManipulateBoneAngles",
    "body": "ManipulateBoneAngles(${1:number boneID}, ${2:Angle ang})$0",
    "description": "(Shared) Method: Entity:ManipulateBoneAngles\n\nSets custom bone angles."
  },
  "Entity:ManipulateBoneJiggle": {
    "prefix": "ManipulateBoneJiggle",
    "body": "ManipulateBoneJiggle(${1:number boneID}, ${2:number amount})$0",
    "description": "(Shared) Method: Entity:ManipulateBoneJiggle\n\nManipulates the bone's jiggle value(s)."
  },
  "Entity:ManipulateBonePosition": {
    "prefix": "ManipulateBonePosition",
    "body": "ManipulateBonePosition(${1:number boneID}, ${2:Vector pos})$0",
    "description": "(Shared) Method: Entity:ManipulateBonePosition\n\nSets custom bone offsets."
  },
  "Entity:ManipulateBoneScale": {
    "prefix": "ManipulateBoneScale",
    "body": "ManipulateBoneScale(${1:number boneID}, ${2:Vector scale})$0",
    "description": "(Shared) Method: Entity:ManipulateBoneScale\n\nSets custom bone scale."
  },
  "Entity:MapCreationID": {
    "prefix": "MapCreationID",
    "body": "MapCreationID()$0",
    "description": "(Server) Method: Entity:MapCreationID\n\nReturns entity's map creation ID. Unlike Entity.EntIndex or Entity.GetCreationID, it will always be the same on same map, no matter how much you clean up or restart it."
  },
  "Entity:MarkShadowAsDirty": {
    "prefix": "MarkShadowAsDirty",
    "body": "MarkShadowAsDirty()$0",
    "description": "(Client) Method: Entity:MarkShadowAsDirty\n\nRefreshes the shadow of the entity."
  },
  "Entity:MuzzleFlash": {
    "prefix": "MuzzleFlash",
    "body": "MuzzleFlash()$0",
    "description": "(Shared) Method: Entity:MuzzleFlash\n\nFires the muzzle flash effect of the weapon the entity is carrying. This only creates a light effect and is often called alongside Weapon.SendWeaponAnim"
  },
  "Entity:NearestPoint": {
    "prefix": "NearestPoint",
    "body": "NearestPoint(${1:Vector position})$0",
    "description": "(Shared) Method: Entity:NearestPoint\n\nPerforms a Ray OBBox intersection from the given position to the origin of the OBBox with the entity and returns the hit position on the OBBox"
  },
  "Entity:NetworkVar": {
    "prefix": "NetworkVar",
    "body": "NetworkVar(${1:string type}, ${2:number slot}, ${3:string name}, ${4:table extended=nil})$0",
    "description": "(Shared) Method: Entity:NetworkVar\n\nCreates a network variable on the entity and adds Set/Get functions for it. This function should only be called in ENTITY.SetupDataTables."
  },
  "Entity:NetworkVarNotify": {
    "prefix": "NetworkVarNotify",
    "body": "NetworkVarNotify(${1:string name}, ${2:function callback})$0",
    "description": "(Shared) Method: Entity:NetworkVarNotify\n\nCreates a callback that will execute when the given network variable changes - that is, when the Set function is run."
  },
  "Entity:NextThink": {
    "prefix": "NextThink",
    "body": "NextThink(${1:number timestamp})$0",
    "description": "(Shared) Method: Entity:NextThink\n\nIn the case of a scripted entity, this will cause the next ENTITY.Think event to be run at the given time."
  },
  "Entity:OBBCenter": {
    "prefix": "OBBCenter",
    "body": "OBBCenter()$0",
    "description": "(Shared) Method: Entity:OBBCenter\n\nReturns the center of an entity's bounding box as a local vector."
  },
  "Entity:OBBMaxs": {
    "prefix": "OBBMaxs",
    "body": "OBBMaxs()$0",
    "description": "(Shared) Method: Entity:OBBMaxs\n\nReturns the highest corner of an entity's bounding box as a local vector."
  },
  "Entity:OBBMins": {
    "prefix": "OBBMins",
    "body": "OBBMins()$0",
    "description": "(Shared) Method: Entity:OBBMins\n\nReturns the lowest corner of an entity's bounding box as a local vector."
  },
  "Entity:ObjectCaps": {
    "prefix": "ObjectCaps",
    "body": "ObjectCaps()$0",
    "description": "(Shared) Method: Entity:ObjectCaps\n\nReturns the entity's capabilities as a bitfield."
  },
  "Entity:OnGround": {
    "prefix": "OnGround",
    "body": "OnGround()$0",
    "description": "(Shared) Method: Entity:OnGround\n\nReturns true if the entity is on the ground, and false if it isn't."
  },
  "Entity:PassesDamageFilter": {
    "prefix": "PassesDamageFilter",
    "body": "PassesDamageFilter(${1:CTakeDamageInfo dmg})$0",
    "description": "(Server) Method: Entity:PassesDamageFilter\n\nTests whether the damage passes the entity filter."
  },
  "Entity:PassesFilter": {
    "prefix": "PassesFilter",
    "body": "PassesFilter(${1:Entity caller}, ${2:Entity ent})$0",
    "description": "(Server) Method: Entity:PassesFilter\n\nTests whether the entity passes the entity filter."
  },
  "Entity:PhysicsDestroy": {
    "prefix": "PhysicsDestroy",
    "body": "PhysicsDestroy()$0",
    "description": "(Shared) Method: Entity:PhysicsDestroy\n\nDestroys the current physics object of an entity."
  },
  "Entity:PhysicsFromMesh": {
    "prefix": "PhysicsFromMesh",
    "body": "PhysicsFromMesh(${1:table vertices})$0",
    "description": "(Shared) Method: Entity:PhysicsFromMesh\n\nInitializes the physics mesh of the entity from a triangle soup defined by a table of vertices. The resulting mesh is hollow, may contain holes, and always has a volume of 0."
  },
  "Entity:PhysicsInit": {
    "prefix": "PhysicsInit",
    "body": "PhysicsInit(${1:number solidType})$0",
    "description": "(Shared) Method: Entity:PhysicsInit\n\nInitializes the physics object of the entity using its current model. Deletes the previous physics object if there was any."
  },
  "Entity:PhysicsInitBox": {
    "prefix": "PhysicsInitBox",
    "body": "PhysicsInitBox(${1:Vector mins}, ${2:Vector maxs})$0",
    "description": "(Shared) Method: Entity:PhysicsInitBox\n\nMakes the physics object of the entity a AABB."
  },
  "Entity:PhysicsInitConvex": {
    "prefix": "PhysicsInitConvex",
    "body": "PhysicsInitConvex(${1:table points})$0",
    "description": "(Shared) Method: Entity:PhysicsInitConvex\n\nInitializes the physics mesh of the entity with a convex mesh defined by a table of points. The resulting mesh is the [[wikipedia:Convex hull.convex hull]] of all the input points."
  },
  "Entity:PhysicsInitMultiConvex": {
    "prefix": "PhysicsInitMultiConvex",
    "body": "PhysicsInitMultiConvex(${1:table vertices})$0",
    "description": "(Shared) Method: Entity:PhysicsInitMultiConvex\n\nAn advanced version of Entity.PhysicsInitConvex which initializes a physics object from multiple convex meshes."
  },
  "Entity:PhysicsInitShadow": {
    "prefix": "PhysicsInitShadow",
    "body": "PhysicsInitShadow(${1:boolean allowPhysicsMovement}, ${2:boolean allowPhysicsRotation})$0",
    "description": "(Shared) Method: Entity:PhysicsInitShadow\n\nRemoves the old Entity.GetPhysicsObject and initializes it as a physics shadow."
  },
  "Entity:PhysicsInitSphere": {
    "prefix": "PhysicsInitSphere",
    "body": "PhysicsInitSphere(${1:number radius}, ${2:string physmat})$0",
    "description": "(Shared) Method: Entity:PhysicsInitSphere\n\nMakes the physics object of the entity a sphere."
  },
  "Entity:PhysicsInitStatic": {
    "prefix": "PhysicsInitStatic",
    "body": "PhysicsInitStatic(${1:number solidType})$0",
    "description": "(Shared) Method: Entity:PhysicsInitStatic\n\nInitializes a static physics object of the entity using its current model. Deletes the previous physics object if there was any."
  },
  "Entity:PhysWake": {
    "prefix": "PhysWake",
    "body": "PhysWake()$0",
    "description": "(Shared) Method: Entity:PhysWake\n\nWakes up the entity's physics object"
  },
  "Entity:PlayScene": {
    "prefix": "PlayScene",
    "body": "PlayScene(${1:string scene}, ${2:number delay=0})$0",
    "description": "(Server) Method: Entity:PlayScene\n\nMakes the entity play a .vcd scene."
  },
  "Entity:PointAtEntity": {
    "prefix": "PointAtEntity",
    "body": "PointAtEntity(${1:Entity target})$0",
    "description": "(Server) Method: Entity:PointAtEntity\n\nChanges an entities angles so that it faces the target entity."
  },
  "Entity:PrecacheGibs": {
    "prefix": "PrecacheGibs",
    "body": "PrecacheGibs()$0",
    "description": "(Server) Method: Entity:PrecacheGibs\n\nPrecaches gibs for the entity's model."
  },
  "Entity:RagdollSolve": {
    "prefix": "RagdollSolve",
    "body": "RagdollSolve()$0",
    "description": "(Server) Method: Entity:RagdollSolve\n\nNormalizes the ragdoll. This is used alongside Kinect in Entity.SetRagdollBuildFunction, for more info see ragdoll_motion entity."
  },
  "Entity:RagdollStopControlling": {
    "prefix": "RagdollStopControlling",
    "body": "RagdollStopControlling()$0",
    "description": "(Server) Method: Entity:RagdollStopControlling\n\nSets the function to build the ragdoll. This is used alongside Kinect in Entity.SetRagdollBuildFunction, for more info see ragdoll_motion entity."
  },
  "Entity:RagdollUpdatePhysics": {
    "prefix": "RagdollUpdatePhysics",
    "body": "RagdollUpdatePhysics()$0",
    "description": "(Server) Method: Entity:RagdollUpdatePhysics\n\nMakes the physics objects follow the set bone positions. This is used alongside Kinect in Entity.SetRagdollBuildFunction, for more info see ragdoll_motion entity."
  },
  "Entity:Remove": {
    "prefix": "Remove",
    "body": "Remove()$0",
    "description": "(Shared) Method: Entity:Remove\n\nRemoves the entity it is used on."
  },
  "Entity:RemoveAllDecals": {
    "prefix": "RemoveAllDecals",
    "body": "RemoveAllDecals()$0",
    "description": "(Shared) Method: Entity:RemoveAllDecals\n\nRemoves all decals from the entities surface."
  },
  "Entity:RemoveAllGestures": {
    "prefix": "RemoveAllGestures",
    "body": "RemoveAllGestures()$0",
    "description": "(Server) Method: Entity:RemoveAllGestures\n\nRemoves and stops all gestures."
  },
  "Entity:RemoveCallback": {
    "prefix": "RemoveCallback",
    "body": "RemoveCallback(${1:string hook}, ${2:number callbackid})$0",
    "description": "(Shared) Method: Entity:RemoveCallback\n\nRemoves a callback previously added with Entity.AddCallback"
  },
  "Entity:RemoveCallOnRemove": {
    "prefix": "RemoveCallOnRemove",
    "body": "RemoveCallOnRemove(${1:string identifier})$0",
    "description": "(Shared) Method: Entity:RemoveCallOnRemove\n\nRemoves the CallOnRemove'd function referred to by identifier"
  },
  "Entity:RemoveEffects": {
    "prefix": "RemoveEffects",
    "body": "RemoveEffects(${1:number effect})$0",
    "description": "(Shared) Method: Entity:RemoveEffects\n\nRemoves an engine effect applied to an entity."
  },
  "Entity:RemoveEFlags": {
    "prefix": "RemoveEFlags",
    "body": "RemoveEFlags(${1:number flag})$0",
    "description": "(Shared) Method: Entity:RemoveEFlags\n\nRemoves specified engine flag"
  },
  "Entity:RemoveFlags": {
    "prefix": "RemoveFlags",
    "body": "RemoveFlags(${1:number flag})$0",
    "description": "(Shared) Method: Entity:RemoveFlags\n\nRemoves specified flag(s) from the entity"
  },
  "Entity:RemoveFromMotionController": {
    "prefix": "RemoveFromMotionController",
    "body": "RemoveFromMotionController(${1:PhysObj physObj})$0",
    "description": "(Shared) Method: Entity:RemoveFromMotionController\n\nRemoves a PhysObject from the entity's motion controller so that ENTITY.PhysicsSimulate will no longer be called for given Type.PhysObject."
  },
  "Entity:RemoveGesture": {
    "prefix": "RemoveGesture",
    "body": "RemoveGesture(${1:number activity})$0",
    "description": "(Server) Method: Entity:RemoveGesture\n\nRemoves and stops the gesture with given activity."
  },
  "Entity:RemoveSolidFlags": {
    "prefix": "RemoveSolidFlags",
    "body": "RemoveSolidFlags(${1:number flags})$0",
    "description": "(Shared) Method: Entity:RemoveSolidFlags\n\nRemoves solid flag(s) from the entity."
  },
  "Entity:ResetSequence": {
    "prefix": "ResetSequence",
    "body": "ResetSequence(${1:number sequence})$0",
    "description": "(Shared) Method: Entity:ResetSequence\n\nPlays an animation on the entity. This may not always work on engine entities."
  },
  "Entity:ResetSequenceInfo": {
    "prefix": "ResetSequenceInfo",
    "body": "ResetSequenceInfo()$0",
    "description": "(Shared) Method: Entity:ResetSequenceInfo\n\nReset entity sequence info such as playback rate, ground speed, last event check, etc."
  },
  "Entity:Respawn": {
    "prefix": "Respawn",
    "body": "Respawn()$0",
    "description": "(Server) Method: Entity:Respawn\n\nMakes the entity/weapon respawn."
  },
  "Entity:RestartGesture": {
    "prefix": "RestartGesture",
    "body": "RestartGesture(${1:number activity}, ${2:boolean addIfMissing=true}, ${3:boolean autokill=true})$0",
    "description": "(Server) Method: Entity:RestartGesture\n\nRestarts the entity's animation gesture. If the given gesture is already playing, it will reset it and play it from the beginning."
  },
  "Entity:SelectWeightedSequence": {
    "prefix": "SelectWeightedSequence",
    "body": "SelectWeightedSequence(${1:number act})$0",
    "description": "(Shared) Method: Entity:SelectWeightedSequence\n\nReturns sequence ID corresponding to given activity ID."
  },
  "Entity:SelectWeightedSequenceSeeded": {
    "prefix": "SelectWeightedSequenceSeeded",
    "body": "SelectWeightedSequenceSeeded(${1:number act}, ${2:number seed})$0",
    "description": "(Shared) Method: Entity:SelectWeightedSequenceSeeded\n\nReturns sequence ID corresponding to given activity ID."
  },
  "Entity:SendViewModelMatchingSequence": {
    "prefix": "SendViewModelMatchingSequence",
    "body": "SendViewModelMatchingSequence(${1:number seq})$0",
    "description": "(Shared) Method: Entity:SendViewModelMatchingSequence\n\nSends sequence animation to the view model. It is recommended to use this for view model animations, instead of Entity.ResetSequence."
  },
  "Entity:SequenceDuration": {
    "prefix": "SequenceDuration",
    "body": "SequenceDuration(${1:number seqid=nil})$0",
    "description": "(Shared) Method: Entity:SequenceDuration\n\nReturns length of currently played sequence."
  },
  "Entity:SetAbsVelocity": {
    "prefix": "SetAbsVelocity",
    "body": "SetAbsVelocity(${1:Vector vel})$0",
    "description": "(Shared) Method: Entity:SetAbsVelocity\n\nSets the entity's velocity."
  },
  "Entity:SetAngles": {
    "prefix": "SetAngles",
    "body": "SetAngles(${1:Angle angles})$0",
    "description": "(Shared) Method: Entity:SetAngles\n\nSets the angles of the entity."
  },
  "Entity:SetAnimation": {
    "prefix": "SetAnimation",
    "body": "SetAnimation(${1:number playerAnim})$0",
    "description": "(Shared) Method: Entity:SetAnimation\n\nSets a player's third-person animation. Mainly used by Weapons to start the player's weapon attack and reload animations."
  },
  "Entity:SetAnimTime": {
    "prefix": "SetAnimTime",
    "body": "SetAnimTime(${1:number time})$0",
    "description": "(Client) Method: Entity:SetAnimTime\n\nSets the time (relative to _G.CurTime) of the current animation frame, which is used to determine Entity.GetCycle."
  },
  "Entity:SetAttachment": {
    "prefix": "SetAttachment",
    "body": "SetAttachment(${1:Entity ent}, ${2:number attachment})$0",
    "description": "(Shared) Method: Entity:SetAttachment\n\n[Deprecated] .You should be using Entity.SetParent instead."
  },
  "Entity:SetBloodColor": {
    "prefix": "SetBloodColor",
    "body": "SetBloodColor(${1:number bloodColor})$0",
    "description": "(Server) Method: Entity:SetBloodColor\n\nSets the blood color this entity uses."
  },
  "Entity:SetBodygroup": {
    "prefix": "SetBodygroup",
    "body": "SetBodygroup(${1:number bodygroup}, ${2:number value})$0",
    "description": "(Shared) Method: Entity:SetBodygroup\n\nSets an entities' bodygroup."
  },
  "Entity:SetBodyGroups": {
    "prefix": "SetBodyGroups",
    "body": "SetBodyGroups(${1:string bodygroups})$0",
    "description": "(Shared) Method: Entity:SetBodyGroups\n\nSets the bodygroups from a string. A convenience function for Entity.SetBodygroup."
  },
  "Entity:SetBoneController": {
    "prefix": "SetBoneController",
    "body": "SetBoneController(${1:number boneControllerID}, ${2:number value})$0",
    "description": "(Shared) Method: Entity:SetBoneController\n\nSets the specified value on the bone controller with the given ID of this entity, it's used in HL1 to change the head rotation of NPCs, turret aiming and so on."
  },
  "Entity:SetBoneMatrix": {
    "prefix": "SetBoneMatrix",
    "body": "SetBoneMatrix(${1:number boneid}, ${2:VMatrix matrix})$0",
    "description": "(Shared) Method: Entity:SetBoneMatrix\n\nStub"
  },
  "Entity:SetBonePosition": {
    "prefix": "SetBonePosition",
    "body": "SetBonePosition(${1:number bone}, ${2:Vector pos}, ${3:Angle ang})$0",
    "description": "(Client) Method: Entity:SetBonePosition\n\nSets the bone position and angles."
  },
  "Entity:SetCollisionBounds": {
    "prefix": "SetCollisionBounds",
    "body": "SetCollisionBounds(${1:Vector mins}, ${2:Vector maxs})$0",
    "description": "(Shared) Method: Entity:SetCollisionBounds\n\nSets the collision bounds for the entity, which are used for triggers ( Entity.SetTrigger, ENTITY.Touch ), determining if rendering is necessary clientside, and collision ( If Entity.SetSolid set as [[Enums/SOLID.SOLID_BBOX]] )."
  },
  "Entity:SetCollisionBoundsWS": {
    "prefix": "SetCollisionBoundsWS",
    "body": "SetCollisionBoundsWS(${1:Vector vec1}, ${2:Vector vec2})$0",
    "description": "(Shared) Method: Entity:SetCollisionBoundsWS\n\nSets the collision bounds for the entity, which are used for triggers ( Entity.SetTrigger, ENTITY.Touch ), determining if rendering is necessary clientside, and collision ( If Entity.SetSolid set as [[Enums/SOLID.SOLID_BBOX]] )."
  },
  "Entity:SetCollisionGroup": {
    "prefix": "SetCollisionGroup",
    "body": "SetCollisionGroup(${1:number group})$0",
    "description": "(Shared) Method: Entity:SetCollisionGroup\n\nSets the entity's collision group."
  },
  "Entity:SetColor": {
    "prefix": "SetColor",
    "body": "SetColor(${1:table color=Color(255, 0, 255, 255)})$0",
    "description": "(Shared) Method: Entity:SetColor\n\nSets the color of an entity."
  },
  "Entity:SetCreator": {
    "prefix": "SetCreator",
    "body": "SetCreator(${1:Player ply})$0",
    "description": "(Server) Method: Entity:SetCreator\n\nSets the creator of the SENT."
  },
  "Entity:SetCustomCollisionCheck": {
    "prefix": "SetCustomCollisionCheck",
    "body": "SetCustomCollisionCheck(${1:boolean enable})$0",
    "description": "(Shared) Method: Entity:SetCustomCollisionCheck\n\nMarks the entity to call GM.ShouldCollide."
  },
  "Entity:SetCycle": {
    "prefix": "SetCycle",
    "body": "SetCycle(${1:number value})$0",
    "description": "(Shared) Method: Entity:SetCycle\n\nSets the progress of the current animation to a specific value between 0 and 1."
  },
  "Entity:SetDTAngle": {
    "prefix": "SetDTAngle",
    "body": "SetDTAngle(${1:number key}, ${2:Angle ang})$0",
    "description": "(Shared) Method: Entity:SetDTAngle\n\n[Internal] "
  },
  "Entity:SetDTBool": {
    "prefix": "SetDTBool",
    "body": "SetDTBool(${1:number key}, ${2:boolean bool})$0",
    "description": "(Shared) Method: Entity:SetDTBool\n\n[Internal] "
  },
  "Entity:SetDTEntity": {
    "prefix": "SetDTEntity",
    "body": "SetDTEntity(${1:number key}, ${2:Entity ent})$0",
    "description": "(Shared) Method: Entity:SetDTEntity\n\n[Internal] "
  },
  "Entity:SetDTFloat": {
    "prefix": "SetDTFloat",
    "body": "SetDTFloat(${1:number key}, ${2:number float})$0",
    "description": "(Shared) Method: Entity:SetDTFloat\n\n[Internal] "
  },
  "Entity:SetDTInt": {
    "prefix": "SetDTInt",
    "body": "SetDTInt(${1:number key}, ${2:number integer})$0",
    "description": "(Shared) Method: Entity:SetDTInt\n\n[Internal] "
  },
  "Entity:SetDTString": {
    "prefix": "SetDTString",
    "body": "SetDTString(${1:number key}, ${2:string str})$0",
    "description": "(Shared) Method: Entity:SetDTString\n\n[Internal] "
  },
  "Entity:SetDTVector": {
    "prefix": "SetDTVector",
    "body": "SetDTVector(${1:number key}, ${2:Vector vec})$0",
    "description": "(Shared) Method: Entity:SetDTVector\n\n[Internal] "
  },
  "Entity:SetElasticity": {
    "prefix": "SetElasticity",
    "body": "SetElasticity(${1:number elasticity})$0",
    "description": "(Shared) Method: Entity:SetElasticity\n\nSets the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding."
  },
  "Entity:SetEntity": {
    "prefix": "SetEntity",
    "body": "SetEntity(${1:string name}, ${2:Entity entity})$0",
    "description": "(Shared) Method: Entity:SetEntity\n\nAllows you to set the Start or End entity attachment for the rope."
  },
  "Entity:SetEyeTarget": {
    "prefix": "SetEyeTarget",
    "body": "SetEyeTarget(${1:Vector pos})$0",
    "description": "(Shared) Method: Entity:SetEyeTarget\n\nSets the position an entity's eyes look toward."
  },
  "Entity:SetFlexScale": {
    "prefix": "SetFlexScale",
    "body": "SetFlexScale(${1:number scale})$0",
    "description": "(Shared) Method: Entity:SetFlexScale\n\nSets the flex scale of the entity."
  },
  "Entity:SetFlexWeight": {
    "prefix": "SetFlexWeight",
    "body": "SetFlexWeight(${1:number flex}, ${2:number weight})$0",
    "description": "(Shared) Method: Entity:SetFlexWeight\n\nSets the flex weight."
  },
  "Entity:SetFriction": {
    "prefix": "SetFriction",
    "body": "SetFriction(${1:number friction})$0",
    "description": "(Server) Method: Entity:SetFriction\n\nSets how much friction an entity has when sliding against a surface. Entities default to 1 (100%) and can be higher or even negative."
  },
  "Entity:SetGravity": {
    "prefix": "SetGravity",
    "body": "SetGravity(${1:number gravityMultiplier})$0",
    "description": "(Shared) Method: Entity:SetGravity\n\nSets the gravity multiplier of the entity."
  },
  "Entity:SetGroundEntity": {
    "prefix": "SetGroundEntity",
    "body": "SetGroundEntity(${1:Entity ground})$0",
    "description": "(Shared) Method: Entity:SetGroundEntity\n\nSets the ground the entity is standing on."
  },
  "Entity:SetHealth": {
    "prefix": "SetHealth",
    "body": "SetHealth(${1:number newHealth})$0",
    "description": "(Shared) Method: Entity:SetHealth\n\nSets the health of the entity."
  },
  "Entity:SetHitboxSet": {
    "prefix": "SetHitboxSet",
    "body": "SetHitboxSet(${1:number id})$0",
    "description": "(Shared) Method: Entity:SetHitboxSet\n\nSets the current Hitbox Set for the entity."
  },
  "Entity:SetIK": {
    "prefix": "SetIK",
    "body": "SetIK(${1:boolean useIK=false})$0",
    "description": "(Client) Method: Entity:SetIK\n\nEnables or disable the inverse kinematic usage of this entity."
  },
  "Entity:SetKeyValue": {
    "prefix": "SetKeyValue",
    "body": "SetKeyValue(${1:string key}, ${2:string value})$0",
    "description": "(Shared) Method: Entity:SetKeyValue\n\nSets key value for the entity."
  },
  "Entity:SetLagCompensated": {
    "prefix": "SetLagCompensated",
    "body": "SetLagCompensated(${1:boolean enable})$0",
    "description": "(Server) Method: Entity:SetLagCompensated\n\nThis allows the entity to be lag compensated during Player.LagCompensation."
  },
  "Entity:SetLayerBlendIn": {
    "prefix": "SetLayerBlendIn",
    "body": "SetLayerBlendIn(${1:number layerID}, ${2:number blendIn})$0",
    "description": "(Server) Method: Entity:SetLayerBlendIn\n\nStub"
  },
  "Entity:SetLayerBlendOut": {
    "prefix": "SetLayerBlendOut",
    "body": "SetLayerBlendOut(${1:number layerID}, ${2:number blendOut})$0",
    "description": "(Server) Method: Entity:SetLayerBlendOut\n\nStub"
  },
  "Entity:SetLayerCycle": {
    "prefix": "SetLayerCycle",
    "body": "SetLayerCycle(${1:number layerID}, ${2:number duration})$0",
    "description": "(Server) Method: Entity:SetLayerCycle\n\nSets the animation cycle/frame of given layer."
  },
  "Entity:SetLayerDuration": {
    "prefix": "SetLayerDuration",
    "body": "SetLayerDuration(${1:number layerID}, ${2:number duration})$0",
    "description": "(Server) Method: Entity:SetLayerDuration\n\nSets the duration of given layer. This internally overrides the Entity.SetLayerPlaybackRate."
  },
  "Entity:SetLayerLooping": {
    "prefix": "SetLayerLooping",
    "body": "SetLayerLooping(${1:number layerID}, ${2:boolean loop})$0",
    "description": "(Server) Method: Entity:SetLayerLooping\n\nSets whether the layer should loop or not."
  },
  "Entity:SetLayerPlaybackRate": {
    "prefix": "SetLayerPlaybackRate",
    "body": "SetLayerPlaybackRate(${1:number layerID}, ${2:number rate})$0",
    "description": "(Server) Method: Entity:SetLayerPlaybackRate\n\nSets the layer player back rate. See also Entity.SetLayerDuration."
  },
  "Entity:SetLayerPriority": {
    "prefix": "SetLayerPriority",
    "body": "SetLayerPriority(${1:number layerID}, ${2:number priority})$0",
    "description": "(Server) Method: Entity:SetLayerPriority\n\nSets the priority of given layer."
  },
  "Entity:SetLayerWeight": {
    "prefix": "SetLayerWeight",
    "body": "SetLayerWeight(${1:number layerID}, ${2:number weight})$0",
    "description": "(Server) Method: Entity:SetLayerWeight\n\nSets the layer weight. This influences how strongly the animation should be overriding the normal animations of the entity."
  },
  "Entity:SetLegacyTransform": {
    "prefix": "SetLegacyTransform",
    "body": "SetLegacyTransform(${1:boolean enabled})$0",
    "description": "(Client) Method: Entity:SetLegacyTransform\n\nThis forces an entity to use the bone transformation behaviour from versions prior to '''14.07.08'''."
  },
  "Entity:SetLocalAngles": {
    "prefix": "SetLocalAngles",
    "body": "SetLocalAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: Entity:SetLocalAngles\n\nSets angles relative to angles of Entity.GetParent"
  },
  "Entity:SetLocalAngularVelocity": {
    "prefix": "SetLocalAngularVelocity",
    "body": "SetLocalAngularVelocity(${1:Angle angVel})$0",
    "description": "(Shared) Method: Entity:SetLocalAngularVelocity\n\n"
  },
  "Entity:SetLocalPos": {
    "prefix": "SetLocalPos",
    "body": "SetLocalPos(${1:Vector pos})$0",
    "description": "(Shared) Method: Entity:SetLocalPos\n\nSets local position relative to the parented position. This is for use with Entity.SetParent to offset position."
  },
  "Entity:SetLocalVelocity": {
    "prefix": "SetLocalVelocity",
    "body": "SetLocalVelocity(${1:Vector velocity})$0",
    "description": "(Shared) Method: Entity:SetLocalVelocity\n\nSets the entity's local velocity. Same as Entity.SetAbsVelocity, but clamps given velocity, and is not recommended to be used because of that."
  },
  "Entity:SetLOD": {
    "prefix": "SetLOD",
    "body": "SetLOD(${1:number lod=-1})$0",
    "description": "(Client) Method: Entity:SetLOD\n\nSets the Level Of Detail model to use with this entity. This may not work for all models if the model doesn't include any LOD sub models."
  },
  "Entity:SetMaterial": {
    "prefix": "SetMaterial",
    "body": "SetMaterial(${1:string materialName}, ${2:boolean forceMaterial=false})$0",
    "description": "(Shared) Method: Entity:SetMaterial\n\nSets the rendering material override of the entity."
  },
  "Entity:SetMaxHealth": {
    "prefix": "SetMaxHealth",
    "body": "SetMaxHealth(${1:number maxhealth})$0",
    "description": "(Server) Method: Entity:SetMaxHealth\n\nSets the maximum health for entity. Note, that you can still set entity's health above this amount with Entity.SetHealth."
  },
  "Entity:SetModel": {
    "prefix": "SetModel",
    "body": "SetModel(${1:string modelName})$0",
    "description": "(Shared) Method: Entity:SetModel\n\nSets the model of the entity."
  },
  "Entity:SetModelName": {
    "prefix": "SetModelName",
    "body": "SetModelName(${1:string modelname})$0",
    "description": "(Shared) Method: Entity:SetModelName\n\nAlter the model name returned by Entity.GetModel. Does not affect the entity's actual model."
  },
  "Entity:SetModelScale": {
    "prefix": "SetModelScale",
    "body": "SetModelScale(${1:number scale}, ${2:number deltaTime=0})$0",
    "description": "(Shared) Method: Entity:SetModelScale\n\nScales the model of the entity, if the entity is a Player or an Type.NPC the hitboxes will be scaled as well."
  },
  "Entity:SetMoveCollide": {
    "prefix": "SetMoveCollide",
    "body": "SetMoveCollide(${1:number moveCollideType})$0",
    "description": "(Server) Method: Entity:SetMoveCollide\n\nSets the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide?"
  },
  "Entity:SetMoveParent": {
    "prefix": "SetMoveParent",
    "body": "SetMoveParent(${1:Entity Parent})$0",
    "description": "(Shared) Method: Entity:SetMoveParent\n\nSets the Movement Parent of an entity to another entity."
  },
  "Entity:SetMoveType": {
    "prefix": "SetMoveType",
    "body": "SetMoveType(${1:number movetype})$0",
    "description": "(Shared) Method: Entity:SetMoveType\n\nSets the entity's move type. This should be called before initializing the physics object on the entity, unless it will override SetMoveType such as Entity.PhysicsInitBox."
  },
  "Entity:SetName": {
    "prefix": "SetName",
    "body": "SetName(${1:string mappingName})$0",
    "description": "(Server) Method: Entity:SetName\n\nSets the mapping name of the entity."
  },
  "Entity:SetNetworkAngles": {
    "prefix": "SetNetworkAngles",
    "body": "SetNetworkAngles(${1:Angle angle})$0",
    "description": "(Client) Method: Entity:SetNetworkAngles\n\nAlters networked entity angles."
  },
  "Entity:SetNetworkedAngle": {
    "prefix": "SetNetworkedAngle",
    "body": "SetNetworkedAngle(${1:string key}, ${2:Angle value=Angle( 0, 0, 0 )})$0",
    "description": "(Shared) Method: Entity:SetNetworkedAngle\n\n[Deprecated] .You should use Entity.SetNWAngle instead."
  },
  "Entity:SetNetworkedBool": {
    "prefix": "SetNetworkedBool",
    "body": "SetNetworkedBool(${1:string key}, ${2:boolean value=false})$0",
    "description": "(Shared) Method: Entity:SetNetworkedBool\n\n[Deprecated] .You should use Entity.SetNWBool instead."
  },
  "Entity:SetNetworkedEntity": {
    "prefix": "SetNetworkedEntity",
    "body": "SetNetworkedEntity(${1:string key}, ${2:Entity value=NULL})$0",
    "description": "(Shared) Method: Entity:SetNetworkedEntity\n\n[Deprecated] .You should use Entity.SetNWEntity instead."
  },
  "Entity:SetNetworkedFloat": {
    "prefix": "SetNetworkedFloat",
    "body": "SetNetworkedFloat(${1:string key}, ${2:number value=0})$0",
    "description": "(Shared) Method: Entity:SetNetworkedFloat\n\n[Deprecated] .You should use Entity.SetNWFloat instead."
  },
  "Entity:SetNetworkedInt": {
    "prefix": "SetNetworkedInt",
    "body": "SetNetworkedInt(${1:string key}, ${2:number value=0})$0",
    "description": "(Shared) Method: Entity:SetNetworkedInt\n\n[Deprecated] .You should use Entity.SetNWInt instead."
  },
  "Entity:SetNetworkedNumber": {
    "prefix": "SetNetworkedNumber",
    "body": "SetNetworkedNumber(${1:any index}, ${2:number number})$0",
    "description": "(Shared) Method: Entity:SetNetworkedNumber\n\nSets a networked number at the specified index on the entity."
  },
  "Entity:SetNetworkedString": {
    "prefix": "SetNetworkedString",
    "body": "SetNetworkedString(${1:string key}, ${2:string value=\"\"})$0",
    "description": "(Shared) Method: Entity:SetNetworkedString\n\n[Deprecated] .You should use Entity.SetNWString instead."
  },
  "Entity:SetNetworkedVarProxy": {
    "prefix": "SetNetworkedVarProxy",
    "body": "SetNetworkedVarProxy(${1:string name}, ${2:function callback})$0",
    "description": "(Shared) Method: Entity:SetNetworkedVarProxy\n\n[Deprecated] .You should be using Entity.SetNWVarProxy instead."
  },
  "Entity:SetNetworkedVector": {
    "prefix": "SetNetworkedVector",
    "body": "SetNetworkedVector(${1:string key}, ${2:Vector value=Vector( 0, 0, 0 )})$0",
    "description": "(Shared) Method: Entity:SetNetworkedVector\n\n[Deprecated] .You should use Entity.SetNWVector instead."
  },
  "Entity:SetNetworkOrigin": {
    "prefix": "SetNetworkOrigin",
    "body": "SetNetworkOrigin(${1:Vector origin})$0",
    "description": "(Shared) Method: Entity:SetNetworkOrigin\n\nVirtually changes entity position for clients."
  },
  "Entity:SetNextClientThink": {
    "prefix": "SetNextClientThink",
    "body": "SetNextClientThink(${1:number nextthink})$0",
    "description": "(Client) Method: Entity:SetNextClientThink\n\nSets the next time the clientside ENTITY.Think is called."
  },
  "Entity:SetNoDraw": {
    "prefix": "SetNoDraw",
    "body": "SetNoDraw(${1:boolean shouldNotDraw})$0",
    "description": "(Shared) Method: Entity:SetNoDraw\n\nSets if the entity's model should render at all."
  },
  "Entity:SetNotSolid": {
    "prefix": "SetNotSolid",
    "body": "SetNotSolid(${1:boolean IsNotSolid})$0",
    "description": "(Shared) Method: Entity:SetNotSolid\n\nSets whether the entity is solid or not."
  },
  "Entity:SetNWAngle": {
    "prefix": "SetNWAngle",
    "body": "SetNWAngle(${1:string key}, ${2:Angle value})$0",
    "description": "(Shared) Method: Entity:SetNWAngle\n\nSets a networked angle value on the entity."
  },
  "Entity:SetNWBool": {
    "prefix": "SetNWBool",
    "body": "SetNWBool(${1:string key}, ${2:boolean value})$0",
    "description": "(Shared) Method: Entity:SetNWBool\n\nSets a networked boolean value on the entity."
  },
  "Entity:SetNWEntity": {
    "prefix": "SetNWEntity",
    "body": "SetNWEntity(${1:string key}, ${2:Entity value})$0",
    "description": "(Shared) Method: Entity:SetNWEntity\n\nSets a networked entity value on the entity."
  },
  "Entity:SetNWFloat": {
    "prefix": "SetNWFloat",
    "body": "SetNWFloat(${1:string key}, ${2:number value})$0",
    "description": "(Shared) Method: Entity:SetNWFloat\n\nSets a networked float (number) value on the entity."
  },
  "Entity:SetNWInt": {
    "prefix": "SetNWInt",
    "body": "SetNWInt(${1:string key}, ${2:number value})$0",
    "description": "(Shared) Method: Entity:SetNWInt\n\nSets a networked integer (whole number) value on the entity."
  },
  "Entity:SetNWString": {
    "prefix": "SetNWString",
    "body": "SetNWString(${1:string key}, ${2:string value})$0",
    "description": "(Shared) Method: Entity:SetNWString\n\nSets a networked string value on the entity."
  },
  "Entity:SetNWVarProxy": {
    "prefix": "SetNWVarProxy",
    "body": "SetNWVarProxy(${1:string name}, ${2:function callback})$0",
    "description": "(Shared) Method: Entity:SetNWVarProxy\n\nSets a function to be called when the NWVar changes."
  },
  "Entity:SetNWVector": {
    "prefix": "SetNWVector",
    "body": "SetNWVector(${1:string key}, ${2:Vector value})$0",
    "description": "(Shared) Method: Entity:SetNWVector\n\nSets a networked vector value on the entity."
  },
  "Entity:SetOwner": {
    "prefix": "SetOwner",
    "body": "SetOwner(${1:Entity owner=NULL})$0",
    "description": "(Shared) Method: Entity:SetOwner\n\nSets the owner of this entity, disabling all physics interaction with it."
  },
  "Entity:SetParent": {
    "prefix": "SetParent",
    "body": "SetParent(${1:Entity parent=NULL}, ${2:number attachmentId=-1})$0",
    "description": "(Shared) Method: Entity:SetParent\n\nSets the parent of this entity, making it move with its parent."
  },
  "Entity:SetParentPhysNum": {
    "prefix": "SetParentPhysNum",
    "body": "SetParentPhysNum(${1:number bone})$0",
    "description": "(Shared) Method: Entity:SetParentPhysNum\n\nSets the parent of an entity to another entity with the given physics bone number. Similar to Entity.SetParent, except it is parented to a physbone. This function is useful mainly for ragdolls."
  },
  "Entity:SetPersistent": {
    "prefix": "SetPersistent",
    "body": "SetPersistent(${1:boolean persist})$0",
    "description": "(Shared) Method: Entity:SetPersistent\n\nSets whether or not the given entity is persistent. A persistent entity will be saved on server shutdown and loaded back when the server starts up. Additionally, by default persistent entities cannot be grabbed with the physgun and tools cannot be used on them."
  },
  "Entity:SetPhysConstraintObjects": {
    "prefix": "SetPhysConstraintObjects",
    "body": "SetPhysConstraintObjects(${1:PhysObj Phys1}, ${2:PhysObj Phys2})$0",
    "description": "(Server) Method: Entity:SetPhysConstraintObjects\n\nWhen called on a constraint entity, sets the two physics objects to be constrained."
  },
  "Entity:SetPhysicsAttacker": {
    "prefix": "SetPhysicsAttacker",
    "body": "SetPhysicsAttacker(${1:Player ent}, ${2:number timeLimit=5})$0",
    "description": "(Server) Method: Entity:SetPhysicsAttacker\n\nSets the player who gets credit if this entity kills something with physics damage within the time limit."
  },
  "Entity:SetPlaybackRate": {
    "prefix": "SetPlaybackRate",
    "body": "SetPlaybackRate(${1:number fSpeed})$0",
    "description": "(Shared) Method: Entity:SetPlaybackRate\n\nAllows you to set how fast an entity's animation will play, with 1.0 being the default speed."
  },
  "Entity:SetPos": {
    "prefix": "SetPos",
    "body": "SetPos(${1:Vector position})$0",
    "description": "(Shared) Method: Entity:SetPos\n\nMoves the entity to the specified position."
  },
  "Entity:SetPoseParameter": {
    "prefix": "SetPoseParameter",
    "body": "SetPoseParameter(${1:string poseName}, ${2:number poseValue})$0",
    "description": "(Shared) Method: Entity:SetPoseParameter\n\nSets the specified pose parameter to the specified value."
  },
  "Entity:SetPredictable": {
    "prefix": "SetPredictable",
    "body": "SetPredictable(${1:boolean setPredictable})$0",
    "description": "(Client) Method: Entity:SetPredictable\n\nSets whether an entity should be predictable or not."
  },
  "Entity:SetPreventTransmit": {
    "prefix": "SetPreventTransmit",
    "body": "SetPreventTransmit(${1:Player player}, ${2:boolean stopTransmitting})$0",
    "description": "(Server) Method: Entity:SetPreventTransmit\n\nPrevents the server from sending any further information about the entity to a player."
  },
  "Entity:SetRagdollAng": {
    "prefix": "SetRagdollAng",
    "body": "SetRagdollAng(${1:number boneid}, ${2:Angle pos})$0",
    "description": "(Server) Method: Entity:SetRagdollAng\n\nSets the bone angles. This is used alongside Kinect in Entity.SetRagdollBuildFunction, for more info see ragdoll_motion entity."
  },
  "Entity:SetRagdollBuildFunction": {
    "prefix": "SetRagdollBuildFunction",
    "body": "SetRagdollBuildFunction(${1:function func})$0",
    "description": "(Server) Method: Entity:SetRagdollBuildFunction\n\nSets the function to build the ragdoll. This is used alongside Kinect, for more info see ragdoll_motion entity."
  },
  "Entity:SetRagdollPos": {
    "prefix": "SetRagdollPos",
    "body": "SetRagdollPos(${1:number boneid}, ${2:Vector pos})$0",
    "description": "(Server) Method: Entity:SetRagdollPos\n\nSets the bone position. This is used alongside Kinect in Entity.SetRagdollBuildFunction, for more info see ragdoll_motion entity."
  },
  "Entity:SetRenderAngles": {
    "prefix": "SetRenderAngles",
    "body": "SetRenderAngles(${1:Angle newAngles})$0",
    "description": "(Client) Method: Entity:SetRenderAngles\n\nSets the render angles of the Entity."
  },
  "Entity:SetRenderBounds": {
    "prefix": "SetRenderBounds",
    "body": "SetRenderBounds(${1:Vector mins}, ${2:Vector maxs}, ${3:Vector add=Vector( 0, 0, 0 )})$0",
    "description": "(Client) Method: Entity:SetRenderBounds\n\nSets the render bounds for the entity. For world space coordinates see Entity.SetRenderBoundsWS."
  },
  "Entity:SetRenderBoundsWS": {
    "prefix": "SetRenderBoundsWS",
    "body": "SetRenderBoundsWS(${1:Vector mins}, ${2:Vector maxs}, ${3:Vector add=Vector( 0, 0, 0 )})$0",
    "description": "(Client) Method: Entity:SetRenderBoundsWS\n\nSets the render bounds for the entity in world space coordinates. For relative coordinates see Entity.SetRenderBounds."
  },
  "Entity:SetRenderClipPlane": {
    "prefix": "SetRenderClipPlane",
    "body": "SetRenderClipPlane(${1:Vector planeNormal}, ${2:number planePosition})$0",
    "description": "(Client) Method: Entity:SetRenderClipPlane\n\nUsed to specify a plane, past which an object will be visually clipped."
  },
  "Entity:SetRenderClipPlaneEnabled": {
    "prefix": "SetRenderClipPlaneEnabled",
    "body": "SetRenderClipPlaneEnabled(${1:boolean enabled})$0",
    "description": "(Client) Method: Entity:SetRenderClipPlaneEnabled\n\nEnables the use of clipping planes to \"cut\" objects."
  },
  "Entity:SetRenderFX": {
    "prefix": "SetRenderFX",
    "body": "SetRenderFX(${1:number renderFX})$0",
    "description": "(Shared) Method: Entity:SetRenderFX\n\nSets entity's render FX."
  },
  "Entity:SetRenderMode": {
    "prefix": "SetRenderMode",
    "body": "SetRenderMode(${1:number renderMode})$0",
    "description": "(Shared) Method: Entity:SetRenderMode\n\nSets the render mode of the entity."
  },
  "Entity:SetRenderOrigin": {
    "prefix": "SetRenderOrigin",
    "body": "SetRenderOrigin(${1:Vector newOrigin})$0",
    "description": "(Client) Method: Entity:SetRenderOrigin\n\nSet the origin in which the Entity will be drawn from."
  },
  "Entity:SetSaveValue": {
    "prefix": "SetSaveValue",
    "body": "SetSaveValue(${1:string name}, ${2:any value})$0",
    "description": "(Shared) Method: Entity:SetSaveValue\n\nSets a save value for an entity."
  },
  "Entity:SetSequence": {
    "prefix": "SetSequence",
    "body": "SetSequence(${1:number sequenceId})$0",
    "description": "(Shared) Method: Entity:SetSequence\n\nSets the entity's model sequence."
  },
  "Entity:SetShouldPlayPickupSound": {
    "prefix": "SetShouldPlayPickupSound",
    "body": "SetShouldPlayPickupSound(${1:boolean playsound})$0",
    "description": "(Shared) Method: Entity:SetShouldPlayPickupSound\n\nSets whether or not the entity should make a physics contact sound when it's been picked up by a player."
  },
  "Entity:SetShouldServerRagdoll": {
    "prefix": "SetShouldServerRagdoll",
    "body": "SetShouldServerRagdoll(${1:boolean serverragdoll})$0",
    "description": "(Shared) Method: Entity:SetShouldServerRagdoll\n\nSets if entity should create a server ragdoll on death or a client one."
  },
  "Entity:SetSkin": {
    "prefix": "SetSkin",
    "body": "SetSkin(${1:number skinIndex})$0",
    "description": "(Shared) Method: Entity:SetSkin\n\nSets the skin of the entity."
  },
  "Entity:SetSolid": {
    "prefix": "SetSolid",
    "body": "SetSolid(${1:number solid_type})$0",
    "description": "(Shared) Method: Entity:SetSolid\n\nSets the solidity of an entity."
  },
  "Entity:SetSolidFlags": {
    "prefix": "SetSolidFlags",
    "body": "SetSolidFlags(${1:number flags})$0",
    "description": "(Shared) Method: Entity:SetSolidFlags\n\nSets solid flag(s) for the entity."
  },
  "Entity:SetSpawnEffect": {
    "prefix": "SetSpawnEffect",
    "body": "SetSpawnEffect(${1:boolean spawnEffect})$0",
    "description": "(Shared) Method: Entity:SetSpawnEffect\n\nSets whether the entity should use a spawn effect. See also: Entity.GetSpawnEffect"
  },
  "Entity:SetSubMaterial": {
    "prefix": "SetSubMaterial",
    "body": "SetSubMaterial(${1:number index=nil}, ${2:string material=nil})$0",
    "description": "(Shared) Method: Entity:SetSubMaterial\n\nOverrides a single material on the model of this entity."
  },
  "Entity:SetTable": {
    "prefix": "SetTable",
    "body": "SetTable(${1:table tab})$0",
    "description": "(Shared) Method: Entity:SetTable\n\nChanges the table that can be accessed by indexing an entity. Each entity starts with its own table by default."
  },
  "Entity:SetTransmitWithParent": {
    "prefix": "SetTransmitWithParent",
    "body": "SetTransmitWithParent(${1:boolean onoff})$0",
    "description": "(Shared) Method: Entity:SetTransmitWithParent\n\nWhen this flag is set the entity will only transmit to the player when its parent is transmitted. This is useful for things like viewmodel attachments since without this flag they will transmit to everyone (and cause the viewmodels to transmit to everyone too)."
  },
  "Entity:SetTrigger": {
    "prefix": "SetTrigger",
    "body": "SetTrigger(${1:boolean maketrigger})$0",
    "description": "(Server) Method: Entity:SetTrigger\n\nMarks the entity as a trigger, so it will generate ENTITY.StartTouch, ENTITY.Touch and ENTITY.EndTouch callbacks"
  },
  "Entity:SetUnFreezable": {
    "prefix": "SetUnFreezable",
    "body": "SetUnFreezable(${1:boolean freezable})$0",
    "description": "(Server) Method: Entity:SetUnFreezable\n\nSets whether an entity can be unfrozen, meaning that it cannot be unfrozen using the physgun."
  },
  "Entity:SetupBones": {
    "prefix": "SetupBones",
    "body": "SetupBones()$0",
    "description": "(Client) Method: Entity:SetupBones\n\nForces the entity to reconfigure its bones. You might need to call this after changing your model's scales or when manually drawing the entity multiple times at different positions."
  },
  "Entity:SetupPhonemeMappings": {
    "prefix": "SetupPhonemeMappings",
    "body": "SetupPhonemeMappings(${1:string fileRoot})$0",
    "description": "(Client) Method: Entity:SetupPhonemeMappings\n\nInitializes the class names of an entity's phoneme mappings (mouth movement data). This is called by default with argument \"phonemes\" when a flex-based entity (such as an NPC) is created."
  },
  "Entity:SetUseType": {
    "prefix": "SetUseType",
    "body": "SetUseType(${1:number useType})$0",
    "description": "(Server) Method: Entity:SetUseType\n\nSets the use type of an entity, affecting how often ENTITY.Use will be called for Lua entities."
  },
  "Entity:SetVar": {
    "prefix": "SetVar",
    "body": "SetVar(${1:string name}, ${2:any value})$0",
    "description": "(Shared) Method: Entity:SetVar\n\nAllows to quickly set variable to entity's Entity.GetTable."
  },
  "Entity:SetVelocity": {
    "prefix": "SetVelocity",
    "body": "SetVelocity(${1:Vector velocity})$0",
    "description": "(Shared) Method: Entity:SetVelocity\n\nSets an entity's velocity with a given vector velocity."
  },
  "Entity:SetWeaponModel": {
    "prefix": "SetWeaponModel",
    "body": "SetWeaponModel(${1:string viewModel}, ${2:Weapon weapon=NULL})$0",
    "description": "(Shared) Method: Entity:SetWeaponModel\n\nSets the model and associated weapon to this viewmodel entity."
  },
  "Entity:SkinCount": {
    "prefix": "SkinCount",
    "body": "SkinCount()$0",
    "description": "(Shared) Method: Entity:SkinCount\n\nReturns the amount of skins the entity has."
  },
  "Entity:SnatchModelInstance": {
    "prefix": "SnatchModelInstance",
    "body": "SnatchModelInstance(${1:Entity srcEntity})$0",
    "description": "(Client) Method: Entity:SnatchModelInstance\n\nMoves the model instance from the source entity to this entity. This can be used to transfer decals that have been applied on one entity to another."
  },
  "Entity:Spawn": {
    "prefix": "Spawn",
    "body": "Spawn()$0",
    "description": "(Shared) Method: Entity:Spawn\n\nInitializes the entity and starts its networking."
  },
  "Entity:StartLoopingSound": {
    "prefix": "StartLoopingSound",
    "body": "StartLoopingSound(${1:string sound})$0",
    "description": "(Shared) Method: Entity:StartLoopingSound\n\nStarts a \"looping\" sound. As with any other sound playing methods, this function expects the sound file to be looping itself and will not automatically loop a non looping sound file as one might expect."
  },
  "Entity:StartMotionController": {
    "prefix": "StartMotionController",
    "body": "StartMotionController()$0",
    "description": "(Shared) Method: Entity:StartMotionController\n\nStarts a motion controller in the physics engine tied to this entity's PhysObj, which enables the use of ENTITY.PhysicsSimulate."
  },
  "Entity:StopAndDestroyParticles": {
    "prefix": "StopAndDestroyParticles",
    "body": "StopAndDestroyParticles()$0",
    "description": "(Client) Method: Entity:StopAndDestroyParticles\n\nStops all particle effects parented to the entity and immediately destroys them."
  },
  "Entity:StopLoopingSound": {
    "prefix": "StopLoopingSound",
    "body": "StopLoopingSound(${1:number id})$0",
    "description": "(Shared) Method: Entity:StopLoopingSound\n\nStops a sound created by Entity.StartLoopingSound."
  },
  "Entity:StopMotionController": {
    "prefix": "StopMotionController",
    "body": "StopMotionController()$0",
    "description": "(Shared) Method: Entity:StopMotionController\n\nStops the motion controller created with Entity.StartMotionController."
  },
  "Entity:StopParticleEmission": {
    "prefix": "StopParticleEmission",
    "body": "StopParticleEmission()$0",
    "description": "(Client) Method: Entity:StopParticleEmission\n\nStops all particle effects parented to the entity."
  },
  "Entity:StopParticles": {
    "prefix": "StopParticles",
    "body": "StopParticles()$0",
    "description": "(Shared) Method: Entity:StopParticles\n\nStops any attached to the entity .pcf particles using _G.ParticleEffectAttach."
  },
  "Entity:StopParticlesNamed": {
    "prefix": "StopParticlesNamed",
    "body": "StopParticlesNamed(${1:string name})$0",
    "description": "(Client) Method: Entity:StopParticlesNamed\n\nStops all particle effects parented to the entity with given name."
  },
  "Entity:StopParticlesWithNameAndAttachment": {
    "prefix": "StopParticlesWithNameAndAttachment",
    "body": "StopParticlesWithNameAndAttachment(${1:string name}, ${2:number attachment})$0",
    "description": "(Client) Method: Entity:StopParticlesWithNameAndAttachment\n\nStops all particle effects parented to the entity with given name on given attachment."
  },
  "Entity:StopSound": {
    "prefix": "StopSound",
    "body": "StopSound(${1:string soundscript})$0",
    "description": "(Shared) Method: Entity:StopSound\n\nStops emitting the given sound script from the entity, especially useful for looping sound scripts."
  },
  "Entity:TakeDamage": {
    "prefix": "TakeDamage",
    "body": "TakeDamage(${1:number damageAmount}, ${2:Entity attacker}, ${3:Entity inflictor})$0",
    "description": "(Server) Method: Entity:TakeDamage\n\nApplies the specified amount of damage to the entity."
  },
  "Entity:TakeDamageInfo": {
    "prefix": "TakeDamageInfo",
    "body": "TakeDamageInfo(${1:CTakeDamageInfo damageInfo})$0",
    "description": "(Server) Method: Entity:TakeDamageInfo\n\nApplies the damage specified by the damage info to the entity."
  },
  "Entity:TakePhysicsDamage": {
    "prefix": "TakePhysicsDamage",
    "body": "TakePhysicsDamage(${1:CTakeDamageInfo dmginfo})$0",
    "description": "(Server) Method: Entity:TakePhysicsDamage\n\nApplies physics damage to the entity"
  },
  "Entity:TestPVS": {
    "prefix": "TestPVS",
    "body": "TestPVS(${1:any testPoint})$0",
    "description": "(Server) Method: Entity:TestPVS\n\nCheck if the given position or entity is within this entity's PVS."
  },
  "Entity:TranslateBoneToPhysBone": {
    "prefix": "TranslateBoneToPhysBone",
    "body": "TranslateBoneToPhysBone(${1:number boneID})$0",
    "description": "(Shared) Method: Entity:TranslateBoneToPhysBone\n\nReturns the ID of a PhysObj attached to the given bone. To be used with Entity.GetPhysicsObjectNum."
  },
  "Entity:TranslatePhysBoneToBone": {
    "prefix": "TranslatePhysBoneToBone",
    "body": "TranslatePhysBoneToBone(${1:number physNum})$0",
    "description": "(Shared) Method: Entity:TranslatePhysBoneToBone\n\nReturns the boneID of the bone the given PhysObj is attached to."
  },
  "Entity:Use": {
    "prefix": "Use",
    "body": "Use(${1:Player Activator}, ${2:Entity Caller}, ${3:number UseType}, ${4:number Integer})$0",
    "description": "(Server) Method: Entity:Use\n\nActivates the entity, as if a player pressed the Use key (Default Key.E) on it."
  },
  "Entity:UseClientSideAnimation": {
    "prefix": "UseClientSideAnimation",
    "body": "UseClientSideAnimation()$0",
    "description": "(Shared) Method: Entity:UseClientSideAnimation\n\nStub"
  },
  "Entity:UseTriggerBounds": {
    "prefix": "UseTriggerBounds",
    "body": "UseTriggerBounds(${1:boolean enable}, ${2:number bloat=0})$0",
    "description": "(Shared) Method: Entity:UseTriggerBounds\n\nEnables or disables trigger bounds."
  },
  "Entity:ViewModelIndex": {
    "prefix": "ViewModelIndex",
    "body": "ViewModelIndex()$0",
    "description": "(Shared) Method: Entity:ViewModelIndex\n\nReturns the index of this view model, it can be used to identify which one of the player's view models this entity is."
  },
  "Entity:Visible": {
    "prefix": "Visible",
    "body": "Visible(${1:Entity Entity})$0",
    "description": "(Server) Method: Entity:Visible\n\nReturns true if the provided entity is visible from the passed entity."
  },
  "Entity:VisibleVec": {
    "prefix": "VisibleVec",
    "body": "VisibleVec(${1:Vector pos})$0",
    "description": "(Server) Method: Entity:VisibleVec\n\nReturns true if supplied vector is visible from the entity's line of sight."
  },
  "Entity:WaterLevel": {
    "prefix": "WaterLevel",
    "body": "WaterLevel()$0",
    "description": "(Shared) Method: Entity:WaterLevel\n\nReturns an integer that represents how deep in water the entity is."
  },
  "Entity:Weapon_SetActivity": {
    "prefix": "Weapon_SetActivity",
    "body": "Weapon_SetActivity(${1:number act}, ${2:number duration})$0",
    "description": "(Shared) Method: Entity:Weapon_SetActivity\n\nStub"
  },
  "Entity:Weapon_TranslateActivity": {
    "prefix": "Weapon_TranslateActivity",
    "body": "Weapon_TranslateActivity(${1:number act})$0",
    "description": "(Shared) Method: Entity:Weapon_TranslateActivity\n\nCalls and returns WEAPON.TranslateActivity on the weapon the entity ( player or NPC ) carries."
  },
  "Entity:WorldSpaceAABB": {
    "prefix": "WorldSpaceAABB",
    "body": "WorldSpaceAABB()$0",
    "description": "(Shared) Method: Entity:WorldSpaceAABB\n\nReturns two vectors representing the minimum and maximum extent of the entity's bounding box."
  },
  "Entity:WorldSpaceCenter": {
    "prefix": "WorldSpaceCenter",
    "body": "WorldSpaceCenter()$0",
    "description": "(Shared) Method: Entity:WorldSpaceCenter\n\nReturns the center of the entity according to its collision model."
  },
  "Entity:WorldToLocal": {
    "prefix": "WorldToLocal",
    "body": "WorldToLocal(${1:Vector wpos})$0",
    "description": "(Shared) Method: Entity:WorldToLocal\n\nConverts a worldspace vector into a vector local to an entity"
  },
  "Entity:WorldToLocalAngles": {
    "prefix": "WorldToLocalAngles",
    "body": "WorldToLocalAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: Entity:WorldToLocalAngles\n\nConverts world angles to local angles ( local to the entity )"
  },
  "File:Close": {
    "prefix": "Close",
    "body": "Close()$0",
    "description": "(Shared) Method: File:Close\n\nDumps the file changes to disk and closes the file handle which makes the handle useless."
  },
  "File:Flush": {
    "prefix": "Flush",
    "body": "Flush()$0",
    "description": "(Shared) Method: File:Flush\n\nDumps the file changes to disk and saves the file."
  },
  "File:Read": {
    "prefix": "Read",
    "body": "Read(${1:number length})$0",
    "description": "(Shared) Method: File:Read\n\nReads the specified amount of chars and returns them as a binary string."
  },
  "File:ReadBool": {
    "prefix": "ReadBool",
    "body": "ReadBool()$0",
    "description": "(Shared) Method: File:ReadBool\n\nReads one byte of the file and returns whether that byte was not 0."
  },
  "File:ReadByte": {
    "prefix": "ReadByte",
    "body": "ReadByte()$0",
    "description": "(Shared) Method: File:ReadByte\n\nReads one unsigned 8-bit integer from the file."
  },
  "File:ReadDouble": {
    "prefix": "ReadDouble",
    "body": "ReadDouble()$0",
    "description": "(Shared) Method: File:ReadDouble\n\nReads 8 bytes from the file converts them to a double and returns them."
  },
  "File:ReadFloat": {
    "prefix": "ReadFloat",
    "body": "ReadFloat()$0",
    "description": "(Shared) Method: File:ReadFloat\n\nReads 4 bytes from the file converts them to a float and returns them."
  },
  "File:ReadLine": {
    "prefix": "ReadLine",
    "body": "ReadLine()$0",
    "description": "(Shared) Method: File:ReadLine\n\nReturns the contents of the file from the current position up until the end of the current line. This function will not return more than 8192 characters."
  },
  "File:ReadLong": {
    "prefix": "ReadLong",
    "body": "ReadLong()$0",
    "description": "(Shared) Method: File:ReadLong\n\nReads a signed 32-bit integer from the file."
  },
  "File:ReadShort": {
    "prefix": "ReadShort",
    "body": "ReadShort()$0",
    "description": "(Shared) Method: File:ReadShort\n\nReads a signed 16-bit integer from the file."
  },
  "File:Seek": {
    "prefix": "Seek",
    "body": "Seek(${1:number pos})$0",
    "description": "(Shared) Method: File:Seek\n\nSets the file pointer to the specified position."
  },
  "File:Size": {
    "prefix": "Size",
    "body": "Size()$0",
    "description": "(Shared) Method: File:Size\n\nReturns the size of the file in bytes."
  },
  "File:Skip": {
    "prefix": "Skip",
    "body": "Skip(${1:number amount})$0",
    "description": "(Shared) Method: File:Skip\n\nMoves the file pointer by the specified amount of chars."
  },
  "File:Tell": {
    "prefix": "Tell",
    "body": "Tell()$0",
    "description": "(Shared) Method: File:Tell\n\nReturns the current position of the file pointer."
  },
  "File:Write": {
    "prefix": "Write",
    "body": "Write(${1:string data})$0",
    "description": "(Shared) Method: File:Write\n\nWrites the given string into the file."
  },
  "File:WriteBool": {
    "prefix": "WriteBool",
    "body": "WriteBool(${1:boolean bool})$0",
    "description": "(Shared) Method: File:WriteBool\n\nWrites on byte, representing the a Boolean to the file."
  },
  "File:WriteByte": {
    "prefix": "WriteByte",
    "body": "WriteByte(${1:number uint8})$0",
    "description": "(Shared) Method: File:WriteByte\n\nWrite an 8-bit unsigned integer to the file."
  },
  "File:WriteDouble": {
    "prefix": "WriteDouble",
    "body": "WriteDouble(${1:number double})$0",
    "description": "(Shared) Method: File:WriteDouble\n\nWrites a 8byte floating point double to the file."
  },
  "File:WriteFloat": {
    "prefix": "WriteFloat",
    "body": "WriteFloat(${1:number float})$0",
    "description": "(Shared) Method: File:WriteFloat\n\nWrites a 4byte float to the file."
  },
  "File:WriteLong": {
    "prefix": "WriteLong",
    "body": "WriteLong(${1:number int32})$0",
    "description": "(Shared) Method: File:WriteLong\n\nWrites a 32-bit signed integer to the file."
  },
  "File:WriteShort": {
    "prefix": "WriteShort",
    "body": "WriteShort(${1:number int16})$0",
    "description": "(Shared) Method: File:WriteShort\n\nWrites a 16-bit signed integer to the file."
  },
  "IGModAudioChannel:EnableLooping": {
    "prefix": "EnableLooping",
    "body": "EnableLooping(${1:boolean enable})$0",
    "description": "(Client) Method: IGModAudioChannel:EnableLooping\n\nEnables or disables looping of audio channel, requires noblock flag."
  },
  "IGModAudioChannel:FFT": {
    "prefix": "FFT",
    "body": "FFT(${1:table tbl}, ${2:number size})$0",
    "description": "(Client) Method: IGModAudioChannel:FFT\n\nComputes the [https://en.wikipedia.org/wiki/Discrete_Fourier_transform DFT (discrete Fourier transform)] of the sound channel."
  },
  "IGModAudioChannel:Get3DCone": {
    "prefix": "Get3DCone",
    "body": "Get3DCone()$0",
    "description": "(Client) Method: IGModAudioChannel:Get3DCone\n\nReturns 3D cone of the sound channel. See IGModAudioChannel.Set3DCone."
  },
  "IGModAudioChannel:Get3DFadeDistance": {
    "prefix": "Get3DFadeDistance",
    "body": "Get3DFadeDistance()$0",
    "description": "(Client) Method: IGModAudioChannel:Get3DFadeDistance\n\nReturns 3D fade distances of a sound channel."
  },
  "IGModAudioChannel:GetBitsPerSample": {
    "prefix": "GetBitsPerSample",
    "body": "GetBitsPerSample()$0",
    "description": "(Client) Method: IGModAudioChannel:GetBitsPerSample\n\nRetrieves the number of bits per sample of the sound channel."
  },
  "IGModAudioChannel:GetFileName": {
    "prefix": "GetFileName",
    "body": "GetFileName()$0",
    "description": "(Client) Method: IGModAudioChannel:GetFileName\n\nReturns the filename for the sound channel."
  },
  "IGModAudioChannel:GetLength": {
    "prefix": "GetLength",
    "body": "GetLength()$0",
    "description": "(Client) Method: IGModAudioChannel:GetLength\n\nReturns the length of sound played by the sound channel."
  },
  "IGModAudioChannel:GetLevel": {
    "prefix": "GetLevel",
    "body": "GetLevel()$0",
    "description": "(Client) Method: IGModAudioChannel:GetLevel\n\nReturns the right and left levels of sound played by the sound channel."
  },
  "IGModAudioChannel:GetPlaybackRate": {
    "prefix": "GetPlaybackRate",
    "body": "GetPlaybackRate()$0",
    "description": "(Client) Method: IGModAudioChannel:GetPlaybackRate\n\nReturns the playback rate of the sound channel."
  },
  "IGModAudioChannel:GetPos": {
    "prefix": "GetPos",
    "body": "GetPos()$0",
    "description": "(Client) Method: IGModAudioChannel:GetPos\n\nReturns position of the sound channel"
  },
  "IGModAudioChannel:GetSamplingRate": {
    "prefix": "GetSamplingRate",
    "body": "GetSamplingRate()$0",
    "description": "(Client) Method: IGModAudioChannel:GetSamplingRate\n\nReturns the sample rate for currently playing sound."
  },
  "IGModAudioChannel:GetState": {
    "prefix": "GetState",
    "body": "GetState()$0",
    "description": "(Client) Method: IGModAudioChannel:GetState\n\nReturns the state of a sound channel"
  },
  "IGModAudioChannel:GetTime": {
    "prefix": "GetTime",
    "body": "GetTime()$0",
    "description": "(Client) Method: IGModAudioChannel:GetTime\n\nReturns the current time of the sound channel"
  },
  "IGModAudioChannel:GetVolume": {
    "prefix": "GetVolume",
    "body": "GetVolume()$0",
    "description": "(Client) Method: IGModAudioChannel:GetVolume\n\nReturns volume of a sound channel"
  },
  "IGModAudioChannel:Is3D": {
    "prefix": "Is3D",
    "body": "Is3D()$0",
    "description": "(Client) Method: IGModAudioChannel:Is3D\n\nReturns if the sound channel is in 3D mode or not."
  },
  "IGModAudioChannel:IsBlockStreamed": {
    "prefix": "IsBlockStreamed",
    "body": "IsBlockStreamed()$0",
    "description": "(Client) Method: IGModAudioChannel:IsBlockStreamed\n\nReturns whether the audio stream is block streamed or not."
  },
  "IGModAudioChannel:IsLooping": {
    "prefix": "IsLooping",
    "body": "IsLooping()$0",
    "description": "(Client) Method: IGModAudioChannel:IsLooping\n\nReturns if the sound channel is looping or not."
  },
  "IGModAudioChannel:IsOnline": {
    "prefix": "IsOnline",
    "body": "IsOnline()$0",
    "description": "(Client) Method: IGModAudioChannel:IsOnline\n\nReturns if the sound channel is streamed from the Internet or not. "
  },
  "IGModAudioChannel:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Client) Method: IGModAudioChannel:IsValid\n\nReturns if the sound channel is valid or not."
  },
  "IGModAudioChannel:Pause": {
    "prefix": "Pause",
    "body": "Pause()$0",
    "description": "(Client) Method: IGModAudioChannel:Pause\n\nPauses the stream. It can be started again using IGModAudioChannel.Play"
  },
  "IGModAudioChannel:Play": {
    "prefix": "Play",
    "body": "Play()$0",
    "description": "(Client) Method: IGModAudioChannel:Play\n\nStarts playing the stream."
  },
  "IGModAudioChannel:Set3DCone": {
    "prefix": "Set3DCone",
    "body": "Set3DCone(${1:number innerAngle}, ${2:number outerAngle}, ${3:number outerVolume})$0",
    "description": "(Client) Method: IGModAudioChannel:Set3DCone\n\nSets 3D cone of the sound channel."
  },
  "IGModAudioChannel:Set3DFadeDistance": {
    "prefix": "Set3DFadeDistance",
    "body": "Set3DFadeDistance(${1:number min}, ${2:number max})$0",
    "description": "(Client) Method: IGModAudioChannel:Set3DFadeDistance\n\nSets 3D fade distances of a sound channel."
  },
  "IGModAudioChannel:SetPlaybackRate": {
    "prefix": "SetPlaybackRate",
    "body": "SetPlaybackRate(${1:number rate})$0",
    "description": "(Client) Method: IGModAudioChannel:SetPlaybackRate\n\nSets the playback rate of the sound channel. May not work with high values for radio streams."
  },
  "IGModAudioChannel:SetPos": {
    "prefix": "SetPos",
    "body": "SetPos(${1:Vector pos}, ${2:Vector dir=Vector( 0, 0, 0 )})$0",
    "description": "(Client) Method: IGModAudioChannel:SetPos\n\nSets position of sound channel in case the sound channel has a 3d option set."
  },
  "IGModAudioChannel:SetTime": {
    "prefix": "SetTime",
    "body": "SetTime(${1:number secs})$0",
    "description": "(Client) Method: IGModAudioChannel:SetTime\n\nSets the sound channel to specified time ( Rewind to that position of the song ). Does not work on online radio streams."
  },
  "IGModAudioChannel:SetVolume": {
    "prefix": "SetVolume",
    "body": "SetVolume(${1:number volume})$0",
    "description": "(Client) Method: IGModAudioChannel:SetVolume\n\nSets the volume of a sound channel"
  },
  "IGModAudioChannel:Stop": {
    "prefix": "Stop",
    "body": "Stop()$0",
    "description": "(Client) Method: IGModAudioChannel:Stop\n\nWarning.This is currently broken and causes the object to become invalid. It will not play again. [https://github.com/Facepunch/garrysmod-issues/issues/1497 Issue #1497]"
  },
  "IMaterial:GetColor": {
    "prefix": "GetColor",
    "body": "GetColor(${1:number x}, ${2:number y})$0",
    "description": "(Shared) Method: IMaterial:GetColor\n\nReturns the color of the specified pixel of the $basetexture, only works for materials created from PNG files."
  },
  "IMaterial:GetFloat": {
    "prefix": "GetFloat",
    "body": "GetFloat(${1:string materialFloat})$0",
    "description": "(Shared) Method: IMaterial:GetFloat\n\nReturns the specified material value as a float, or nil if the value is not set."
  },
  "IMaterial:GetInt": {
    "prefix": "GetInt",
    "body": "GetInt(${1:string materialInt})$0",
    "description": "(Shared) Method: IMaterial:GetInt\n\nReturns the specified material value as a int, rounds the value if its a float, or nil if the value is not set."
  },
  "IMaterial:GetKeyValues": {
    "prefix": "GetKeyValues",
    "body": "GetKeyValues()$0",
    "description": "(Shared) Method: IMaterial:GetKeyValues\n\nGets all the key values defined for the material."
  },
  "IMaterial:GetMatrix": {
    "prefix": "GetMatrix",
    "body": "GetMatrix(${1:string materialMatrix})$0",
    "description": "(Shared) Method: IMaterial:GetMatrix\n\nReturns the specified material matrix as a int, or nil if the value is not set or is not a matrix."
  },
  "IMaterial:GetName": {
    "prefix": "GetName",
    "body": "GetName()$0",
    "description": "(Shared) Method: IMaterial:GetName\n\nReturns the name of the material, in most cases the path."
  },
  "IMaterial:GetShader": {
    "prefix": "GetShader",
    "body": "GetShader()$0",
    "description": "(Shared) Method: IMaterial:GetShader\n\nReturns the name of the materials shader."
  },
  "IMaterial:GetString": {
    "prefix": "GetString",
    "body": "GetString(${1:string materialString})$0",
    "description": "(Shared) Method: IMaterial:GetString\n\nReturns the specified material string, or nil if the value is not set or if the value can not be converted to a string."
  },
  "IMaterial:GetTexture": {
    "prefix": "GetTexture",
    "body": "GetTexture(${1:string param})$0",
    "description": "(Shared) Method: IMaterial:GetTexture\n\nReturns an ITexture based on the passed shader parameter."
  },
  "IMaterial:GetVector": {
    "prefix": "GetVector",
    "body": "GetVector(${1:string materialVector})$0",
    "description": "(Shared) Method: IMaterial:GetVector\n\nReturns the specified material linear color vector, or nil if the value is not set."
  },
  "IMaterial:Height": {
    "prefix": "Height",
    "body": "Height()$0",
    "description": "(Shared) Method: IMaterial:Height\n\nReturns the height of the member texture set for $basetexture."
  },
  "IMaterial:IsError": {
    "prefix": "IsError",
    "body": "IsError()$0",
    "description": "(Shared) Method: IMaterial:IsError\n\nReturns whenever the material was not loaded successfully."
  },
  "IMaterial:Recompute": {
    "prefix": "Recompute",
    "body": "Recompute()$0",
    "description": "(Shared) Method: IMaterial:Recompute\n\nRecomputes the material's snapshot. This needs to be called if you have changed variables on your material and it isn't changing. "
  },
  "IMaterial:SetFloat": {
    "prefix": "SetFloat",
    "body": "SetFloat(${1:string materialFloat}, ${2:number float})$0",
    "description": "(Shared) Method: IMaterial:SetFloat\n\nSets the specified material float to the specified float, does nothing on a type mismatch."
  },
  "IMaterial:SetInt": {
    "prefix": "SetInt",
    "body": "SetInt(${1:string materialInt}, ${2:number int})$0",
    "description": "(Shared) Method: IMaterial:SetInt\n\nSets the specified material value to the specified int, does nothing on a type mismatch."
  },
  "IMaterial:SetMatrix": {
    "prefix": "SetMatrix",
    "body": "SetMatrix(${1:string materialMatrix}, ${2:VMatrix matrix})$0",
    "description": "(Shared) Method: IMaterial:SetMatrix\n\nSets the specified material value to the specified matrix, does nothing on a type mismatch."
  },
  "IMaterial:SetShader": {
    "prefix": "SetShader",
    "body": "SetShader(${1:string shaderName})$0",
    "description": "(Shared) Method: IMaterial:SetShader\n\n[Deprecated] .This function does nothingThe functionality of this function was removed due to the amount of crashes it caused."
  },
  "IMaterial:SetString": {
    "prefix": "SetString",
    "body": "SetString(${1:string materialString}, ${2:string string})$0",
    "description": "(Shared) Method: IMaterial:SetString\n\nSets the specified material value to the specified string, does nothing on a type mismatch."
  },
  "IMaterial:SetTexture": {
    "prefix": "SetTexture",
    "body": "SetTexture(${1:string materialTexture}, ${2:ITexture texture})$0",
    "description": "(Shared) Method: IMaterial:SetTexture\n\nSets the specified material texture to the specified texture, does nothing on a type mismatch."
  },
  "IMaterial:SetUndefined": {
    "prefix": "SetUndefined",
    "body": "SetUndefined(${1:string materialValueName})$0",
    "description": "(Shared) Method: IMaterial:SetUndefined\n\nUnsets the value for the specified material value."
  },
  "IMaterial:SetVector": {
    "prefix": "SetVector",
    "body": "SetVector(${1:string MaterialVector}, ${2:Vector vec})$0",
    "description": "(Shared) Method: IMaterial:SetVector\n\nSets the specified material vector to the specified vector, does nothing on a type mismatch."
  },
  "IMaterial:Width": {
    "prefix": "Width",
    "body": "Width()$0",
    "description": "(Shared) Method: IMaterial:Width\n\nReturns the width of the member texture set for $basetexture."
  },
  "IMesh:BuildFromTriangles": {
    "prefix": "BuildFromTriangles",
    "body": "BuildFromTriangles(${1:table vertexes})$0",
    "description": "(Client) Method: IMesh:BuildFromTriangles\n\nBuilds the mesh from a table mesh vertexes."
  },
  "IMesh:Destroy": {
    "prefix": "Destroy",
    "body": "Destroy()$0",
    "description": "(Client) Method: IMesh:Destroy\n\nDeletes the mesh and frees the memory used by it.."
  },
  "IMesh:Draw": {
    "prefix": "Draw",
    "body": "Draw()$0",
    "description": "(Client) Method: IMesh:Draw\n\nRenders the mesh with the active matrix."
  },
  "IRestore:EndBlock": {
    "prefix": "EndBlock",
    "body": "EndBlock()$0",
    "description": "(Shared) Method: IRestore:EndBlock\n\nEnds current data block started with IRestore.StartBlock and returns to the parent block."
  },
  "IRestore:ReadAngle": {
    "prefix": "ReadAngle",
    "body": "ReadAngle()$0",
    "description": "(Shared) Method: IRestore:ReadAngle\n\nReads next bytes from the restore object as an Angle."
  },
  "IRestore:ReadBool": {
    "prefix": "ReadBool",
    "body": "ReadBool()$0",
    "description": "(Shared) Method: IRestore:ReadBool\n\nReads next bytes from the restore object as a boolean."
  },
  "IRestore:ReadEntity": {
    "prefix": "ReadEntity",
    "body": "ReadEntity()$0",
    "description": "(Shared) Method: IRestore:ReadEntity\n\nReads next bytes from the restore object as an Entity."
  },
  "IRestore:ReadFloat": {
    "prefix": "ReadFloat",
    "body": "ReadFloat()$0",
    "description": "(Shared) Method: IRestore:ReadFloat\n\nReads next bytes from the restore object as a floating point number."
  },
  "IRestore:ReadInt": {
    "prefix": "ReadInt",
    "body": "ReadInt()$0",
    "description": "(Shared) Method: IRestore:ReadInt\n\nReads next bytes from the restore object as an integer number."
  },
  "IRestore:ReadString": {
    "prefix": "ReadString",
    "body": "ReadString()$0",
    "description": "(Shared) Method: IRestore:ReadString\n\nReads next bytes from the restore object as a string."
  },
  "IRestore:ReadVector": {
    "prefix": "ReadVector",
    "body": "ReadVector()$0",
    "description": "(Shared) Method: IRestore:ReadVector\n\nReads next bytes from the restore object as a Vector."
  },
  "IRestore:StartBlock": {
    "prefix": "StartBlock",
    "body": "StartBlock()$0",
    "description": "(Shared) Method: IRestore:StartBlock\n\nLoads next block of data to be read inside current block. Blocks '''must''' be ended with IRestore.EndBlock."
  },
  "ISave:EndBlock": {
    "prefix": "EndBlock",
    "body": "EndBlock()$0",
    "description": "(Shared) Method: ISave:EndBlock\n\nEnds current data block started with ISave.StartBlock and returns to the parent block."
  },
  "ISave:StartBlock": {
    "prefix": "StartBlock",
    "body": "StartBlock(${1:string name})$0",
    "description": "(Shared) Method: ISave:StartBlock\n\nStarts a new block of data that you can write to inside current block. Blocks '''must''' be ended with ISave.EndBlock."
  },
  "ISave:WriteAngle": {
    "prefix": "WriteAngle",
    "body": "WriteAngle(${1:Angle ang})$0",
    "description": "(Shared) Method: ISave:WriteAngle\n\nWrites an Angle to the save object."
  },
  "ISave:WriteBool": {
    "prefix": "WriteBool",
    "body": "WriteBool(${1:boolean bool})$0",
    "description": "(Shared) Method: ISave:WriteBool\n\nWrites a boolean to the save object."
  },
  "ISave:WriteEntity": {
    "prefix": "WriteEntity",
    "body": "WriteEntity(${1:Entity ent})$0",
    "description": "(Shared) Method: ISave:WriteEntity\n\nWrites an Entity to the save object."
  },
  "ISave:WriteFloat": {
    "prefix": "WriteFloat",
    "body": "WriteFloat(${1:number float})$0",
    "description": "(Shared) Method: ISave:WriteFloat\n\nWrites a floating point number to the save object."
  },
  "ISave:WriteInt": {
    "prefix": "WriteInt",
    "body": "WriteInt(${1:number int})$0",
    "description": "(Shared) Method: ISave:WriteInt\n\nWrites an integer number to the save object."
  },
  "ISave:WriteString": {
    "prefix": "WriteString",
    "body": "WriteString(${1:string str})$0",
    "description": "(Shared) Method: ISave:WriteString\n\nWrites a string to the save object."
  },
  "ISave:WriteVector": {
    "prefix": "WriteVector",
    "body": "WriteVector(${1:Vector vec})$0",
    "description": "(Shared) Method: ISave:WriteVector\n\nWrites a Vector to the save object."
  },
  "ITexture:Download": {
    "prefix": "Download",
    "body": "Download()$0",
    "description": "(Shared) Method: ITexture:Download\n\nInvokes the generator of the texture. Reloads file based textures from disk and clears render target textures."
  },
  "ITexture:GetColor": {
    "prefix": "GetColor",
    "body": "GetColor(${1:number x}, ${2:number y})$0",
    "description": "(Shared) Method: ITexture:GetColor\n\nReturns the color of the specified pixel, only works for textures created from PNG files."
  },
  "ITexture:GetMappingHeight": {
    "prefix": "GetMappingHeight",
    "body": "GetMappingHeight()$0",
    "description": "(Shared) Method: ITexture:GetMappingHeight\n\nReturns the true unmodified height of the texture."
  },
  "ITexture:GetMappingWidth": {
    "prefix": "GetMappingWidth",
    "body": "GetMappingWidth()$0",
    "description": "(Shared) Method: ITexture:GetMappingWidth\n\nReturns the true unmodified width of the texture."
  },
  "ITexture:GetName": {
    "prefix": "GetName",
    "body": "GetName()$0",
    "description": "(Shared) Method: ITexture:GetName\n\nReturns the name of the texture, in most cases the path."
  },
  "ITexture:Height": {
    "prefix": "Height",
    "body": "Height()$0",
    "description": "(Shared) Method: ITexture:Height\n\nReturns the modified height of the texture, this value may be affected by mipmapping and other factors."
  },
  "ITexture:IsError": {
    "prefix": "IsError",
    "body": "IsError()$0",
    "description": "(Shared) Method: ITexture:IsError\n\nReturns whenever the texture is invalid or not."
  },
  "ITexture:Width": {
    "prefix": "Width",
    "body": "Width()$0",
    "description": "(Shared) Method: ITexture:Width\n\nReturns the modified width of the texture, this value may be affected by mipmapping and other factors."
  },
  "IVideoWriter:AddFrame": {
    "prefix": "AddFrame",
    "body": "AddFrame(${1:number frameTime}, ${2:boolean downsample})$0",
    "description": "(Client) Method: IVideoWriter:AddFrame\n\nAdds the current framebuffer to the video stream."
  },
  "IVideoWriter:Finish": {
    "prefix": "Finish",
    "body": "Finish()$0",
    "description": "(Client) Method: IVideoWriter:Finish\n\nEnds the video recording and dumps it to disk."
  },
  "IVideoWriter:Height": {
    "prefix": "Height",
    "body": "Height()$0",
    "description": "(Client) Method: IVideoWriter:Height\n\nReturns the height of the video stream."
  },
  "IVideoWriter:SetRecordSound": {
    "prefix": "SetRecordSound",
    "body": "SetRecordSound(${1:boolean record})$0",
    "description": "(Client) Method: IVideoWriter:SetRecordSound\n\nSets whether to record sound or not."
  },
  "IVideoWriter:Width": {
    "prefix": "Width",
    "body": "Width()$0",
    "description": "(Client) Method: IVideoWriter:Width\n\nReturns the width of the video stream."
  },
  "MarkupObject:Create": {
    "prefix": "Create",
    "body": "Create()$0",
    "description": "(Client) Method: MarkupObject:Create\n\n[Internal] "
  },
  "MarkupObject:Draw": {
    "prefix": "Draw",
    "body": "Draw(${1:number xOffset}, ${2:number yOffset}, ${3:number xAlign}, ${4:number yAlign}, ${5:number alphaoverride=255})$0",
    "description": "(Client) Method: MarkupObject:Draw\n\nDraws the computed markupobject to the screen."
  },
  "MarkupObject:GetHeight": {
    "prefix": "GetHeight",
    "body": "GetHeight()$0",
    "description": "(Client) Method: MarkupObject:GetHeight\n\nGets computed the height of the markupobject."
  },
  "MarkupObject:GetWidth": {
    "prefix": "GetWidth",
    "body": "GetWidth()$0",
    "description": "(Client) Method: MarkupObject:GetWidth\n\nGets computed the width of the markupobject."
  },
  "MarkupObject:Size": {
    "prefix": "Size",
    "body": "Size()$0",
    "description": "(Client) Method: MarkupObject:Size\n\nGets computed the width and height of the markupobject."
  },
  "navmesh:CreateNavArea": {
    "prefix": "CreateNavArea",
    "body": "CreateNavArea(${1:Vector corner}, ${2:Vector opposite_corner})$0",
    "description": "(Server) Method: navmesh:CreateNavArea\n\nCreates a new CNavArea."
  },
  "NextBot:BecomeRagdoll": {
    "prefix": "BecomeRagdoll",
    "body": "BecomeRagdoll(${1:CTakeDamageInfo info})$0",
    "description": "(Server) Method: NextBot:BecomeRagdoll\n\nBecome a ragdoll and remove the entity."
  },
  "NextBot:BodyMoveXY": {
    "prefix": "BodyMoveXY",
    "body": "BodyMoveXY()$0",
    "description": "(Server) Method: NextBot:BodyMoveXY\n\nShould only be called in BodyUpdate. This sets the move_x and move_y pose parameters of the bot to fit how they're currently moving, sets the animation speed to suit the ground speed and calls FrameAdvance."
  },
  "NextBot:FindSpot": {
    "prefix": "FindSpot",
    "body": "FindSpot(${1:string type}, ${2:table options})$0",
    "description": "(Server) Method: NextBot:FindSpot\n\nLike NextBot.FindSpots but only returns a vector."
  },
  "NextBot:FindSpots": {
    "prefix": "FindSpots",
    "body": "FindSpots(${1:table specs})$0",
    "description": "(Server) Method: NextBot:FindSpots\n\nReturns a table of hiding spots."
  },
  "NextBot:GetActivity": {
    "prefix": "GetActivity",
    "body": "GetActivity()$0",
    "description": "(Server) Method: NextBot:GetActivity\n\nReturns the currently running activity"
  },
  "NextBot:GetRangeSquaredTo": {
    "prefix": "GetRangeSquaredTo",
    "body": "GetRangeSquaredTo(${1:Vector to})$0",
    "description": "(Server) Method: NextBot:GetRangeSquaredTo\n\nReturns the distance to an entity or position. It is supposed to return a squared distance, however."
  },
  "NextBot:GetRangeTo": {
    "prefix": "GetRangeTo",
    "body": "GetRangeTo(${1:Vector to})$0",
    "description": "(Server) Method: NextBot:GetRangeTo\n\nReturns the distance to an entity or position"
  },
  "NextBot:GetSolidMask": {
    "prefix": "GetSolidMask",
    "body": "GetSolidMask()$0",
    "description": "(Server) Method: NextBot:GetSolidMask\n\nReturns the solid mask for given NextBot."
  },
  "NextBot:HandleStuck": {
    "prefix": "HandleStuck",
    "body": "HandleStuck()$0",
    "description": "(Server) Method: NextBot:HandleStuck\n\nCalled from Lua when the NPC is stuck. This should only be called from the behaviour coroutine - so if you want to override this function and do something special that yields - then go for it."
  },
  "NextBot:MoveToPos": {
    "prefix": "MoveToPos",
    "body": "MoveToPos(${1:Vector pos}, ${2:table options})$0",
    "description": "(Server) Method: NextBot:MoveToPos\n\nTo be called in the behaviour coroutine only! Will yield until the bot has reached the goal or is stuck"
  },
  "NextBot:PlaySequenceAndWait": {
    "prefix": "PlaySequenceAndWait",
    "body": "PlaySequenceAndWait(${1:string name}, ${2:number speed=1})$0",
    "description": "(Server) Method: NextBot:PlaySequenceAndWait\n\nTo be called in the behaviour coroutine only! Plays an animation sequence and waits for it to end before returning."
  },
  "NextBot:SetSolidMask": {
    "prefix": "SetSolidMask",
    "body": "SetSolidMask(${1:number mask})$0",
    "description": "(Server) Method: NextBot:SetSolidMask\n\nSets the solid mask for given NextBot."
  },
  "NextBot:StartActivity": {
    "prefix": "StartActivity",
    "body": "StartActivity(${1:number activity})$0",
    "description": "(Server) Method: NextBot:StartActivity\n\nStart doing an activity (animation)"
  },
  "NPC:AddEntityRelationship": {
    "prefix": "AddEntityRelationship",
    "body": "AddEntityRelationship(${1:Entity target}, ${2:number disposition}, ${3:number priority})$0",
    "description": "(Server) Method: NPC:AddEntityRelationship\n\nMakes the NPC like, hate, feel neutral towards, or fear the entity in question. If you want to setup relationship towards a certain entity ''class'', use NPC.AddRelationship."
  },
  "NPC:AddRelationship": {
    "prefix": "AddRelationship",
    "body": "AddRelationship(${1:string relationstring})$0",
    "description": "(Server) Method: NPC:AddRelationship\n\nChanges how an NPC feels towards another NPC.  If you want to setup relationship towards a certain ''entity'', use NPC.AddEntityRelationship."
  },
  "NPC:AlertSound": {
    "prefix": "AlertSound",
    "body": "AlertSound()$0",
    "description": "(Server) Method: NPC:AlertSound\n\nForce an NPC to play his Alert sound."
  },
  "NPC:CapabilitiesAdd": {
    "prefix": "CapabilitiesAdd",
    "body": "CapabilitiesAdd(${1:number capabilities})$0",
    "description": "(Server) Method: NPC:CapabilitiesAdd\n\nAdds a capability to the NPC."
  },
  "NPC:CapabilitiesClear": {
    "prefix": "CapabilitiesClear",
    "body": "CapabilitiesClear()$0",
    "description": "(Server) Method: NPC:CapabilitiesClear\n\nRemoves all of Capabilities the NPC has."
  },
  "NPC:CapabilitiesGet": {
    "prefix": "CapabilitiesGet",
    "body": "CapabilitiesGet()$0",
    "description": "(Server) Method: NPC:CapabilitiesGet\n\nReturns the NPC's capabilities along the ones defined on its weapon."
  },
  "NPC:CapabilitiesRemove": {
    "prefix": "CapabilitiesRemove",
    "body": "CapabilitiesRemove(${1:number capabilities})$0",
    "description": "(Server) Method: NPC:CapabilitiesRemove\n\nRemove a certain capability."
  },
  "NPC:Classify": {
    "prefix": "Classify",
    "body": "Classify()$0",
    "description": "(Server) Method: NPC:Classify\n\nReturns the NPC class. Do not confuse with Entity.GetClass!"
  },
  "NPC:ClearCondition": {
    "prefix": "ClearCondition",
    "body": "ClearCondition(${1:number condition})$0",
    "description": "(Server) Method: NPC:ClearCondition\n\nClears out the specified Enum.COND on this NPC."
  },
  "NPC:ClearEnemyMemory": {
    "prefix": "ClearEnemyMemory",
    "body": "ClearEnemyMemory()$0",
    "description": "(Server) Method: NPC:ClearEnemyMemory\n\nClears the Enemy from the NPC's memory, effectively forgetting it until met again with either the NPC vision or with NPC.UpdateEnemyMemory."
  },
  "NPC:ClearExpression": {
    "prefix": "ClearExpression",
    "body": "ClearExpression()$0",
    "description": "(Server) Method: NPC:ClearExpression\n\nClears the NPC's current expression which can be set with NPC.SetExpression."
  },
  "NPC:ClearGoal": {
    "prefix": "ClearGoal",
    "body": "ClearGoal()$0",
    "description": "(Server) Method: NPC:ClearGoal\n\n"
  },
  "NPC:ClearSchedule": {
    "prefix": "ClearSchedule",
    "body": "ClearSchedule()$0",
    "description": "(Server) Method: NPC:ClearSchedule\n\nStops the current schedule that the NPC is doing."
  },
  "NPC:ConditionName": {
    "prefix": "ConditionName",
    "body": "ConditionName(${1:number cond})$0",
    "description": "(Server) Method: NPC:ConditionName\n\nTranslates condition ID to a string."
  },
  "NPC:Disposition": {
    "prefix": "Disposition",
    "body": "Disposition(${1:Entity ent})$0",
    "description": "(Server) Method: NPC:Disposition\n\nReturns the way the NPC \"feels\" about the entity."
  },
  "NPC:ExitScriptedSequence": {
    "prefix": "ExitScriptedSequence",
    "body": "ExitScriptedSequence()$0",
    "description": "(Server) Method: NPC:ExitScriptedSequence\n\nMakes an NPC exit a scripted sequence, if one is playing."
  },
  "NPC:FearSound": {
    "prefix": "FearSound",
    "body": "FearSound()$0",
    "description": "(Server) Method: NPC:FearSound\n\nForce an NPC to play his Fear sound."
  },
  "NPC:FoundEnemySound": {
    "prefix": "FoundEnemySound",
    "body": "FoundEnemySound()$0",
    "description": "(Server) Method: NPC:FoundEnemySound\n\nForce an NPC to play its FoundEnemy sound."
  },
  "NPC:GetActiveWeapon": {
    "prefix": "GetActiveWeapon",
    "body": "GetActiveWeapon()$0",
    "description": "(Shared) Method: NPC:GetActiveWeapon\n\nReturns the weapon the NPC is currently carrying, or [http://wiki.garrysmod.com/page/Global_Variables NULL]."
  },
  "NPC:GetActivity": {
    "prefix": "GetActivity",
    "body": "GetActivity()$0",
    "description": "(Server) Method: NPC:GetActivity\n\nReturns the NPC's current activity."
  },
  "NPC:GetAimVector": {
    "prefix": "GetAimVector",
    "body": "GetAimVector()$0",
    "description": "(Server) Method: NPC:GetAimVector\n\nReturns the aim vector of the NPC. NPC alternative of Player.GetAimVector."
  },
  "NPC:GetArrivalActivity": {
    "prefix": "GetArrivalActivity",
    "body": "GetArrivalActivity()$0",
    "description": "(Server) Method: NPC:GetArrivalActivity\n\nReturns the activity to be played when the NPC arrives at its goal"
  },
  "NPC:GetArrivalSequence": {
    "prefix": "GetArrivalSequence",
    "body": "GetArrivalSequence()$0",
    "description": "(Server) Method: NPC:GetArrivalSequence\n\n"
  },
  "NPC:GetBlockingEntity": {
    "prefix": "GetBlockingEntity",
    "body": "GetBlockingEntity()$0",
    "description": "(Server) Method: NPC:GetBlockingEntity\n\n"
  },
  "NPC:GetCurrentWeaponProficiency": {
    "prefix": "GetCurrentWeaponProficiency",
    "body": "GetCurrentWeaponProficiency()$0",
    "description": "(Server) Method: NPC:GetCurrentWeaponProficiency\n\nReturns how proficient (skilled) an NPC is with its current weapon."
  },
  "NPC:GetEnemy": {
    "prefix": "GetEnemy",
    "body": "GetEnemy()$0",
    "description": "(Server) Method: NPC:GetEnemy\n\nReturns the entity that this NPC is trying to fight"
  },
  "NPC:GetExpression": {
    "prefix": "GetExpression",
    "body": "GetExpression()$0",
    "description": "(Server) Method: NPC:GetExpression\n\nReturns the expression file the NPC is currently playing."
  },
  "NPC:GetHullType": {
    "prefix": "GetHullType",
    "body": "GetHullType()$0",
    "description": "(Server) Method: NPC:GetHullType\n\nReturns NPCs hull type set by NPC.SetHullType."
  },
  "NPC:GetMovementActivity": {
    "prefix": "GetMovementActivity",
    "body": "GetMovementActivity()$0",
    "description": "(Server) Method: NPC:GetMovementActivity\n\nReturns the NPC's current movement activity."
  },
  "NPC:GetMovementSequence": {
    "prefix": "GetMovementSequence",
    "body": "GetMovementSequence()$0",
    "description": "(Server) Method: NPC:GetMovementSequence\n\nReturns the index of the sequence the NPC uses to move."
  },
  "NPC:GetNPCState": {
    "prefix": "GetNPCState",
    "body": "GetNPCState()$0",
    "description": "(Server) Method: NPC:GetNPCState\n\nReturns the NPC's state."
  },
  "NPC:GetPathDistanceToGoal": {
    "prefix": "GetPathDistanceToGoal",
    "body": "GetPathDistanceToGoal()$0",
    "description": "(Server) Method: NPC:GetPathDistanceToGoal\n\n"
  },
  "NPC:GetPathTimeToGoal": {
    "prefix": "GetPathTimeToGoal",
    "body": "GetPathTimeToGoal()$0",
    "description": "(Server) Method: NPC:GetPathTimeToGoal\n\n"
  },
  "NPC:GetShootPos": {
    "prefix": "GetShootPos",
    "body": "GetShootPos()$0",
    "description": "(Server) Method: NPC:GetShootPos\n\nReturns the shooting position of the NPC."
  },
  "NPC:GetTarget": {
    "prefix": "GetTarget",
    "body": "GetTarget()$0",
    "description": "(Server) Method: NPC:GetTarget\n\n"
  },
  "NPC:Give": {
    "prefix": "Give",
    "body": "Give(${1:string weapon})$0",
    "description": "(Server) Method: NPC:Give\n\nUsed to give a weapon to an already spawned NPC."
  },
  "NPC:HasCondition": {
    "prefix": "HasCondition",
    "body": "HasCondition(${1:number condition})$0",
    "description": "(Server) Method: NPC:HasCondition\n\nReturns whether or not the NPC has the given condition."
  },
  "NPC:IdleSound": {
    "prefix": "IdleSound",
    "body": "IdleSound()$0",
    "description": "(Server) Method: NPC:IdleSound\n\nForce an NPC to play his Idle sound."
  },
  "NPC:IsCurrentSchedule": {
    "prefix": "IsCurrentSchedule",
    "body": "IsCurrentSchedule(${1:number schedule})$0",
    "description": "(Server) Method: NPC:IsCurrentSchedule\n\nReturns whether or not the NPC is performing the given schedule."
  },
  "NPC:IsMoving": {
    "prefix": "IsMoving",
    "body": "IsMoving()$0",
    "description": "(Server) Method: NPC:IsMoving\n\nReturns whether the NPC is moving or not."
  },
  "NPC:IsRunningBehavior": {
    "prefix": "IsRunningBehavior",
    "body": "IsRunningBehavior()$0",
    "description": "(Server) Method: NPC:IsRunningBehavior\n\n"
  },
  "NPC:IsUnreachable": {
    "prefix": "IsUnreachable",
    "body": "IsUnreachable(${1:Entity testEntity})$0",
    "description": "(Server) Method: NPC:IsUnreachable\n\nReturns whether the entity given can be reached by this NPC."
  },
  "NPC:LostEnemySound": {
    "prefix": "LostEnemySound",
    "body": "LostEnemySound()$0",
    "description": "(Server) Method: NPC:LostEnemySound\n\nForce an NPC to play his LostEnemy sound."
  },
  "NPC:MaintainActivity": {
    "prefix": "MaintainActivity",
    "body": "MaintainActivity()$0",
    "description": "(Server) Method: NPC:MaintainActivity\n\n"
  },
  "NPC:MarkEnemyAsEluded": {
    "prefix": "MarkEnemyAsEluded",
    "body": "MarkEnemyAsEluded()$0",
    "description": "(Server) Method: NPC:MarkEnemyAsEluded\n\nCauses the NPC to temporarily forget the current enemy and switch on to a better one."
  },
  "NPC:MoveOrder": {
    "prefix": "MoveOrder",
    "body": "MoveOrder()$0",
    "description": "(Server) Method: NPC:MoveOrder\n\n"
  },
  "NPC:NavSetGoal": {
    "prefix": "NavSetGoal",
    "body": "NavSetGoal(${1:Vector position})$0",
    "description": "(Server) Method: NPC:NavSetGoal\n\n"
  },
  "NPC:NavSetGoalTarget": {
    "prefix": "NavSetGoalTarget",
    "body": "NavSetGoalTarget(${1:Entity target}, ${2:Vector offset})$0",
    "description": "(Server) Method: NPC:NavSetGoalTarget\n\nSet the goal target for an NPC."
  },
  "NPC:NavSetRandomGoal": {
    "prefix": "NavSetRandomGoal",
    "body": "NavSetRandomGoal(${1:number minPathLength}, ${2:Vector dir})$0",
    "description": "(Server) Method: NPC:NavSetRandomGoal\n\nCreates a random path of specified minimum length between a closest start node and random node in the specified direction."
  },
  "NPC:NavSetWanderGoal": {
    "prefix": "NavSetWanderGoal",
    "body": "NavSetWanderGoal(${1:number xoffset}, ${2:number yoffset})$0",
    "description": "(Server) Method: NPC:NavSetWanderGoal\n\nSets a goal in x, y offsets for the npc to wander to"
  },
  "NPC:PlaySentence": {
    "prefix": "PlaySentence",
    "body": "PlaySentence(${1:string sentence}, ${2:number delay}, ${3:number volume})$0",
    "description": "(Server) Method: NPC:PlaySentence\n\nForces the NPC to play a sentence from scripts/sentences.txt"
  },
  "NPC:RemoveMemory": {
    "prefix": "RemoveMemory",
    "body": "RemoveMemory()$0",
    "description": "(Server) Method: NPC:RemoveMemory\n\n"
  },
  "NPC:RunEngineTask": {
    "prefix": "RunEngineTask",
    "body": "RunEngineTask(${1:number taskID}, ${2:number taskData})$0",
    "description": "(Server) Method: NPC:RunEngineTask\n\n"
  },
  "NPC:SentenceStop": {
    "prefix": "SentenceStop",
    "body": "SentenceStop()$0",
    "description": "(Server) Method: NPC:SentenceStop\n\n"
  },
  "NPC:SetArrivalActivity": {
    "prefix": "SetArrivalActivity",
    "body": "SetArrivalActivity(${1:number act})$0",
    "description": "(Server) Method: NPC:SetArrivalActivity\n\n"
  },
  "NPC:SetArrivalDirection": {
    "prefix": "SetArrivalDirection",
    "body": "SetArrivalDirection()$0",
    "description": "(Server) Method: NPC:SetArrivalDirection\n\n"
  },
  "NPC:SetArrivalDistance": {
    "prefix": "SetArrivalDistance",
    "body": "SetArrivalDistance()$0",
    "description": "(Server) Method: NPC:SetArrivalDistance\n\n"
  },
  "NPC:SetArrivalSequence": {
    "prefix": "SetArrivalSequence",
    "body": "SetArrivalSequence()$0",
    "description": "(Server) Method: NPC:SetArrivalSequence\n\n"
  },
  "NPC:SetArrivalSpeed": {
    "prefix": "SetArrivalSpeed",
    "body": "SetArrivalSpeed()$0",
    "description": "(Server) Method: NPC:SetArrivalSpeed\n\n"
  },
  "NPC:SetCondition": {
    "prefix": "SetCondition",
    "body": "SetCondition(${1:number condition})$0",
    "description": "(Server) Method: NPC:SetCondition\n\nSets an NPC condition."
  },
  "NPC:SetCurrentWeaponProficiency": {
    "prefix": "SetCurrentWeaponProficiency",
    "body": "SetCurrentWeaponProficiency(${1:number proficiency})$0",
    "description": "(Server) Method: NPC:SetCurrentWeaponProficiency\n\nSets the weapon proficiency of an NPC (how skilled an NPC is with its current weapon)."
  },
  "NPC:SetEnemy": {
    "prefix": "SetEnemy",
    "body": "SetEnemy(${1:Entity enemy}, ${2:boolean newenemy=true})$0",
    "description": "(Server) Method: NPC:SetEnemy\n\nSets the target for an NPC."
  },
  "NPC:SetExpression": {
    "prefix": "SetExpression",
    "body": "SetExpression(${1:string expression})$0",
    "description": "(Server) Method: NPC:SetExpression\n\nSets the NPC's .vcd expression. Similar to Entity.PlayScene except the scene is looped until it's interrupted by default NPC behavior or NPC.ClearExpression."
  },
  "NPC:SetHullSizeNormal": {
    "prefix": "SetHullSizeNormal",
    "body": "SetHullSizeNormal()$0",
    "description": "(Server) Method: NPC:SetHullSizeNormal\n\nUpdates the NPC's hull and physics hull in order to match its model scale. Entity.SetModelScale seems to take care of this regardless."
  },
  "NPC:SetHullType": {
    "prefix": "SetHullType",
    "body": "SetHullType(${1:number hullType})$0",
    "description": "(Server) Method: NPC:SetHullType\n\nSets the hull type for the NPC."
  },
  "NPC:SetLastPosition": {
    "prefix": "SetLastPosition",
    "body": "SetLastPosition(${1:Vector Position})$0",
    "description": "(Server) Method: NPC:SetLastPosition\n\nSets the last registered or memorized position for an npc. When using scheduling, the NPC will focus on navigating to the last position via nodes."
  },
  "NPC:SetMaxRouteRebuildTime": {
    "prefix": "SetMaxRouteRebuildTime",
    "body": "SetMaxRouteRebuildTime()$0",
    "description": "(Server) Method: NPC:SetMaxRouteRebuildTime\n\n"
  },
  "NPC:SetMovementActivity": {
    "prefix": "SetMovementActivity",
    "body": "SetMovementActivity(${1:number activity})$0",
    "description": "(Server) Method: NPC:SetMovementActivity\n\nSets the activity the NPC uses when it moves."
  },
  "NPC:SetMovementSequence": {
    "prefix": "SetMovementSequence",
    "body": "SetMovementSequence(${1:number sequenceId})$0",
    "description": "(Server) Method: NPC:SetMovementSequence\n\nSets the sequence the NPC navigation path uses for speed calculation. Doesn't seem to have any visible effect on NPC movement."
  },
  "NPC:SetNPCState": {
    "prefix": "SetNPCState",
    "body": "SetNPCState(${1:number state})$0",
    "description": "(Server) Method: NPC:SetNPCState\n\nSets the state the NPC is in to help it decide on a ideal schedule."
  },
  "NPC:SetSchedule": {
    "prefix": "SetSchedule",
    "body": "SetSchedule(${1:number schedule})$0",
    "description": "(Server) Method: NPC:SetSchedule\n\nSets the NPC's current schedule."
  },
  "NPC:SetTarget": {
    "prefix": "SetTarget",
    "body": "SetTarget(${1:Player player})$0",
    "description": "(Server) Method: NPC:SetTarget\n\nSets the NPC's target to a player.(Used in some engine schedules)"
  },
  "NPC:StartEngineTask": {
    "prefix": "StartEngineTask",
    "body": "StartEngineTask(${1:number task}, ${2:number taskData})$0",
    "description": "(Server) Method: NPC:StartEngineTask\n\nForces the NPC to start an engine task, this has different results for every NPC."
  },
  "NPC:StopMoving": {
    "prefix": "StopMoving",
    "body": "StopMoving()$0",
    "description": "(Server) Method: NPC:StopMoving\n\nResets the NPC's movement animation and velocity. Does not actually stop the NPC from moving."
  },
  "NPC:TargetOrder": {
    "prefix": "TargetOrder",
    "body": "TargetOrder()$0",
    "description": "(Server) Method: NPC:TargetOrder\n\n"
  },
  "NPC:TaskComplete": {
    "prefix": "TaskComplete",
    "body": "TaskComplete()$0",
    "description": "(Server) Method: NPC:TaskComplete\n\n"
  },
  "NPC:TaskFail": {
    "prefix": "TaskFail",
    "body": "TaskFail(${1:string task})$0",
    "description": "(Server) Method: NPC:TaskFail\n\n"
  },
  "NPC:UpdateEnemyMemory": {
    "prefix": "UpdateEnemyMemory",
    "body": "UpdateEnemyMemory(${1:Entity enemy}, ${2:Vector pos})$0",
    "description": "(Server) Method: NPC:UpdateEnemyMemory\n\nForce the NPC to update information on the supplied enemy, as if it had line of sight to it."
  },
  "NPC:UseActBusyBehavior": {
    "prefix": "UseActBusyBehavior",
    "body": "UseActBusyBehavior()$0",
    "description": "(Server) Method: NPC:UseActBusyBehavior\n\n"
  },
  "NPC:UseAssaultBehavior": {
    "prefix": "UseAssaultBehavior",
    "body": "UseAssaultBehavior()$0",
    "description": "(Server) Method: NPC:UseAssaultBehavior\n\n"
  },
  "NPC:UseFollowBehavior": {
    "prefix": "UseFollowBehavior",
    "body": "UseFollowBehavior()$0",
    "description": "(Server) Method: NPC:UseFollowBehavior\n\n"
  },
  "NPC:UseFuncTankBehavior": {
    "prefix": "UseFuncTankBehavior",
    "body": "UseFuncTankBehavior()$0",
    "description": "(Server) Method: NPC:UseFuncTankBehavior\n\n"
  },
  "NPC:UseLeadBehavior": {
    "prefix": "UseLeadBehavior",
    "body": "UseLeadBehavior()$0",
    "description": "(Server) Method: NPC:UseLeadBehavior\n\n"
  },
  "NPC:UseNoBehavior": {
    "prefix": "UseNoBehavior",
    "body": "UseNoBehavior()$0",
    "description": "(Server) Method: NPC:UseNoBehavior\n\n"
  },
  "Panel:Add": {
    "prefix": "Add",
    "body": "Add(${1:Panel object})$0",
    "description": "(Client) Method: Panel:Add\n\nAdds the specified object to the panel."
  },
  "Panel:AddText": {
    "prefix": "AddText",
    "body": "AddText()$0",
    "description": "(Client) Method: Panel:AddText\n\n[Deprecated] .Does nothing"
  },
  "Panel:AlignBottom": {
    "prefix": "AlignBottom",
    "body": "AlignBottom(${1:number offset=0})$0",
    "description": "(Client) Method: Panel:AlignBottom\n\nAligns the panel on the bottom of its parent with the specified offset."
  },
  "Panel:AlignLeft": {
    "prefix": "AlignLeft",
    "body": "AlignLeft(${1:number offset=0})$0",
    "description": "(Client) Method: Panel:AlignLeft\n\nAligns the panel on the left of its parent with the specified offset."
  },
  "Panel:AlignRight": {
    "prefix": "AlignRight",
    "body": "AlignRight(${1:number offset=0})$0",
    "description": "(Client) Method: Panel:AlignRight\n\nAligns the panel on the right of its parent with the specified offset."
  },
  "Panel:AlignTop": {
    "prefix": "AlignTop",
    "body": "AlignTop(${1:number offset=0})$0",
    "description": "(Client) Method: Panel:AlignTop\n\nAligns the panel on the top of its parent with the specified offset."
  },
  "Panel:AlphaTo": {
    "prefix": "AlphaTo",
    "body": "AlphaTo(${1:number alpha}, ${2:number duration}, ${3:number delay=0}, ${4:function callback})$0",
    "description": "(Client) Method: Panel:AlphaTo\n\nUses animation to transition the current alpha value of a panel to a new alpha, over a set period of time and after a specified delay."
  },
  "Panel:AnimationThinkInternal": {
    "prefix": "AnimationThinkInternal",
    "body": "AnimationThinkInternal()$0",
    "description": "(Client) Method: Panel:AnimationThinkInternal\n\n[Internal]  Performs the per-frame operations required for panel animations."
  },
  "Panel:AnimTail": {
    "prefix": "AnimTail",
    "body": "AnimTail()$0",
    "description": "(Client) Method: Panel:AnimTail\n\nReturns the _G.SysTime value when all animations for this panel object will end."
  },
  "Panel:AppendText": {
    "prefix": "AppendText",
    "body": "AppendText(${1:string txt})$0",
    "description": "(Client) Method: Panel:AppendText\n\nAppends text to a RichText element. This does not automatically add a new line."
  },
  "Panel:ApplyGWEN": {
    "prefix": "ApplyGWEN",
    "body": "ApplyGWEN(${1:table GWENTable})$0",
    "description": "(Client) Method: Panel:ApplyGWEN\n\nUsed by Panel.LoadGWENFile and Panel.LoadGWENString to apply a GWEN controls table to a panel object."
  },
  "Panel:Center": {
    "prefix": "Center",
    "body": "Center()$0",
    "description": "(Client) Method: Panel:Center\n\nCenters the panel on its parent."
  },
  "Panel:CenterHorizontal": {
    "prefix": "CenterHorizontal",
    "body": "CenterHorizontal(${1:number fraction=0.5})$0",
    "description": "(Client) Method: Panel:CenterHorizontal\n\nCenters the panel horizontally with specified fraction."
  },
  "Panel:CenterVertical": {
    "prefix": "CenterVertical",
    "body": "CenterVertical(${1:number fraction=0.5})$0",
    "description": "(Client) Method: Panel:CenterVertical\n\nCenters the panel vertically with specified fraction."
  },
  "Panel:ChildCount": {
    "prefix": "ChildCount",
    "body": "ChildCount()$0",
    "description": "(Client) Method: Panel:ChildCount\n\nReturns the amount of children of the of panel."
  },
  "Panel:ChildrenSize": {
    "prefix": "ChildrenSize",
    "body": "ChildrenSize()$0",
    "description": "(Client) Method: Panel:ChildrenSize\n\nReturns the width and height of the space between the position of the panel (upper-left corner) and the max bound of the children panels (farthest reaching lower-right corner)."
  },
  "Panel:Clear": {
    "prefix": "Clear",
    "body": "Clear()$0",
    "description": "(Client) Method: Panel:Clear\n\nMarks all of the panel's children for deletion."
  },
  "Panel:ColorTo": {
    "prefix": "ColorTo",
    "body": "ColorTo(${1:table color}, ${2:number length}, ${3:number delay}, ${4:function callback})$0",
    "description": "(Client) Method: Panel:ColorTo\n\nFades panels color to specified one. It won't work unless panel has SetColor function."
  },
  "Panel:Command": {
    "prefix": "Command",
    "body": "Command(${1:string command})$0",
    "description": "(Client) Method: Panel:Command\n\nSends an action command signal to the panel. The response is handled by PANEL.ActionSignal."
  },
  "Panel:ConVarChanged": {
    "prefix": "ConVarChanged",
    "body": "ConVarChanged(${1:string newValue})$0",
    "description": "(Client) Method: Panel:ConVarChanged\n\nUpdates a panel object's associated console variable. This must first be set up with _G.Derma_Install_Convar_Functions, and have a ConVar set using Panel.SetConVar."
  },
  "Panel:ConVarNumberThink": {
    "prefix": "ConVarNumberThink",
    "body": "ConVarNumberThink()$0",
    "description": "(Client) Method: Panel:ConVarNumberThink\n\nA think hook for [[Panel.panels]] using ConVars as a value. Call it in the Think hook. Sets the panel's value should the convar change."
  },
  "Panel:ConVarStringThink": {
    "prefix": "ConVarStringThink",
    "body": "ConVarStringThink()$0",
    "description": "(Client) Method: Panel:ConVarStringThink\n\nA think hook for [[Panel.panels]] using ConVars as a value. Call it in the Think hook. Sets the panel's value should the convar change."
  },
  "Panel:CopyBase": {
    "prefix": "CopyBase",
    "body": "CopyBase(${1:Panel srcPanel})$0",
    "description": "(Client) Method: Panel:CopyBase\n\nGets the size, position and dock state of the passed panel object, and applies it to this one."
  },
  "Panel:CopyBounds": {
    "prefix": "CopyBounds",
    "body": "CopyBounds(${1:Panel base})$0",
    "description": "(Client) Method: Panel:CopyBounds\n\nCopies position and size of the panel."
  },
  "Panel:CopyHeight": {
    "prefix": "CopyHeight",
    "body": "CopyHeight(${1:Panel base})$0",
    "description": "(Client) Method: Panel:CopyHeight\n\nCopies the height of the panel."
  },
  "Panel:CopyPos": {
    "prefix": "CopyPos",
    "body": "CopyPos(${1:Panel base})$0",
    "description": "(Client) Method: Panel:CopyPos\n\nCopies the position of the panel."
  },
  "Panel:CopySelected": {
    "prefix": "CopySelected",
    "body": "CopySelected()$0",
    "description": "(Client) Method: Panel:CopySelected\n\nPerforms the \"CONTROL   C\" key combination effect ( Copy selection to clipboard ) on selected text."
  },
  "Panel:CopyWidth": {
    "prefix": "CopyWidth",
    "body": "CopyWidth(${1:Panel base})$0",
    "description": "(Client) Method: Panel:CopyWidth\n\nCopies the width of the panel."
  },
  "Panel:CursorPos": {
    "prefix": "CursorPos",
    "body": "CursorPos()$0",
    "description": "(Client) Method: Panel:CursorPos\n\nReturns the cursor position relative to the top left of the panel."
  },
  "Panel:CutSelected": {
    "prefix": "CutSelected",
    "body": "CutSelected()$0",
    "description": "(Client) Method: Panel:CutSelected\n\nPerforms the \"CONTROL   X\" ( delete text and copy it to clipboard buffer ) action on selected text."
  },
  "Panel:DeleteCookie": {
    "prefix": "DeleteCookie",
    "body": "DeleteCookie(${1:string cookieName})$0",
    "description": "(Client) Method: Panel:DeleteCookie\n\nDeletes a cookie value using the panel's cookie name ( Panel.GetCookieName ) and the passed extension."
  },
  "Panel:DisableLerp": {
    "prefix": "DisableLerp",
    "body": "DisableLerp()$0",
    "description": "(Client) Method: Panel:DisableLerp\n\nResets the panel object's Panel.SetPos method and removes its animation table (''Panel.LerpAnim''). This effectively undoes the changes made by Panel.LerpPositions."
  },
  "Panel:Distance": {
    "prefix": "Distance",
    "body": "Distance(${1:Panel tgtPanel})$0",
    "description": "(Client) Method: Panel:Distance\n\nReturns the linear distance from the centre of this panel object and another."
  },
  "Panel:DistanceFrom": {
    "prefix": "DistanceFrom",
    "body": "DistanceFrom(${1:number posX}, ${2:number posY})$0",
    "description": "(Client) Method: Panel:DistanceFrom\n\nReturns the distance between the centre of this panel object and a specified point (local to the parent panel)."
  },
  "Panel:Dock": {
    "prefix": "Dock",
    "body": "Dock(${1:number dockType})$0",
    "description": "(Client) Method: Panel:Dock\n\nSets the dock type of the panel."
  },
  "Panel:DockMargin": {
    "prefix": "DockMargin",
    "body": "DockMargin(${1:number marginLeft}, ${2:number marginTop}, ${3:number marginRight}, ${4:number marginBottom})$0",
    "description": "(Client) Method: Panel:DockMargin\n\nSets the dock margin of the panel."
  },
  "Panel:DockPadding": {
    "prefix": "DockPadding",
    "body": "DockPadding(${1:number paddingLeft}, ${2:number paddingTop}, ${3:number paddingRight}, ${4:number paddingBottom})$0",
    "description": "(Client) Method: Panel:DockPadding\n\nSets the dock padding of the panel."
  },
  "Panel:DoModal": {
    "prefix": "DoModal",
    "body": "DoModal(${1:boolean doModal})$0",
    "description": "(Client) Method: Panel:DoModal\n\nMakes the panel \"lock\" the screen until it is removed."
  },
  "Panel:DragClick": {
    "prefix": "DragClick",
    "body": "DragClick()$0",
    "description": "(Client) Method: Panel:DragClick\n\n[Internal]  Called by Panel.DragMouseRelease when a user clicks one mouse button whilst dragging with another."
  },
  "Panel:DragHover": {
    "prefix": "DragHover",
    "body": "DragHover(${1:number HoverTime})$0",
    "description": "(Client) Method: Panel:DragHover\n\n[Internal]  Called by dragndrop.HoverThink to perform actions on an object that is dragged and hovered over another."
  },
  "Panel:DragHoverClick": {
    "prefix": "DragHoverClick",
    "body": "DragHoverClick(${1:number hoverTime})$0",
    "description": "(Client) Method: Panel:DragHoverClick\n\nCalled when an object is dragged and hovered over this panel for 0.1 seconds. This is used by DPropertySheet and Type.DTree, for example to expand the tree when an object is hovered over it."
  },
  "Panel:DragHoverEnd": {
    "prefix": "DragHoverEnd",
    "body": "DragHoverEnd()$0",
    "description": "(Client) Method: Panel:DragHoverEnd\n\n[Internal]  Called to end a drag and hover action. This resets the panel's PANEL.PaintOver method, and is primarily used by dragndrop.StopDragging."
  },
  "Panel:DragMousePress": {
    "prefix": "DragMousePress",
    "body": "DragMousePress(${1:number mouseCode})$0",
    "description": "(Client) Method: Panel:DragMousePress\n\nCalled to inform the dragndrop that a mouse button is being held down on a panel object."
  },
  "Panel:DragMouseRelease": {
    "prefix": "DragMouseRelease",
    "body": "DragMouseRelease(${1:number mouseCode})$0",
    "description": "(Client) Method: Panel:DragMouseRelease\n\nCalled to inform the dragndrop that a mouse button has been depressed on a panel object."
  },
  "Panel:DrawDragHover": {
    "prefix": "DrawDragHover",
    "body": "DrawDragHover(${1:number x}, ${2:number y}, ${3:number width}, ${4:number height})$0",
    "description": "(Client) Method: Panel:DrawDragHover\n\n[Internal]  Called to draw the drop target when an object is being dragged across another. See Panel.SetDropTarget."
  },
  "Panel:DrawFilledRect": {
    "prefix": "DrawFilledRect",
    "body": "DrawFilledRect()$0",
    "description": "(Client) Method: Panel:DrawFilledRect\n\nDraws a coloured rectangle to fill the panel object this method is called on. The colour is set using surface.SetDrawColor. This should only be called within the object's PANEL.Paint or PANEL.PaintOver hooks, as a shortcut for surface.DrawRect."
  },
  "Panel:DrawOutlinedRect": {
    "prefix": "DrawOutlinedRect",
    "body": "DrawOutlinedRect()$0",
    "description": "(Client) Method: Panel:DrawOutlinedRect\n\nDraws a hollow rectangle the size of the panel object this method is called on, with a border width of 1 px. The border colour is set using surface.SetDrawColor. This should only be called within the object's PANEL.Paint or PANEL.PaintOver hooks, as a shortcut for surface.DrawOutlinedRect."
  },
  "Panel:DrawSelections": {
    "prefix": "DrawSelections",
    "body": "DrawSelections()$0",
    "description": "(Client) Method: Panel:DrawSelections\n\nUsed to draw the magenta highlight colour of a panel object when it is selected. This should be called in the object's PANEL.PaintOver hook. Once this is implemented, the highlight colour will be displayed only when the object is selectable and selected. This is achieved using Panel.SetSelectable and Panel.SetSelected respectively."
  },
  "Panel:DrawTextEntryText": {
    "prefix": "DrawTextEntryText",
    "body": "DrawTextEntryText(${1:table textCol}, ${2:table highlightCol}, ${3:table cursorCol})$0",
    "description": "(Client) Method: Panel:DrawTextEntryText\n\nUsed to draw the text in a DTextEntry within a derma skin. This should be called within the SKIN.PaintTextEntry skin hook."
  },
  "Panel:DrawTexturedRect": {
    "prefix": "DrawTexturedRect",
    "body": "DrawTexturedRect()$0",
    "description": "(Client) Method: Panel:DrawTexturedRect\n\nDraws a textured rectangle to fill the panel object this method is called on. The texture is set using surface.SetTexture or surface.SetMaterial. This should only be called within the object's PANEL.Paint or PANEL.PaintOver hooks, as a shortcut for surface.DrawTexturedRect."
  },
  "Panel:Droppable": {
    "prefix": "Droppable",
    "body": "Droppable(${1:string name})$0",
    "description": "(Client) Method: Panel:Droppable\n\nMakes this panel droppable. This is used with Panel.Receiver to create drag and drop events."
  },
  "Panel:DroppedOn": {
    "prefix": "DroppedOn",
    "body": "DroppedOn(${1:Panel pnl})$0",
    "description": "(Client) Method: Panel:DroppedOn\n\nFor override. Called when this panel is dropped onto other panel."
  },
  "Panel:EndBoxSelection": {
    "prefix": "EndBoxSelection",
    "body": "EndBoxSelection()$0",
    "description": "(Client) Method: Panel:EndBoxSelection\n\nCompletes a box selection. If the end point of the selection box is within the selection canvas, mouse capture is disabled for the panel object, and the selected state of each child object within the selection box is toggled."
  },
  "Panel:Exec": {
    "prefix": "Exec",
    "body": "Exec(${1:string cmd})$0",
    "description": "(Client) Method: Panel:Exec\n\n[Internal]  Used to run commands within a DHTML window."
  },
  "Panel:Find": {
    "prefix": "Find",
    "body": "Find(${1:string panelName})$0",
    "description": "(Client) Method: Panel:Find\n\nFinds a panel in its children(and sub children) with the given name."
  },
  "Panel:FocusNext": {
    "prefix": "FocusNext",
    "body": "FocusNext()$0",
    "description": "(Client) Method: Panel:FocusNext\n\nFocuses the next panel in the focus queue."
  },
  "Panel:FocusPrevious": {
    "prefix": "FocusPrevious",
    "body": "FocusPrevious()$0",
    "description": "(Client) Method: Panel:FocusPrevious\n\nFocuses the previous panel in the focus queue."
  },
  "Panel:GetAlpha": {
    "prefix": "GetAlpha",
    "body": "GetAlpha()$0",
    "description": "(Client) Method: Panel:GetAlpha\n\nReturns the alpha multiplier for this panel."
  },
  "Panel:GetBounds": {
    "prefix": "GetBounds",
    "body": "GetBounds()$0",
    "description": "(Client) Method: Panel:GetBounds\n\nReturns the position and size of the panel."
  },
  "Panel:GetCaretPos": {
    "prefix": "GetCaretPos",
    "body": "GetCaretPos()$0",
    "description": "(Client) Method: Panel:GetCaretPos\n\nReturns the position/offset of the caret (or text cursor) in a text-based panel object."
  },
  "Panel:GetChild": {
    "prefix": "GetChild",
    "body": "GetChild(${1:number childIndex})$0",
    "description": "(Client) Method: Panel:GetChild\n\nGets a child by its index."
  },
  "Panel:GetChildPosition": {
    "prefix": "GetChildPosition",
    "body": "GetChildPosition(${1:Panel pnl})$0",
    "description": "(Client) Method: Panel:GetChildPosition\n\nGets a child object's position relative to this panel object. The number of levels is not relevant; the child may have many parents between itself and the object on which the method is called."
  },
  "Panel:GetChildren": {
    "prefix": "GetChildren",
    "body": "GetChildren()$0",
    "description": "(Client) Method: Panel:GetChildren\n\nReturns a table with all the child panels of the panel."
  },
  "Panel:GetChildrenInRect": {
    "prefix": "GetChildrenInRect",
    "body": "GetChildrenInRect(${1:number x}, ${2:number y}, ${3:number w}, ${4:number h})$0",
    "description": "(Client) Method: Panel:GetChildrenInRect\n\nReturns a table of all visible, selectable children of the panel object that lie at least partially within the specified rectangle."
  },
  "Panel:GetClassName": {
    "prefix": "GetClassName",
    "body": "GetClassName()$0",
    "description": "(Client) Method: Panel:GetClassName\n\nReturns the class name of the panel."
  },
  "Panel:GetClosestChild": {
    "prefix": "GetClosestChild",
    "body": "GetClosestChild(${1:number x}, ${2:number y})$0",
    "description": "(Client) Method: Panel:GetClosestChild\n\nReturns the child of this panel object that is closest to the specified point. The point is relative to the object on which the method is called. The distance the child is from this point is also returned."
  },
  "Panel:GetContentSize": {
    "prefix": "GetContentSize",
    "body": "GetContentSize()$0",
    "description": "(Client) Method: Panel:GetContentSize\n\nGets the size of the content/children within a panel object."
  },
  "Panel:GetCookie": {
    "prefix": "GetCookie",
    "body": "GetCookie(${1:string cookieName}, ${2:string default})$0",
    "description": "(Client) Method: Panel:GetCookie\n\nGets the value of a cookie stored by the panel object. This can also be done with cookie.GetString, using the panel's cookie name, a fullstop, and then the actual name of the cookie."
  },
  "Panel:GetCookieName": {
    "prefix": "GetCookieName",
    "body": "GetCookieName()$0",
    "description": "(Client) Method: Panel:GetCookieName\n\nGets the name the panel uses to store cookies. This is set with Panel.SetCookieName."
  },
  "Panel:GetCookieNumber": {
    "prefix": "GetCookieNumber",
    "body": "GetCookieNumber(${1:string cookieName}, ${2:number default})$0",
    "description": "(Client) Method: Panel:GetCookieNumber\n\nGets the value of a cookie stored by the panel object, as a number. This can also be done with cookie.GetNumber, using the panel's cookie name, a fullstop, and then the actual name of the cookie."
  },
  "Panel:GetDock": {
    "prefix": "GetDock",
    "body": "GetDock()$0",
    "description": "(Client) Method: Panel:GetDock\n\nReturns a dock enum for the panel's current docking type."
  },
  "Panel:GetDockMargin": {
    "prefix": "GetDockMargin",
    "body": "GetDockMargin()$0",
    "description": "(Client) Method: Panel:GetDockMargin\n\nReturns the docked margins of the panel. (set by Panel.DockMargin)"
  },
  "Panel:GetDockPadding": {
    "prefix": "GetDockPadding",
    "body": "GetDockPadding()$0",
    "description": "(Client) Method: Panel:GetDockPadding\n\nReturns the docked padding of the panel. (set by Panel.DockPadding)"
  },
  "Panel:GetFont": {
    "prefix": "GetFont",
    "body": "GetFont()$0",
    "description": "(Client) Method: Panel:GetFont\n\nReturns the name of the font that the panel renders its text with."
  },
  "Panel:GetHTMLMaterial": {
    "prefix": "GetHTMLMaterial",
    "body": "GetHTMLMaterial()$0",
    "description": "(Client) Method: Panel:GetHTMLMaterial\n\nReturns the panel's HTML material. Only works with Awesomium, Type.HTML and Type.DHTML panels that have been fully loaded."
  },
  "Panel:GetName": {
    "prefix": "GetName",
    "body": "GetName()$0",
    "description": "(Client) Method: Panel:GetName\n\nReturns the internal name of the panel."
  },
  "Panel:GetNumLines": {
    "prefix": "GetNumLines",
    "body": "GetNumLines()$0",
    "description": "(Client) Method: Panel:GetNumLines\n\nReturns the number of lines in a RichText. You must wait a couple frames before calling this after using Panel.AppendText or Panel.SetText, otherwise it will return the number of text lines before the text change."
  },
  "Panel:GetParent": {
    "prefix": "GetParent",
    "body": "GetParent()$0",
    "description": "(Client) Method: Panel:GetParent\n\nReturns the parent of the panel, returns nil if there is no parent."
  },
  "Panel:GetPos": {
    "prefix": "GetPos",
    "body": "GetPos()$0",
    "description": "(Client) Method: Panel:GetPos\n\nReturns the position of the panel relative to its Panel.GetParent."
  },
  "Panel:GetSelectedChildren": {
    "prefix": "GetSelectedChildren",
    "body": "GetSelectedChildren()$0",
    "description": "(Client) Method: Panel:GetSelectedChildren\n\nReturns a table of all children of the panel object that are selected. This is recursive, and the returned table will include tables for any child objects that also have children. This means that not all first-level members in the returned table will be of type Panel."
  },
  "Panel:GetSelectionCanvas": {
    "prefix": "GetSelectionCanvas",
    "body": "GetSelectionCanvas()$0",
    "description": "(Client) Method: Panel:GetSelectionCanvas\n\nReturns the panel object (''self'') if it has been enabled as a selection canvas. This is achieved using Panel.SetSelectionCanvas."
  },
  "Panel:GetSize": {
    "prefix": "GetSize",
    "body": "GetSize()$0",
    "description": "(Client) Method: Panel:GetSize\n\nReturns the size of the panel."
  },
  "Panel:GetSkin": {
    "prefix": "GetSkin",
    "body": "GetSkin()$0",
    "description": "(Client) Method: Panel:GetSkin\n\nReturns the table for the derma skin currently being used by this panel object."
  },
  "Panel:GetTable": {
    "prefix": "GetTable",
    "body": "GetTable()$0",
    "description": "(Client) Method: Panel:GetTable\n\nReturns the internal Lua table of the panel."
  },
  "Panel:GetTall": {
    "prefix": "GetTall",
    "body": "GetTall()$0",
    "description": "(Client) Method: Panel:GetTall\n\nReturns the height of the panel."
  },
  "Panel:GetText": {
    "prefix": "GetText",
    "body": "GetText()$0",
    "description": "(Client) Method: Panel:GetText\n\nReturns the panel's text (where applicable)."
  },
  "Panel:GetTextInset": {
    "prefix": "GetTextInset",
    "body": "GetTextInset()$0",
    "description": "(Client) Method: Panel:GetTextInset\n\nGets the left and top text margins of a text-based panel object, such as a DButton or Type.DLabel. This is set with Panel.SetTextInset."
  },
  "Panel:GetTextSize": {
    "prefix": "GetTextSize",
    "body": "GetTextSize()$0",
    "description": "(Client) Method: Panel:GetTextSize\n\nGets the size of the text within a Label derived panel."
  },
  "Panel:GetValidReceiverSlot": {
    "prefix": "GetValidReceiverSlot",
    "body": "GetValidReceiverSlot()$0",
    "description": "(Client) Method: Panel:GetValidReceiverSlot\n\nGets valid receiver slot of currently dragged panel."
  },
  "Panel:GetValue": {
    "prefix": "GetValue",
    "body": "GetValue()$0",
    "description": "(Client) Method: Panel:GetValue\n\nReturns the value the panel holds."
  },
  "Panel:GetWide": {
    "prefix": "GetWide",
    "body": "GetWide()$0",
    "description": "(Client) Method: Panel:GetWide\n\nReturns the width of the panel."
  },
  "Panel:GetZPos": {
    "prefix": "GetZPos",
    "body": "GetZPos()$0",
    "description": "(Client) Method: Panel:GetZPos\n\nReturns the Z position of the panel."
  },
  "Panel:GoBack": {
    "prefix": "GoBack",
    "body": "GoBack()$0",
    "description": "(Client) Method: Panel:GoBack\n\nGoes back one page in the HTML panel's history if available."
  },
  "Panel:GoForward": {
    "prefix": "GoForward",
    "body": "GoForward()$0",
    "description": "(Client) Method: Panel:GoForward\n\nGoes forward one page in the HTML panel's history if available."
  },
  "Panel:GoToHistoryOffset": {
    "prefix": "GoToHistoryOffset",
    "body": "GoToHistoryOffset(${1:number offset})$0",
    "description": "(Client) Method: Panel:GoToHistoryOffset\n\nGoes to the page in the HTML panel's history at the specified relative offset."
  },
  "Panel:GotoTextEnd": {
    "prefix": "GotoTextEnd",
    "body": "GotoTextEnd()$0",
    "description": "(Client) Method: Panel:GotoTextEnd\n\nCauses a RichText element to scroll to the bottom of its text."
  },
  "Panel:GotoTextStart": {
    "prefix": "GotoTextStart",
    "body": "GotoTextStart()$0",
    "description": "(Client) Method: Panel:GotoTextStart\n\nCauses a RichText element to scroll to the top of its text."
  },
  "Panel:GWEN_SetCheckboxText": {
    "prefix": "GWEN_SetCheckboxText",
    "body": "GWEN_SetCheckboxText(${1:string txt})$0",
    "description": "(Client) Method: Panel:GWEN_SetCheckboxText\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''CheckboxText'' property to a DCheckBoxLabel. This does exactly the same as Panel.GWEN_SetText, but exists to cater for the seperate GWEN properties."
  },
  "Panel:GWEN_SetControlName": {
    "prefix": "GWEN_SetControlName",
    "body": "GWEN_SetControlName(${1:string name})$0",
    "description": "(Client) Method: Panel:GWEN_SetControlName\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''ControlName'' property to a panel. This calls Panel.SetName."
  },
  "Panel:GWEN_SetDock": {
    "prefix": "GWEN_SetDock",
    "body": "GWEN_SetDock(${1:string dockState})$0",
    "description": "(Client) Method: Panel:GWEN_SetDock\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''Dock'' property to a  panel object. This calls Panel.Dock."
  },
  "Panel:GWEN_SetHorizontalAlign": {
    "prefix": "GWEN_SetHorizontalAlign",
    "body": "GWEN_SetHorizontalAlign(${1:string hAlign})$0",
    "description": "(Client) Method: Panel:GWEN_SetHorizontalAlign\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''HorizontalAlign'' property to a  panel object. This calls Panel.SetContentAlignment."
  },
  "Panel:GWEN_SetMargin": {
    "prefix": "GWEN_SetMargin",
    "body": "GWEN_SetMargin(${1:table margins})$0",
    "description": "(Client) Method: Panel:GWEN_SetMargin\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''Margin'' property to a  panel object. This calls Panel.DockMargin."
  },
  "Panel:GWEN_SetMax": {
    "prefix": "GWEN_SetMax",
    "body": "GWEN_SetMax(${1:number maxValue})$0",
    "description": "(Client) Method: Panel:GWEN_SetMax\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''Max'' property to a  DNumberWang, Type.Slider, Type.DNumSlider or Type.DNumberScratch. This calls ''SetMax'' on one of the previously listed methods."
  },
  "Panel:GWEN_SetMin": {
    "prefix": "GWEN_SetMin",
    "body": "GWEN_SetMin(${1:number minValue})$0",
    "description": "(Client) Method: Panel:GWEN_SetMin\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''Min'' property to a  DNumberWang, Type.Slider, Type.DNumSlider or Type.DNumberScratch. This calls ''SetMin'' on one of the previously listed methods."
  },
  "Panel:GWEN_SetPosition": {
    "prefix": "GWEN_SetPosition",
    "body": "GWEN_SetPosition(${1:table pos})$0",
    "description": "(Client) Method: Panel:GWEN_SetPosition\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''Position'' property to a  panel object. This calls Panel.SetPos."
  },
  "Panel:GWEN_SetSize": {
    "prefix": "GWEN_SetSize",
    "body": "GWEN_SetSize(${1:table size})$0",
    "description": "(Client) Method: Panel:GWEN_SetSize\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''Size'' property to a  panel object. This calls Panel.SetSize."
  },
  "Panel:GWEN_SetText": {
    "prefix": "GWEN_SetText",
    "body": "GWEN_SetText(${1:string txt})$0",
    "description": "(Client) Method: Panel:GWEN_SetText\n\n[Internal]  Used by Panel.ApplyGWEN to apply the ''Text'' property to a panel."
  },
  "Panel:HasChildren": {
    "prefix": "HasChildren",
    "body": "HasChildren()$0",
    "description": "(Client) Method: Panel:HasChildren\n\nReturns whenever the panel has child panels."
  },
  "Panel:HasFocus": {
    "prefix": "HasFocus",
    "body": "HasFocus()$0",
    "description": "(Client) Method: Panel:HasFocus\n\nReturns if the panel is focused."
  },
  "Panel:HasHierarchicalFocus": {
    "prefix": "HasHierarchicalFocus",
    "body": "HasHierarchicalFocus()$0",
    "description": "(Client) Method: Panel:HasHierarchicalFocus\n\nReturns if the panel or any of its children(sub children and so on) has the focus."
  },
  "Panel:HasParent": {
    "prefix": "HasParent",
    "body": "HasParent(${1:Panel parentPanel})$0",
    "description": "(Client) Method: Panel:HasParent\n\nReturns whether the panel is a descendent of the given panel."
  },
  "Panel:Hide": {
    "prefix": "Hide",
    "body": "Hide()$0",
    "description": "(Client) Method: Panel:Hide\n\nMakes a panel invisible."
  },
  "Panel:InsertClickableTextEnd": {
    "prefix": "InsertClickableTextEnd",
    "body": "InsertClickableTextEnd()$0",
    "description": "(Client) Method: Panel:InsertClickableTextEnd\n\nMarks the end of a clickable text segment in a RichText element, started with Panel.InsertClickableTextStart."
  },
  "Panel:InsertClickableTextStart": {
    "prefix": "InsertClickableTextStart",
    "body": "InsertClickableTextStart(${1:string signalValue})$0",
    "description": "(Client) Method: Panel:InsertClickableTextStart\n\nStarts the insertion of clickable text for a RichText element. Any text appended with Panel.AppendText between this call and Panel.InsertClickableTextEnd will become clickable text."
  },
  "Panel:InsertColorChange": {
    "prefix": "InsertColorChange",
    "body": "InsertColorChange(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a})$0",
    "description": "(Client) Method: Panel:InsertColorChange\n\nInserts a color change in a RichText element, which affects the color of all text added with Panel.AppendText until another color change is applied."
  },
  "Panel:InsertFade": {
    "prefix": "InsertFade",
    "body": "InsertFade(${1:number sustain}, ${2:number length})$0",
    "description": "(Client) Method: Panel:InsertFade\n\nBegins a text fade for a RichText element where the last appended text segment is fully faded out after a specific amount of time, at a specific speed."
  },
  "Panel:InvalidateChildren": {
    "prefix": "InvalidateChildren",
    "body": "InvalidateChildren(${1:boolean recursive=false})$0",
    "description": "(Client) Method: Panel:InvalidateChildren\n\nInvalidates the layout of this panel object and all its children. This will cause these objects to re-layout immediately, calling PANEL.PerformLayout. If you want to perform the layout in the next frame, you will have loop manually through all children, and call Panel.InvalidateLayout on each."
  },
  "Panel:InvalidateLayout": {
    "prefix": "InvalidateLayout",
    "body": "InvalidateLayout(${1:boolean layoutNow=false})$0",
    "description": "(Client) Method: Panel:InvalidateLayout\n\nCauses the panel to re-layout in the next frame. During the layout process  PANEL.PerformLayout will be called on the target panel."
  },
  "Panel:InvalidateParent": {
    "prefix": "InvalidateParent",
    "body": "InvalidateParent(${1:boolean layoutNow=false})$0",
    "description": "(Client) Method: Panel:InvalidateParent\n\nInvalidates the layout of the parent of this panel object. This will cause it to re-layout, calling PANEL.PerformLayout."
  },
  "Panel:IsChildHovered": {
    "prefix": "IsChildHovered",
    "body": "IsChildHovered(${1:boolean immediate=false})$0",
    "description": "(Client) Method: Panel:IsChildHovered\n\nDetermines whether the mouse cursor is hovered over one of this panel object's children. This is a reverse process using vgui.GetHoveredPanel, and looks upward to find the parent."
  },
  "Panel:IsDraggable": {
    "prefix": "IsDraggable",
    "body": "IsDraggable()$0",
    "description": "(Client) Method: Panel:IsDraggable\n\nReturns whether this panel is draggable ( if user is able to drag it ) or not."
  },
  "Panel:IsDragging": {
    "prefix": "IsDragging",
    "body": "IsDragging()$0",
    "description": "(Client) Method: Panel:IsDragging\n\nReturns whether this panel is currently being dragged or not."
  },
  "Panel:IsEnabled": {
    "prefix": "IsEnabled",
    "body": "IsEnabled()$0",
    "description": "(Client) Method: Panel:IsEnabled\n\nReturns whether the the panel is enabled or disabled."
  },
  "Panel:IsHovered": {
    "prefix": "IsHovered",
    "body": "IsHovered()$0",
    "description": "(Client) Method: Panel:IsHovered\n\nReturns whether the mouse cursor is hovering over this panel or not"
  },
  "Panel:IsKeyboardInputEnabled": {
    "prefix": "IsKeyboardInputEnabled",
    "body": "IsKeyboardInputEnabled()$0",
    "description": "(Client) Method: Panel:IsKeyboardInputEnabled\n\nReturns true if the panel can receive keyboard input."
  },
  "Panel:IsLoading": {
    "prefix": "IsLoading",
    "body": "IsLoading()$0",
    "description": "(Client) Method: Panel:IsLoading\n\nDetermines whether or not a HTML or Type.DHTML element is currently loading a page."
  },
  "Panel:IsMarkedForDeletion": {
    "prefix": "IsMarkedForDeletion",
    "body": "IsMarkedForDeletion()$0",
    "description": "(Client) Method: Panel:IsMarkedForDeletion\n\nReturns if the panel is going to be deleted in the next frame."
  },
  "Panel:IsMouseInputEnabled": {
    "prefix": "IsMouseInputEnabled",
    "body": "IsMouseInputEnabled()$0",
    "description": "(Client) Method: Panel:IsMouseInputEnabled\n\nReturns true if the panel can receive mouse input."
  },
  "Panel:IsMultiline": {
    "prefix": "IsMultiline",
    "body": "IsMultiline()$0",
    "description": "(Client) Method: Panel:IsMultiline\n\nDetermines whether or not a text-based panel object, such as a DTextEntry, is in multi-line mode. This is set with Panel.SetMultiline."
  },
  "Panel:IsOurChild": {
    "prefix": "IsOurChild",
    "body": "IsOurChild(${1:Panel childPanel})$0",
    "description": "(Client) Method: Panel:IsOurChild\n\nReturns whether the panel contains the given panel, recursively."
  },
  "Panel:IsSelectable": {
    "prefix": "IsSelectable",
    "body": "IsSelectable()$0",
    "description": "(Client) Method: Panel:IsSelectable\n\nDetermines if the panel object is selectable (like icons in the Spawn Menu, holding Key.Shift). This is set with Panel.SetSelectable."
  },
  "Panel:IsSelected": {
    "prefix": "IsSelected",
    "body": "IsSelected()$0",
    "description": "(Client) Method: Panel:IsSelected\n\nReturns if the panel object is selected (like icons in the Spawn Menu, holding Key.Shift). This can be set in Lua using Panel.SetSelected. "
  },
  "Panel:IsSelectionCanvas": {
    "prefix": "IsSelectionCanvas",
    "body": "IsSelectionCanvas()$0",
    "description": "(Client) Method: Panel:IsSelectionCanvas\n\nDetermines if the panel object is a selection canvas or not. This is set with Panel.SetSelectionCanvas."
  },
  "Panel:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Client) Method: Panel:IsValid\n\nReturns if the panel is valid and not marked for deletion."
  },
  "Panel:IsVisible": {
    "prefix": "IsVisible",
    "body": "IsVisible()$0",
    "description": "(Client) Method: Panel:IsVisible\n\nReturns if the panel is visible."
  },
  "Panel:KillFocus": {
    "prefix": "KillFocus",
    "body": "KillFocus()$0",
    "description": "(Client) Method: Panel:KillFocus\n\nRemove the focus from the panel."
  },
  "Panel:LerpPositions": {
    "prefix": "LerpPositions",
    "body": "LerpPositions(${1:number speed}, ${2:boolean easeOut})$0",
    "description": "(Client) Method: Panel:LerpPositions\n\nRedefines the panel object's Panel.SetPos method to operate using frame-by-frame linear interpolation (Lerp). When the panel's position is changed, it will move to the target position at the speed defined. You can undo this with Panel.DisableLerp."
  },
  "Panel:LoadControlsFromFile": {
    "prefix": "LoadControlsFromFile",
    "body": "LoadControlsFromFile(${1:string path})$0",
    "description": "(Client) Method: Panel:LoadControlsFromFile\n\n[Deprecated] "
  },
  "Panel:LoadControlsFromString": {
    "prefix": "LoadControlsFromString",
    "body": "LoadControlsFromString(${1:string data})$0",
    "description": "(Client) Method: Panel:LoadControlsFromString\n\n[Deprecated] "
  },
  "Panel:LoadGWENFile": {
    "prefix": "LoadGWENFile",
    "body": "LoadGWENFile(${1:string filename}, ${2:string path=\"GAME\"})$0",
    "description": "(Client) Method: Panel:LoadGWENFile\n\nLoads a .gwen file (created by GWEN Designer) and calls Panel.LoadGWENString with the contents of the loaded file."
  },
  "Panel:LoadGWENString": {
    "prefix": "LoadGWENString",
    "body": "LoadGWENString(${1:string str})$0",
    "description": "(Client) Method: Panel:LoadGWENString\n\nLoads controls for the panel from a JSON string."
  },
  "Panel:LoadTGAImage": {
    "prefix": "LoadTGAImage",
    "body": "LoadTGAImage(${1:string imageName}, ${2:string strPath})$0",
    "description": "(Client) Method: Panel:LoadTGAImage\n\nSets a new image to be loaded by a TGAImage."
  },
  "Panel:LocalCursorPos": {
    "prefix": "LocalCursorPos",
    "body": "LocalCursorPos()$0",
    "description": "(Client) Method: Panel:LocalCursorPos\n\nReturns the cursor position local to the position of the panel (usually the upper-left corner)."
  },
  "Panel:LocalToScreen": {
    "prefix": "LocalToScreen",
    "body": "LocalToScreen(${1:number posX}, ${2:number posY})$0",
    "description": "(Client) Method: Panel:LocalToScreen\n\nGets the absolute screen position of the position specified relative to the panel."
  },
  "Panel:MakePopup": {
    "prefix": "MakePopup",
    "body": "MakePopup()$0",
    "description": "(Client) Method: Panel:MakePopup\n\nFocuses the panel and enables it to receive input."
  },
  "Panel:MouseCapture": {
    "prefix": "MouseCapture",
    "body": "MouseCapture(${1:boolean doCapture})$0",
    "description": "(Client) Method: Panel:MouseCapture\n\nAllows the panel to receive mouse input even if the mouse cursor is outside the bounds of the panel."
  },
  "Panel:MoveAbove": {
    "prefix": "MoveAbove",
    "body": "MoveAbove(${1:Panel panel}, ${2:number offset=0})$0",
    "description": "(Client) Method: Panel:MoveAbove\n\nPlaces the panel above the passed panel with the specified offset."
  },
  "Panel:MoveBelow": {
    "prefix": "MoveBelow",
    "body": "MoveBelow(${1:Panel panel}, ${2:number offset=0})$0",
    "description": "(Client) Method: Panel:MoveBelow\n\nPlaces the panel below the passed panel with the specified offset."
  },
  "Panel:MoveBy": {
    "prefix": "MoveBy",
    "body": "MoveBy(${1:number moveX}, ${2:number moveY}, ${3:number time}, ${4:number delay=0}, ${5:number ease=-1}, ${6:function callback})$0",
    "description": "(Client) Method: Panel:MoveBy\n\nMoves the panel by the specified coordinates using animation."
  },
  "Panel:MoveLeftOf": {
    "prefix": "MoveLeftOf",
    "body": "MoveLeftOf(${1:Panel panel}, ${2:number offset=0})$0",
    "description": "(Client) Method: Panel:MoveLeftOf\n\nPlaces the panel left to the passed panel with the specified offset."
  },
  "Panel:MoveRightOf": {
    "prefix": "MoveRightOf",
    "body": "MoveRightOf(${1:Panel panel}, ${2:number offset=0})$0",
    "description": "(Client) Method: Panel:MoveRightOf\n\nPlaces the panel right to the passed panel with the specified offset."
  },
  "Panel:MoveTo": {
    "prefix": "MoveTo",
    "body": "MoveTo(${1:number posX}, ${2:number posY}, ${3:number time}, ${4:number delay=0}, ${5:number ease=-1}, ${6:function callback})$0",
    "description": "(Client) Method: Panel:MoveTo\n\nMoves the panel to the specified position using animation."
  },
  "Panel:MoveToAfter": {
    "prefix": "MoveToAfter",
    "body": "MoveToAfter(${1:Panel siblingPanel})$0",
    "description": "(Client) Method: Panel:MoveToAfter\n\nMoves this panel object in front of the specified sibling (child of the same parent) in the render order, and shuffles up the Z-positions of siblings now behind."
  },
  "Panel:MoveToBack": {
    "prefix": "MoveToBack",
    "body": "MoveToBack()$0",
    "description": "(Client) Method: Panel:MoveToBack\n\nMoves the panel object behind all other panels on screen. If the panel has been made a pop-up with Panel.MakePopup, it will still draw in front of any panels that haven't."
  },
  "Panel:MoveToBefore": {
    "prefix": "MoveToBefore",
    "body": "MoveToBefore(${1:Panel siblingPanel})$0",
    "description": "(Client) Method: Panel:MoveToBefore\n\nMoves this panel object behind the specified sibling (child of the same parent) in the render order, and shuffles up the Z-positions of siblings now in front."
  },
  "Panel:MoveToFront": {
    "prefix": "MoveToFront",
    "body": "MoveToFront()$0",
    "description": "(Client) Method: Panel:MoveToFront\n\nMoves the panel in front of all other panels on screen. Unless the panel has been made a pop-up using Panel.MakePopup, it will still draw behind any that have."
  },
  "Panel:NewAnimation": {
    "prefix": "NewAnimation",
    "body": "NewAnimation(${1:number length}, ${2:number delay=0}, ${3:number ease=-1}, ${4:function callback=nil})$0",
    "description": "(Client) Method: Panel:NewAnimation\n\nCreates a new animation for the panel object."
  },
  "Panel:NewObject": {
    "prefix": "NewObject",
    "body": "NewObject(${1:string })$0",
    "description": "(Client) Method: Panel:NewObject\n\n[Internal] "
  },
  "Panel:NewObjectCallback": {
    "prefix": "NewObjectCallback",
    "body": "NewObjectCallback(${1:string }, ${2:string })$0",
    "description": "(Client) Method: Panel:NewObjectCallback\n\n[Internal] "
  },
  "Panel:NoClipping": {
    "prefix": "NoClipping",
    "body": "NoClipping(${1:boolean clip})$0",
    "description": "(Client) Method: Panel:NoClipping\n\nSets whether this panel's drawings should be clipped within the parent panel's bounds."
  },
  "Panel:NumSelectedChildren": {
    "prefix": "NumSelectedChildren",
    "body": "NumSelectedChildren()$0",
    "description": "(Client) Method: Panel:NumSelectedChildren\n\nReturns the number of children of the panel object that are selected. This is equivalent to calling Panel.IsSelected on all child objects and counting the number of returns that are ''true''."
  },
  "Panel:OpenURL": {
    "prefix": "OpenURL",
    "body": "OpenURL(${1:string URL})$0",
    "description": "(Client) Method: Panel:OpenURL\n\n[[Category:HTML]][[Category:Awesomium]]Instructs a HTML control to download and parse a HTML script using the passed URL."
  },
  "Panel:PaintAt": {
    "prefix": "PaintAt",
    "body": "PaintAt(${1:number posX}, ${2:number posY})$0",
    "description": "(Client) Method: Panel:PaintAt\n\nPaints a ghost copy of the panel at the given position."
  },
  "Panel:PaintManual": {
    "prefix": "PaintManual",
    "body": "PaintManual()$0",
    "description": "(Client) Method: Panel:PaintManual\n\nPaints the panel at its current position. To use this you must call Panel.SetPaintedManually(true)."
  },
  "Panel:ParentToHUD": {
    "prefix": "ParentToHUD",
    "body": "ParentToHUD()$0",
    "description": "(Client) Method: Panel:ParentToHUD\n\nParents the panel to the HUD."
  },
  "Panel:Paste": {
    "prefix": "Paste",
    "body": "Paste()$0",
    "description": "(Client) Method: Panel:Paste\n\nWarning.Due to privacy concerns, this function has been disabled"
  },
  "Panel:PositionLabel": {
    "prefix": "PositionLabel",
    "body": "PositionLabel(${1:number lblWidth}, ${2:number x}, ${3:number y}, ${4:Panel lbl}, ${5:Panel panelObj})$0",
    "description": "(Client) Method: Panel:PositionLabel\n\nSets the width and position of a DLabel and places the passed panel object directly to the right of it. Returns the ''y'' value of the bottom of the tallest object. The panel on which this method is run is not relevant; only the passed objects are affected."
  },
  "Panel:PostMessage": {
    "prefix": "PostMessage",
    "body": "PostMessage(${1:string messageName}, ${2:string valueType}, ${3:string value})$0",
    "description": "(Client) Method: Panel:PostMessage\n\n[Deprecated] .Only used in deprecated Derma controls.Sends a command to the panel."
  },
  "Panel:Prepare": {
    "prefix": "Prepare",
    "body": "Prepare()$0",
    "description": "(Client) Method: Panel:Prepare\n\n[Internal] "
  },
  "Panel:Queue": {
    "prefix": "Queue",
    "body": "Queue()$0",
    "description": "(Client) Method: Panel:Queue\n\nEnables the queue for panel animations. If enabled, the next new animation will begin after all current animations have ended. This must be called before Panel.NewAnimation to work, and only applies to the next new animation. If you want to queue many, you must call this before each."
  },
  "Panel:RebuildSpawnIcon": {
    "prefix": "RebuildSpawnIcon",
    "body": "RebuildSpawnIcon()$0",
    "description": "(Client) Method: Panel:RebuildSpawnIcon\n\nCauses a SpawnIcon to rebuild its model image."
  },
  "Panel:RebuildSpawnIconEx": {
    "prefix": "RebuildSpawnIconEx",
    "body": "RebuildSpawnIconEx(${1:table data})$0",
    "description": "(Client) Method: Panel:RebuildSpawnIconEx\n\nRe-renders a spawn icon with customized cam data."
  },
  "Panel:Receiver": {
    "prefix": "Receiver",
    "body": "Receiver(${1:string name}, ${2:function func}, ${3:table menu})$0",
    "description": "(Client) Method: Panel:Receiver\n\nAllows the panel to receive drag and drop events."
  },
  "Panel:Refresh": {
    "prefix": "Refresh",
    "body": "Refresh(${1:boolean ignoreCache=false})$0",
    "description": "(Client) Method: Panel:Refresh\n\nRefreshes the HTML panel's current page."
  },
  "Panel:Remove": {
    "prefix": "Remove",
    "body": "Remove()$0",
    "description": "(Client) Method: Panel:Remove\n\nMarks a panel for deletion so it will be deleted on the next frame."
  },
  "Panel:RequestFocus": {
    "prefix": "RequestFocus",
    "body": "RequestFocus()$0",
    "description": "(Client) Method: Panel:RequestFocus\n\nAttempts to obtain focus for this panel."
  },
  "Panel:ResetAllFades": {
    "prefix": "ResetAllFades",
    "body": "ResetAllFades(${1:boolean hold}, ${2:boolean expiredOnly}, ${3:number newSustain})$0",
    "description": "(Client) Method: Panel:ResetAllFades\n\nResets all text fades in a RichText element made with Panel.InsertFade."
  },
  "Panel:RunJavascript": {
    "prefix": "RunJavascript",
    "body": "RunJavascript(${1:string js})$0",
    "description": "(Client) Method: Panel:RunJavascript\n\nRuns/Executes a string as JavaScript code in [[:Category:DHTML.DHTML]] panel."
  },
  "Panel:SaveUndoState": {
    "prefix": "SaveUndoState",
    "body": "SaveUndoState()$0",
    "description": "(Client) Method: Panel:SaveUndoState\n\nSaves the current state (caret position and the text inside) of a TextEntry as an undo state."
  },
  "Panel:ScreenToLocal": {
    "prefix": "ScreenToLocal",
    "body": "ScreenToLocal(${1:number screenX}, ${2:number screenY})$0",
    "description": "(Client) Method: Panel:ScreenToLocal\n\nTranslates global screen coordinate to coordinates relative to the panel."
  },
  "Panel:SelectAll": {
    "prefix": "SelectAll",
    "body": "SelectAll()$0",
    "description": "(Client) Method: Panel:SelectAll\n\nSelects all items within a panel or object. For text-based objects, selects all text."
  },
  "Panel:SelectAllOnFocus": {
    "prefix": "SelectAllOnFocus",
    "body": "SelectAllOnFocus()$0",
    "description": "(Client) Method: Panel:SelectAllOnFocus\n\nIf called on a text entry, clicking the text entry for the first time will automatically select all of the text ready to be copied by the user."
  },
  "Panel:SelectAllText": {
    "prefix": "SelectAllText",
    "body": "SelectAllText()$0",
    "description": "(Client) Method: Panel:SelectAllText\n\nSelects all the text in a panel object. Will not select non-text items; for this, use Panel.SelectAll."
  },
  "Panel:SelectNone": {
    "prefix": "SelectNone",
    "body": "SelectNone()$0",
    "description": "(Client) Method: Panel:SelectNone\n\nDeselects all items in a panel object. For text-based objects, this will deselect all text."
  },
  "Panel:SetAchievement": {
    "prefix": "SetAchievement",
    "body": "SetAchievement(${1:number id})$0",
    "description": "(Client) Method: Panel:SetAchievement\n\nSets the achievement to be displayed by AchievementIcon.[[Category:AchievementIcon]]"
  },
  "Panel:SetActionFunction": {
    "prefix": "SetActionFunction",
    "body": "SetActionFunction(${1:function func})$0",
    "description": "(Client) Method: Panel:SetActionFunction\n\n[Deprecated] .Only used in deprecated Derma controls."
  },
  "Panel:SetAllowNonAsciiCharacters": {
    "prefix": "SetAllowNonAsciiCharacters",
    "body": "SetAllowNonAsciiCharacters(${1:boolean allowed})$0",
    "description": "(Client) Method: Panel:SetAllowNonAsciiCharacters\n\nConfigures a text input to allow user to type characters that are not included in the US-ASCII (7-bit ASCII) character set."
  },
  "Panel:SetAlpha": {
    "prefix": "SetAlpha",
    "body": "SetAlpha(${1:number alpha})$0",
    "description": "(Client) Method: Panel:SetAlpha\n\nSets the alpha multiplier for the panel"
  },
  "Panel:SetAnimationEnabled": {
    "prefix": "SetAnimationEnabled",
    "body": "SetAnimationEnabled(${1:boolean enable})$0",
    "description": "(Client) Method: Panel:SetAnimationEnabled\n\nEnables or disables animations for the panel object by overriding the PANEL.AnimationThink hook to nil and back."
  },
  "Panel:SetAutoDelete": {
    "prefix": "SetAutoDelete",
    "body": "SetAutoDelete(${1:boolean autoDelete})$0",
    "description": "(Client) Method: Panel:SetAutoDelete\n\nSets whenever the panel should be removed if the parent was removed."
  },
  "Panel:SetBGColor": {
    "prefix": "SetBGColor",
    "body": "SetBGColor(${1:number r or color}, ${2:number g}, ${3:number b}, ${4:number a})$0",
    "description": "(Client) Method: Panel:SetBGColor\n\nSets the background color of a panel such as a RichText, Type.Label or Type.DColorCube."
  },
  "Panel:SetBGColorEx": {
    "prefix": "SetBGColorEx",
    "body": "SetBGColorEx(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a})$0",
    "description": "(Client) Method: Panel:SetBGColorEx\n\n[Internal] Sets the background color of the panel."
  },
  "Panel:SetCaretPos": {
    "prefix": "SetCaretPos",
    "body": "SetCaretPos(${1:number offset})$0",
    "description": "(Client) Method: Panel:SetCaretPos\n\nSets the position of the caret (or text cursor) in a text-based panel object. "
  },
  "Panel:SetCommand": {
    "prefix": "SetCommand",
    "body": "SetCommand()$0",
    "description": "(Client) Method: Panel:SetCommand\n\nSets the action signal command that's fired when a Button is clicked. The hook PANEL.ActionSignal is called as the click response."
  },
  "Panel:SetContentAlignment": {
    "prefix": "SetContentAlignment",
    "body": "SetContentAlignment(${1:number alignment})$0",
    "description": "(Client) Method: Panel:SetContentAlignment\n\nSets the alignment of the contents."
  },
  "Panel:SetConVar": {
    "prefix": "SetConVar",
    "body": "SetConVar(${1:string convar})$0",
    "description": "(Client) Method: Panel:SetConVar\n\nSets this panel's convar. When the convar changes this panel will update automatically."
  },
  "Panel:SetCookie": {
    "prefix": "SetCookie",
    "body": "SetCookie(${1:string cookieName}, ${2:string value})$0",
    "description": "(Client) Method: Panel:SetCookie\n\nStores a string in the named cookie using Panel.GetCookieName as prefix."
  },
  "Panel:SetCookieName": {
    "prefix": "SetCookieName",
    "body": "SetCookieName(${1:string name})$0",
    "description": "(Client) Method: Panel:SetCookieName\n\nSets the panel's cookie name. Calls PANEL.LoadCookies if defined."
  },
  "Panel:SetCursor": {
    "prefix": "SetCursor",
    "body": "SetCursor(${1:string cursor})$0",
    "description": "(Client) Method: Panel:SetCursor\n\nSets the appearance of the cursor."
  },
  "Panel:SetDragParent": {
    "prefix": "SetDragParent",
    "body": "SetDragParent(${1:Panel parent})$0",
    "description": "(Client) Method: Panel:SetDragParent\n\nSets the drag parent."
  },
  "Panel:SetDrawLanguageID": {
    "prefix": "SetDrawLanguageID",
    "body": "SetDrawLanguageID(${1:boolean visible})$0",
    "description": "(Client) Method: Panel:SetDrawLanguageID\n\nSets the visibility of the language selection box in a TextEntry when typing in non-English mode."
  },
  "Panel:SetDrawLanguageIDAtLeft": {
    "prefix": "SetDrawLanguageIDAtLeft",
    "body": "SetDrawLanguageIDAtLeft(${1:boolean left})$0",
    "description": "(Client) Method: Panel:SetDrawLanguageIDAtLeft\n\nSets where to draw the language selection box."
  },
  "Panel:SetDrawOnTop": {
    "prefix": "SetDrawOnTop",
    "body": "SetDrawOnTop(${1:boolean drawOnTop=false})$0",
    "description": "(Client) Method: Panel:SetDrawOnTop\n\nMakes the panel render in front of all others, including the spawn menu and main menu."
  },
  "Panel:SetDropTarget": {
    "prefix": "SetDropTarget",
    "body": "SetDropTarget(${1:number x}, ${2:number y}, ${3:number width}, ${4:number height})$0",
    "description": "(Client) Method: Panel:SetDropTarget\n\nSets the target area for dropping when an object is being dragged around this panel using the dragndrop. "
  },
  "Panel:SetEnabled": {
    "prefix": "SetEnabled",
    "body": "SetEnabled(${1:boolean enable})$0",
    "description": "(Client) Method: Panel:SetEnabled\n\nSets the enabled state of a disable-able panel object, such as a DButton or Type.DTextEntry."
  },
  "Panel:SetExpensiveShadow": {
    "prefix": "SetExpensiveShadow",
    "body": "SetExpensiveShadow(${1:number distance}, ${2:table Color})$0",
    "description": "(Client) Method: Panel:SetExpensiveShadow\n\nAdds a shadow falling to the bottom right corner of the panel's text. This has no effect on panels that do not derive from Label."
  },
  "Panel:SetFGColor": {
    "prefix": "SetFGColor",
    "body": "SetFGColor(${1:number r or color}, ${2:number g}, ${3:number b}, ${4:number a})$0",
    "description": "(Client) Method: Panel:SetFGColor\n\nSets the foreground color of a panel."
  },
  "Panel:SetFGColorEx": {
    "prefix": "SetFGColorEx",
    "body": "SetFGColorEx(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a})$0",
    "description": "(Client) Method: Panel:SetFGColorEx\n\n[Internal] Sets the foreground color of the panel."
  },
  "Panel:SetFocusTopLevel": {
    "prefix": "SetFocusTopLevel",
    "body": "SetFocusTopLevel(${1:boolean state})$0",
    "description": "(Client) Method: Panel:SetFocusTopLevel\n\nStub"
  },
  "Panel:SetFontInternal": {
    "prefix": "SetFontInternal",
    "body": "SetFontInternal(${1:string fontName})$0",
    "description": "(Client) Method: Panel:SetFontInternal\n\nSets the font used to render this panel's text."
  },
  "Panel:SetHeight": {
    "prefix": "SetHeight",
    "body": "SetHeight(${1:number height})$0",
    "description": "(Client) Method: Panel:SetHeight\n\nSets the height of the panel."
  },
  "Panel:SetHTML": {
    "prefix": "SetHTML",
    "body": "SetHTML(${1:string HTML code})$0",
    "description": "(Client) Method: Panel:SetHTML\n\n[[Category:HTML]][[Category:Awesomium]]Allows you to set HTML code within a panel."
  },
  "Panel:SetKeyBoardInputEnabled": {
    "prefix": "SetKeyBoardInputEnabled",
    "body": "SetKeyBoardInputEnabled(${1:boolean keyboardInput})$0",
    "description": "(Client) Method: Panel:SetKeyBoardInputEnabled\n\n[Deprecated] .Alias of Panel.SetKeyboardInputEnabledEnables or disables the keyboard input for the panel."
  },
  "Panel:SetKeyboardInputEnabled": {
    "prefix": "SetKeyboardInputEnabled",
    "body": "SetKeyboardInputEnabled(${1:boolean enable})$0",
    "description": "(Client) Method: Panel:SetKeyboardInputEnabled\n\nAllows or disallows the panel to receive keyboard focus and input. This is recursively applied to all children."
  },
  "Panel:SetMinimumSize": {
    "prefix": "SetMinimumSize",
    "body": "SetMinimumSize(${1:number minW=nil}, ${2:number minH=nil})$0",
    "description": "(Client) Method: Panel:SetMinimumSize\n\nSets the minimum dimensions of the panel or object."
  },
  "Panel:SetModel": {
    "prefix": "SetModel",
    "body": "SetModel(${1:string ModelPath}, ${2:number skin=0}, ${3:string bodygroups=\"\"})$0",
    "description": "(Client) Method: Panel:SetModel\n\n[[Category:ModelImage]][[Category:SpawnIcon]]Sets the model to be displayed by SpawnIcon.[[Category:SpawnIcon]]"
  },
  "Panel:SetMouseInputEnabled": {
    "prefix": "SetMouseInputEnabled",
    "body": "SetMouseInputEnabled(${1:boolean mouseInput})$0",
    "description": "(Client) Method: Panel:SetMouseInputEnabled\n\nEnables or disables the mouse input for the panel."
  },
  "Panel:SetMultiline": {
    "prefix": "SetMultiline",
    "body": "SetMultiline(${1:boolean multiline})$0",
    "description": "(Client) Method: Panel:SetMultiline\n\nEnables or disables the multi-line functionality of a text object, such as a DTextEntry."
  },
  "Panel:SetName": {
    "prefix": "SetName",
    "body": "SetName(${1:string name})$0",
    "description": "(Client) Method: Panel:SetName\n\nSets the internal name of the panel."
  },
  "Panel:SetPaintBackgroundEnabled": {
    "prefix": "SetPaintBackgroundEnabled",
    "body": "SetPaintBackgroundEnabled(${1:boolean paintBackground})$0",
    "description": "(Client) Method: Panel:SetPaintBackgroundEnabled\n\nSets whenever all the default background of the panel should be drawn or not."
  },
  "Panel:SetPaintBorderEnabled": {
    "prefix": "SetPaintBorderEnabled",
    "body": "SetPaintBorderEnabled(${1:boolean paintBorder})$0",
    "description": "(Client) Method: Panel:SetPaintBorderEnabled\n\nSets whenever all the default border of the panel should be drawn or not."
  },
  "Panel:SetPaintedManually": {
    "prefix": "SetPaintedManually",
    "body": "SetPaintedManually(${1:boolean paintedManually})$0",
    "description": "(Client) Method: Panel:SetPaintedManually\n\nEnables or disables painting of the panel manually with Panel.PaintManual."
  },
  "Panel:SetPaintFunction": {
    "prefix": "SetPaintFunction",
    "body": "SetPaintFunction()$0",
    "description": "(Client) Method: Panel:SetPaintFunction\n\n[Deprecated] .This function does nothing."
  },
  "Panel:SetParent": {
    "prefix": "SetParent",
    "body": "SetParent(${1:Panel parent})$0",
    "description": "(Client) Method: Panel:SetParent\n\nSets the parent of the panel."
  },
  "Panel:SetPlayer": {
    "prefix": "SetPlayer",
    "body": "SetPlayer(${1:Player player}, ${2:number size})$0",
    "description": "(Client) Method: Panel:SetPlayer\n\nUsed by AvatarImage to load an avatar for given player.[[Category:AvatarImage]]"
  },
  "Panel:SetPopupStayAtBack": {
    "prefix": "SetPopupStayAtBack",
    "body": "SetPopupStayAtBack(${1:boolean stayAtBack})$0",
    "description": "(Client) Method: Panel:SetPopupStayAtBack\n\nIf this panel object has been made a popup with Panel.MakePopup, this method will prevent it from drawing in front of other panels when it receives input focus."
  },
  "Panel:SetPos": {
    "prefix": "SetPos",
    "body": "SetPos(${1:number posX}, ${2:number posY})$0",
    "description": "(Client) Method: Panel:SetPos\n\nSets the position of the panel."
  },
  "Panel:SetRenderInScreenshots": {
    "prefix": "SetRenderInScreenshots",
    "body": "SetRenderInScreenshots(${1:boolean renderInScreenshot})$0",
    "description": "(Client) Method: Panel:SetRenderInScreenshots\n\nSets whenever the panel should be rendered in the next screenshot."
  },
  "Panel:SetSelectable": {
    "prefix": "SetSelectable",
    "body": "SetSelectable(${1:boolean selectable})$0",
    "description": "(Client) Method: Panel:SetSelectable\n\nSets whether the panel object can be selected or not (like icons in the Spawn Menu, holding Key.Shift). If enabled, this will affect the function of a DButton whilst Key.Shift is pressed. Panel.SetSelected can be used to select/deselect the object."
  },
  "Panel:SetSelected": {
    "prefix": "SetSelected",
    "body": "SetSelected(${1:boolean selected=false})$0",
    "description": "(Client) Method: Panel:SetSelected\n\nSets the selected state of a selectable panel object. This functionality is set with Panel.SetSelectable and checked with Panel.IsSelectable."
  },
  "Panel:SetSelectionCanvas": {
    "prefix": "SetSelectionCanvas",
    "body": "SetSelectionCanvas(${1:any selCanvas})$0",
    "description": "(Client) Method: Panel:SetSelectionCanvas\n\nEnables the panel object for selection (much like the spawn menu). "
  },
  "Panel:SetSize": {
    "prefix": "SetSize",
    "body": "SetSize(${1:number width}, ${2:number height})$0",
    "description": "(Client) Method: Panel:SetSize\n\nSets the size of the panel."
  },
  "Panel:SetSkin": {
    "prefix": "SetSkin",
    "body": "SetSkin(${1:string skinName})$0",
    "description": "(Client) Method: Panel:SetSkin\n\nSets the derma skin that the panel object will use, and refreshes all panels with derma.RefreshSkins."
  },
  "Panel:SetSpawnIcon": {
    "prefix": "SetSpawnIcon",
    "body": "SetSpawnIcon(${1:string icon})$0",
    "description": "(Client) Method: Panel:SetSpawnIcon\n\n[[Category:ModelImage]][[Category:SpawnIcon]]Sets the [[Silkicons.silkicon]] of a panel object such as a SpawnIcon and Type.ModelImage."
  },
  "Panel:SetSteamID": {
    "prefix": "SetSteamID",
    "body": "SetSteamID(${1:string steamid}, ${2:number size})$0",
    "description": "(Client) Method: Panel:SetSteamID\n\nUsed by AvatarImage panels to load an avatar by its 64-bit Steam ID (community ID).[[Category:AvatarImage]]"
  },
  "Panel:SetTabPosition": {
    "prefix": "SetTabPosition",
    "body": "SetTabPosition(${1:number })$0",
    "description": "(Client) Method: Panel:SetTabPosition\n\nStub"
  },
  "Panel:SetTall": {
    "prefix": "SetTall",
    "body": "SetTall(${1:number height})$0",
    "description": "(Client) Method: Panel:SetTall\n\nSets height of a panel. An alias of Panel.SetHeight."
  },
  "Panel:SetTerm": {
    "prefix": "SetTerm",
    "body": "SetTerm(${1:number delay})$0",
    "description": "(Client) Method: Panel:SetTerm\n\nRemoves the panel after given time in seconds."
  },
  "Panel:SetText": {
    "prefix": "SetText",
    "body": "SetText(${1:string text})$0",
    "description": "(Client) Method: Panel:SetText\n\nSets the text value of a panel object containing text, such as a Label, Type.TextEntry or  Type.RichText and their derivatives, such as Type.DLabel, Type.DTextEntry or Type.DButton."
  },
  "Panel:SetTextInset": {
    "prefix": "SetTextInset",
    "body": "SetTextInset(${1:number insetX}, ${2:number insetY})$0",
    "description": "(Client) Method: Panel:SetTextInset\n\nSets the left and top text margins of a text-based panel object, such as a DButton or Type.DLabel."
  },
  "Panel:SetToFullHeight": {
    "prefix": "SetToFullHeight",
    "body": "SetToFullHeight()$0",
    "description": "(Client) Method: Panel:SetToFullHeight\n\nSets the height of a RichText element to accommodate the text inside."
  },
  "Panel:SetToolTip": {
    "prefix": "SetToolTip",
    "body": "SetToolTip()$0",
    "description": "(Client) Method: Panel:SetToolTip\n\n[Deprecated] .Alias of Panel.SetTooltip."
  },
  "Panel:SetTooltip": {
    "prefix": "SetTooltip",
    "body": "SetTooltip(${1:string str})$0",
    "description": "(Client) Method: Panel:SetTooltip\n\nSets the tooltip to be displayed when a player hovers over the panel object with their cursor."
  },
  "Panel:SetToolTipPanel": {
    "prefix": "SetToolTipPanel",
    "body": "SetToolTipPanel()$0",
    "description": "(Client) Method: Panel:SetToolTipPanel\n\n[Deprecated] .Alias of Panel.SetTooltipPanel."
  },
  "Panel:SetTooltipPanel": {
    "prefix": "SetTooltipPanel",
    "body": "SetTooltipPanel(${1:Panel tooltipPanel=nil})$0",
    "description": "(Client) Method: Panel:SetTooltipPanel\n\nSets the panel object to be displayed as a tooltip when a player hovers over the panel object with their cursor. "
  },
  "Panel:SetURL": {
    "prefix": "SetURL",
    "body": "SetURL(${1:string url})$0",
    "description": "(Client) Method: Panel:SetURL\n\n[[Category:DLabelURL]][[Category:URLLabel]]Sets the URL of a link-based panel such as DLabelURL."
  },
  "Panel:SetVerticalScrollbarEnabled": {
    "prefix": "SetVerticalScrollbarEnabled",
    "body": "SetVerticalScrollbarEnabled(${1:boolean display=false})$0",
    "description": "(Client) Method: Panel:SetVerticalScrollbarEnabled\n\nSets the visibility of the vertical scrollbar."
  },
  "Panel:SetVisible": {
    "prefix": "SetVisible",
    "body": "SetVisible(${1:boolean visible})$0",
    "description": "(Client) Method: Panel:SetVisible\n\nSets the \"visibility\" of the panel."
  },
  "Panel:SetWide": {
    "prefix": "SetWide",
    "body": "SetWide(${1:number width})$0",
    "description": "(Client) Method: Panel:SetWide\n\nSets width of a panel. An alias of Panel.SetWidth."
  },
  "Panel:SetWidth": {
    "prefix": "SetWidth",
    "body": "SetWidth(${1:number width})$0",
    "description": "(Client) Method: Panel:SetWidth\n\nSets the width of the panel."
  },
  "Panel:SetWorldClicker": {
    "prefix": "SetWorldClicker",
    "body": "SetWorldClicker(${1:boolean enabled})$0",
    "description": "(Client) Method: Panel:SetWorldClicker\n\nThis makes it so that when you're hovering over this panel you can `click` on the world. Your viewmodel will aim etc."
  },
  "Panel:SetWrap": {
    "prefix": "SetWrap",
    "body": "SetWrap(${1:boolean wrap})$0",
    "description": "(Client) Method: Panel:SetWrap\n\nSets whether text wrapping should be enabled or disabled on Label and Type.DLabel panels."
  },
  "Panel:SetZPos": {
    "prefix": "SetZPos",
    "body": "SetZPos(${1:number zIndex})$0",
    "description": "(Client) Method: Panel:SetZPos\n\nSets the panels z position which determines the rendering order."
  },
  "Panel:Show": {
    "prefix": "Show",
    "body": "Show()$0",
    "description": "(Client) Method: Panel:Show\n\nMakes a panel visible."
  },
  "Panel:SizeTo": {
    "prefix": "SizeTo",
    "body": "SizeTo(${1:number sizeW=0}, ${2:number sizeH=0}, ${3:number time}, ${4:number delay=0}, ${5:number ease=-1}, ${6:function callback})$0",
    "description": "(Client) Method: Panel:SizeTo\n\nUses animation to resize the panel to the specified size."
  },
  "Panel:SizeToChildren": {
    "prefix": "SizeToChildren",
    "body": "SizeToChildren(${1:boolean sizeW}, ${2:boolean sizeH})$0",
    "description": "(Client) Method: Panel:SizeToChildren\n\nResizes the panel to fit the bounds of its children."
  },
  "Panel:SizeToContents": {
    "prefix": "SizeToContents",
    "body": "SizeToContents()$0",
    "description": "(Client) Method: Panel:SizeToContents\n\nResizes the panel so that its width and height fit all of the content inside."
  },
  "Panel:SizeToContentsX": {
    "prefix": "SizeToContentsX",
    "body": "SizeToContentsX(${1:number addVal=0})$0",
    "description": "(Client) Method: Panel:SizeToContentsX\n\nResizes the panel object's width to accommodate all child objects/contents."
  },
  "Panel:SizeToContentsY": {
    "prefix": "SizeToContentsY",
    "body": "SizeToContentsY(${1:number addVal=0})$0",
    "description": "(Client) Method: Panel:SizeToContentsY\n\nResizes the panel object's height to accommodate all child objects/contents."
  },
  "Panel:SlideDown": {
    "prefix": "SlideDown",
    "body": "SlideDown(${1:number Length})$0",
    "description": "(Client) Method: Panel:SlideDown\n\nSlides the panel in from above."
  },
  "Panel:SlideUp": {
    "prefix": "SlideUp",
    "body": "SlideUp(${1:number Length})$0",
    "description": "(Client) Method: Panel:SlideUp\n\nSlides the panel out to the top."
  },
  "Panel:StartBoxSelection": {
    "prefix": "StartBoxSelection",
    "body": "StartBoxSelection()$0",
    "description": "(Client) Method: Panel:StartBoxSelection\n\nBegins a box selection, enables mouse capture for the panel object, and sets the start point of the selection box to the mouse cursor's position, relative to this object. For this to work, either the object or its parent must be enabled as a selection canvas. This is set using Panel.SetSelectionCanvas."
  },
  "Panel:Stop": {
    "prefix": "Stop",
    "body": "Stop()$0",
    "description": "(Client) Method: Panel:Stop\n\nStops all panel animations by clearing its animation list. This also clears all delayed animations."
  },
  "Panel:StretchBottomTo": {
    "prefix": "StretchBottomTo",
    "body": "StretchBottomTo(${1:Panel tgtPanel}, ${2:number offset=0})$0",
    "description": "(Client) Method: Panel:StretchBottomTo\n\nResizes the panel object's height so that its bottom is aligned with the top of the passed panel. An offset greater than zero will reduce the panel's height to leave a gap between it and the passed panel."
  },
  "Panel:StretchRightTo": {
    "prefix": "StretchRightTo",
    "body": "StretchRightTo(${1:Panel tgtPanel}, ${2:number offset=0})$0",
    "description": "(Client) Method: Panel:StretchRightTo\n\nResizes the panel object's width so that its right edge is aligned with the left of the passed panel. An offset greater than zero will reduce the panel's width to leave a gap between it and the passed panel."
  },
  "Panel:StretchToParent": {
    "prefix": "StretchToParent",
    "body": "StretchToParent(${1:number offsetLeft}, ${2:number offsetTop}, ${3:number offsetRight}, ${4:number offsetBottom})$0",
    "description": "(Client) Method: Panel:StretchToParent\n\nSets the dimensions of the panel to fill its parent. It will only stretch in directions that aren't nil."
  },
  "Panel:ToggleSelection": {
    "prefix": "ToggleSelection",
    "body": "ToggleSelection()$0",
    "description": "(Client) Method: Panel:ToggleSelection\n\nToggles the selected state of a selectable panel object. This functionality is set with Panel.SetSelectable and checked with Panel.IsSelectable. To check whether the object is selected or not, Panel.IsSelected is used."
  },
  "Panel:ToggleVisible": {
    "prefix": "ToggleVisible",
    "body": "ToggleVisible()$0",
    "description": "(Client) Method: Panel:ToggleVisible\n\nToggles the visibility of a panel and all its children."
  },
  "Panel:Undo": {
    "prefix": "Undo",
    "body": "Undo()$0",
    "description": "(Client) Method: Panel:Undo\n\nRestores the last saved state (caret position and the text inside) of a TextEntry. Should act identically to pressing CTRL Z in a Type.TextEntry."
  },
  "Panel:UnselectAll": {
    "prefix": "UnselectAll",
    "body": "UnselectAll()$0",
    "description": "(Client) Method: Panel:UnselectAll\n\nRecursively deselects this panel object and all of its children. This will cascade to all child objects at every level below the parent. "
  },
  "Panel:UpdateHTMLTexture": {
    "prefix": "UpdateHTMLTexture",
    "body": "UpdateHTMLTexture()$0",
    "description": "(Client) Method: Panel:UpdateHTMLTexture\n\nForcibly updates the panels' HTML Material, similar to when Paint is called on it.This is only useful if the panel is not normally visible, i.e the panel exists purely for its HTML Material."
  },
  "Panel:Valid": {
    "prefix": "Valid",
    "body": "Valid()$0",
    "description": "(Client) Method: Panel:Valid\n\n[Deprecated] .Use Panel.IsValid instead.Returns if a given panel is valid or not."
  },
  "PathFollower:Chase": {
    "prefix": "Chase",
    "body": "Chase(${1:NextBot bot}, ${2:Entity ent})$0",
    "description": "(Server) Method: PathFollower:Chase\n\nIf you created your path with type \"Chase\" this functions should be used in place of PathFollower.Update to cause the bot to chase the specified entity."
  },
  "PathFollower:Compute": {
    "prefix": "Compute",
    "body": "Compute(${1:NextBot from}, ${2:Vector to}, ${3:function generator=nil})$0",
    "description": "(Server) Method: PathFollower:Compute\n\nCompute shortest path from bot to 'goal' via A* algorithm."
  },
  "PathFollower:Draw": {
    "prefix": "Draw",
    "body": "Draw()$0",
    "description": "(Server) Method: PathFollower:Draw\n\nDraws the path. This is meant for debugging - and uses debug overlay."
  },
  "PathFollower:FirstSegment": {
    "prefix": "FirstSegment",
    "body": "FirstSegment()$0",
    "description": "(Server) Method: PathFollower:FirstSegment\n\nReturns the first segment of the path."
  },
  "PathFollower:GetAge": {
    "prefix": "GetAge",
    "body": "GetAge()$0",
    "description": "(Server) Method: PathFollower:GetAge\n\nReturns the age since the path was built"
  },
  "PathFollower:GetAllSegments": {
    "prefix": "GetAllSegments",
    "body": "GetAllSegments()$0",
    "description": "(Server) Method: PathFollower:GetAllSegments\n\nReturns all of the segments of the given path."
  },
  "PathFollower:GetClosestPosition": {
    "prefix": "GetClosestPosition",
    "body": "GetClosestPosition(${1:Vector position})$0",
    "description": "(Server) Method: PathFollower:GetClosestPosition\n\nThe closest position along the path to a position"
  },
  "PathFollower:GetCurrentGoal": {
    "prefix": "GetCurrentGoal",
    "body": "GetCurrentGoal()$0",
    "description": "(Server) Method: PathFollower:GetCurrentGoal\n\nReturns the current goal data. Can return nil if the current goal is invalid, for example immediately after PathFollower.Update."
  },
  "PathFollower:GetCursorData": {
    "prefix": "GetCursorData",
    "body": "GetCursorData()$0",
    "description": "(Server) Method: PathFollower:GetCursorData\n\nReturns the cursor data"
  },
  "PathFollower:GetCursorPosition": {
    "prefix": "GetCursorPosition",
    "body": "GetCursorPosition()$0",
    "description": "(Server) Method: PathFollower:GetCursorPosition\n\nReturns the current progress along the path"
  },
  "PathFollower:GetEnd": {
    "prefix": "GetEnd",
    "body": "GetEnd()$0",
    "description": "(Server) Method: PathFollower:GetEnd\n\nReturns the path end position"
  },
  "PathFollower:GetHindrance": {
    "prefix": "GetHindrance",
    "body": "GetHindrance()$0",
    "description": "(Server) Method: PathFollower:GetHindrance\n\n"
  },
  "PathFollower:GetLength": {
    "prefix": "GetLength",
    "body": "GetLength()$0",
    "description": "(Server) Method: PathFollower:GetLength\n\nReturns the total length of the path"
  },
  "PathFollower:GetPositionOnPath": {
    "prefix": "GetPositionOnPath",
    "body": "GetPositionOnPath(${1:number distance})$0",
    "description": "(Server) Method: PathFollower:GetPositionOnPath\n\nReturns the vector position of distance along path"
  },
  "PathFollower:GetStart": {
    "prefix": "GetStart",
    "body": "GetStart()$0",
    "description": "(Server) Method: PathFollower:GetStart\n\nReturns the path start position"
  },
  "PathFollower:Invalidate": {
    "prefix": "Invalidate",
    "body": "Invalidate()$0",
    "description": "(Server) Method: PathFollower:Invalidate\n\nInvalidates the current path"
  },
  "PathFollower:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Server) Method: PathFollower:IsValid\n\nReturns true if the path is valid"
  },
  "PathFollower:LastSegment": {
    "prefix": "LastSegment",
    "body": "LastSegment()$0",
    "description": "(Server) Method: PathFollower:LastSegment\n\nReturns the last segment of the path."
  },
  "PathFollower:MoveCursor": {
    "prefix": "MoveCursor",
    "body": "MoveCursor(${1:number distance})$0",
    "description": "(Server) Method: PathFollower:MoveCursor\n\nMoves the cursor by give distance."
  },
  "PathFollower:MoveCursorTo": {
    "prefix": "MoveCursorTo",
    "body": "MoveCursorTo(${1:number distance})$0",
    "description": "(Server) Method: PathFollower:MoveCursorTo\n\nSets the cursor position to given distance."
  },
  "PathFollower:MoveCursorToClosestPosition": {
    "prefix": "MoveCursorToClosestPosition",
    "body": "MoveCursorToClosestPosition(${1:Vector pos}, ${2:number type=0}, ${3:number alongLimit=0})$0",
    "description": "(Server) Method: PathFollower:MoveCursorToClosestPosition\n\nMoves the cursor of the path to the closest position compared to given vector."
  },
  "PathFollower:MoveCursorToEnd": {
    "prefix": "MoveCursorToEnd",
    "body": "MoveCursorToEnd()$0",
    "description": "(Server) Method: PathFollower:MoveCursorToEnd\n\nMoves the cursor to the end of the path"
  },
  "PathFollower:MoveCursorToStart": {
    "prefix": "MoveCursorToStart",
    "body": "MoveCursorToStart()$0",
    "description": "(Server) Method: PathFollower:MoveCursorToStart\n\nMoves the cursor to the end of the path"
  },
  "PathFollower:ResetAge": {
    "prefix": "ResetAge",
    "body": "ResetAge()$0",
    "description": "(Server) Method: PathFollower:ResetAge\n\nResets the age which is retrieved by PathFollower.GetAge to 0."
  },
  "PathFollower:SetGoalTolerance": {
    "prefix": "SetGoalTolerance",
    "body": "SetGoalTolerance(${1:number distance})$0",
    "description": "(Server) Method: PathFollower:SetGoalTolerance\n\nHow close we can get to the goal to call it done"
  },
  "PathFollower:SetMinLookAheadDistance": {
    "prefix": "SetMinLookAheadDistance",
    "body": "SetMinLookAheadDistance(${1:number mindist})$0",
    "description": "(Server) Method: PathFollower:SetMinLookAheadDistance\n\nSets minimum range movement goal must be along path"
  },
  "PathFollower:Update": {
    "prefix": "Update",
    "body": "Update(${1:NextBot bot})$0",
    "description": "(Server) Method: PathFollower:Update\n\nMove the bot along the path."
  },
  "PhysObj:AddAngleVelocity": {
    "prefix": "AddAngleVelocity",
    "body": "AddAngleVelocity(${1:Vector angularVelocity})$0",
    "description": "(Shared) Method: PhysObj:AddAngleVelocity\n\nAdds the specified velocity to the current."
  },
  "PhysObj:AddGameFlag": {
    "prefix": "AddGameFlag",
    "body": "AddGameFlag(${1:number flags})$0",
    "description": "(Shared) Method: PhysObj:AddGameFlag\n\nAdds one or more bit flags."
  },
  "PhysObj:AddVelocity": {
    "prefix": "AddVelocity",
    "body": "AddVelocity(${1:Vector velocity})$0",
    "description": "(Shared) Method: PhysObj:AddVelocity\n\nAdds the specified velocity to the current."
  },
  "PhysObj:AlignAngles": {
    "prefix": "AlignAngles",
    "body": "AlignAngles(${1:Angle from}, ${2:Angle to})$0",
    "description": "(Shared) Method: PhysObj:AlignAngles\n\nStubRotates the object so that it's angles are aligned to the ones inputted."
  },
  "PhysObj:ApplyForceCenter": {
    "prefix": "ApplyForceCenter",
    "body": "ApplyForceCenter(${1:Vector force})$0",
    "description": "(Shared) Method: PhysObj:ApplyForceCenter\n\nApplies the specified force to the physics object. (in Newtons)"
  },
  "PhysObj:ApplyForceOffset": {
    "prefix": "ApplyForceOffset",
    "body": "ApplyForceOffset(${1:Vector force}, ${2:Vector position})$0",
    "description": "(Shared) Method: PhysObj:ApplyForceOffset\n\nApplies the specified force on the physics object at the specified position"
  },
  "PhysObj:CalculateForceOffset": {
    "prefix": "CalculateForceOffset",
    "body": "CalculateForceOffset(${1:Vector force}, ${2:Vector pos})$0",
    "description": "(Shared) Method: PhysObj:CalculateForceOffset\n\n"
  },
  "PhysObj:CalculateVelocityOffset": {
    "prefix": "CalculateVelocityOffset",
    "body": "CalculateVelocityOffset(${1:Vector force}, ${2:Vector pos})$0",
    "description": "(Shared) Method: PhysObj:CalculateVelocityOffset\n\n"
  },
  "PhysObj:ClearGameFlag": {
    "prefix": "ClearGameFlag",
    "body": "ClearGameFlag(${1:number flags})$0",
    "description": "(Shared) Method: PhysObj:ClearGameFlag\n\nRemoves one of more specified flags."
  },
  "PhysObj:ComputeShadowControl": {
    "prefix": "ComputeShadowControl",
    "body": "ComputeShadowControl(${1:table shadowparams})$0",
    "description": "(Shared) Method: PhysObj:ComputeShadowControl\n\nAllows you to move a PhysObj to a point and angle in 3D space."
  },
  "PhysObj:EnableCollisions": {
    "prefix": "EnableCollisions",
    "body": "EnableCollisions(${1:boolean enable})$0",
    "description": "(Shared) Method: PhysObj:EnableCollisions\n\nSets whether the physics object should collide with anything or not, including world."
  },
  "PhysObj:EnableDrag": {
    "prefix": "EnableDrag",
    "body": "EnableDrag(${1:boolean enable})$0",
    "description": "(Shared) Method: PhysObj:EnableDrag\n\nSets whenever the physics object should be affected by drag."
  },
  "PhysObj:EnableGravity": {
    "prefix": "EnableGravity",
    "body": "EnableGravity(${1:boolean enable})$0",
    "description": "(Shared) Method: PhysObj:EnableGravity\n\nSets whenever the physobject should be affected by gravity"
  },
  "PhysObj:EnableMotion": {
    "prefix": "EnableMotion",
    "body": "EnableMotion(${1:boolean enable})$0",
    "description": "(Shared) Method: PhysObj:EnableMotion\n\nSets whether the physobject should be able to move or not."
  },
  "PhysObj:GetAABB": {
    "prefix": "GetAABB",
    "body": "GetAABB()$0",
    "description": "(Shared) Method: PhysObj:GetAABB\n\nReturns the mins and max of the physics object."
  },
  "PhysObj:GetAngles": {
    "prefix": "GetAngles",
    "body": "GetAngles()$0",
    "description": "(Shared) Method: PhysObj:GetAngles\n\nReturns the angles of the physics object."
  },
  "PhysObj:GetAngleVelocity": {
    "prefix": "GetAngleVelocity",
    "body": "GetAngleVelocity()$0",
    "description": "(Shared) Method: PhysObj:GetAngleVelocity\n\nGets the angular velocity of the object in degrees per second."
  },
  "PhysObj:GetDamping": {
    "prefix": "GetDamping",
    "body": "GetDamping()$0",
    "description": "(Shared) Method: PhysObj:GetDamping\n\nReturns the linear and angular damping of the physics object."
  },
  "PhysObj:GetEnergy": {
    "prefix": "GetEnergy",
    "body": "GetEnergy()$0",
    "description": "(Shared) Method: PhysObj:GetEnergy\n\nReturns the kinetic energy of the physobject."
  },
  "PhysObj:GetEntity": {
    "prefix": "GetEntity",
    "body": "GetEntity()$0",
    "description": "(Shared) Method: PhysObj:GetEntity\n\nReturns the parent entity of the physics object."
  },
  "PhysObj:GetInertia": {
    "prefix": "GetInertia",
    "body": "GetInertia()$0",
    "description": "(Shared) Method: PhysObj:GetInertia\n\nReturns the directional inertia of the physics object."
  },
  "PhysObj:GetInvInertia": {
    "prefix": "GetInvInertia",
    "body": "GetInvInertia()$0",
    "description": "(Shared) Method: PhysObj:GetInvInertia\n\nReturns 1 divided by the inertia."
  },
  "PhysObj:GetInvMass": {
    "prefix": "GetInvMass",
    "body": "GetInvMass()$0",
    "description": "(Shared) Method: PhysObj:GetInvMass\n\nReturns 1 divided by the physics object's mass."
  },
  "PhysObj:GetMass": {
    "prefix": "GetMass",
    "body": "GetMass()$0",
    "description": "(Shared) Method: PhysObj:GetMass\n\nReturns the mass of the physics object."
  },
  "PhysObj:GetMassCenter": {
    "prefix": "GetMassCenter",
    "body": "GetMassCenter()$0",
    "description": "(Shared) Method: PhysObj:GetMassCenter\n\nReturns the center of mass of the physics object as a local vector."
  },
  "PhysObj:GetMaterial": {
    "prefix": "GetMaterial",
    "body": "GetMaterial()$0",
    "description": "(Shared) Method: PhysObj:GetMaterial\n\nReturns the physical material of the physics object."
  },
  "PhysObj:GetMesh": {
    "prefix": "GetMesh",
    "body": "GetMesh()$0",
    "description": "(Shared) Method: PhysObj:GetMesh\n\nReturns a table of MeshVertexs where each 3 vertices represent a triangle."
  },
  "PhysObj:GetMeshConvexes": {
    "prefix": "GetMeshConvexes",
    "body": "GetMeshConvexes()$0",
    "description": "(Shared) Method: PhysObj:GetMeshConvexes\n\nReturns a structured table, the physics mesh of the physics object."
  },
  "PhysObj:GetName": {
    "prefix": "GetName",
    "body": "GetName()$0",
    "description": "(Shared) Method: PhysObj:GetName\n\nReturns the name of the physics object."
  },
  "PhysObj:GetPos": {
    "prefix": "GetPos",
    "body": "GetPos()$0",
    "description": "(Shared) Method: PhysObj:GetPos\n\nReturns the position of the physics object."
  },
  "PhysObj:GetRotDamping": {
    "prefix": "GetRotDamping",
    "body": "GetRotDamping()$0",
    "description": "(Shared) Method: PhysObj:GetRotDamping\n\nReturns the rotation damping of the physics object."
  },
  "PhysObj:GetSpeedDamping": {
    "prefix": "GetSpeedDamping",
    "body": "GetSpeedDamping()$0",
    "description": "(Shared) Method: PhysObj:GetSpeedDamping\n\nReturns the speed damping of the physics object."
  },
  "PhysObj:GetStress": {
    "prefix": "GetStress",
    "body": "GetStress()$0",
    "description": "(Server) Method: PhysObj:GetStress\n\nReturns the stress of the entity."
  },
  "PhysObj:GetSurfaceArea": {
    "prefix": "GetSurfaceArea",
    "body": "GetSurfaceArea()$0",
    "description": "(Shared) Method: PhysObj:GetSurfaceArea\n\nReturns the surface area of the physics object in source-units."
  },
  "PhysObj:GetVelocity": {
    "prefix": "GetVelocity",
    "body": "GetVelocity()$0",
    "description": "(Shared) Method: PhysObj:GetVelocity\n\nReturns the absolute directional velocity of the physobject."
  },
  "PhysObj:GetVolume": {
    "prefix": "GetVolume",
    "body": "GetVolume()$0",
    "description": "(Shared) Method: PhysObj:GetVolume\n\nReturns the volume in source units."
  },
  "PhysObj:HasGameFlag": {
    "prefix": "HasGameFlag",
    "body": "HasGameFlag(${1:number flags})$0",
    "description": "(Shared) Method: PhysObj:HasGameFlag\n\nReturns whenever the specified flag(s) is/are set."
  },
  "PhysObj:IsAsleep": {
    "prefix": "IsAsleep",
    "body": "IsAsleep()$0",
    "description": "(Shared) Method: PhysObj:IsAsleep\n\nReturns whether the physics object is \"sleeping\"."
  },
  "PhysObj:IsCollisionEnabled": {
    "prefix": "IsCollisionEnabled",
    "body": "IsCollisionEnabled()$0",
    "description": "(Shared) Method: PhysObj:IsCollisionEnabled\n\nReturns whenever the entity is able to collide or not."
  },
  "PhysObj:IsDragEnabled": {
    "prefix": "IsDragEnabled",
    "body": "IsDragEnabled()$0",
    "description": "(Shared) Method: PhysObj:IsDragEnabled\n\nReturns whenever the entity is affected by drag."
  },
  "PhysObj:IsGravityEnabled": {
    "prefix": "IsGravityEnabled",
    "body": "IsGravityEnabled()$0",
    "description": "(Shared) Method: PhysObj:IsGravityEnabled\n\nReturns whenever the entity is affected by gravity."
  },
  "PhysObj:IsMotionEnabled": {
    "prefix": "IsMotionEnabled",
    "body": "IsMotionEnabled()$0",
    "description": "(Shared) Method: PhysObj:IsMotionEnabled\n\nReturns if the physics object can move itself (by velocity, acceleration)"
  },
  "PhysObj:IsMoveable": {
    "prefix": "IsMoveable",
    "body": "IsMoveable()$0",
    "description": "(Shared) Method: PhysObj:IsMoveable\n\nReturns whenever the entity is able to move."
  },
  "PhysObj:IsPenetrating": {
    "prefix": "IsPenetrating",
    "body": "IsPenetrating()$0",
    "description": "(Shared) Method: PhysObj:IsPenetrating\n\nReturns whenever the physics object is penetrating another physics object."
  },
  "PhysObj:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Shared) Method: PhysObj:IsValid\n\nReturns if the physics object is valid/not NULL."
  },
  "PhysObj:LocalToWorld": {
    "prefix": "LocalToWorld",
    "body": "LocalToWorld(${1:Vector LocalVec})$0",
    "description": "(Shared) Method: PhysObj:LocalToWorld\n\nMapping a vector in local frame of the physics object to world frame."
  },
  "PhysObj:LocalToWorldVector": {
    "prefix": "LocalToWorldVector",
    "body": "LocalToWorldVector(${1:Vector LocalVec})$0",
    "description": "(Shared) Method: PhysObj:LocalToWorldVector\n\nRotate a vector from the local frame of the physics object to world frame."
  },
  "PhysObj:OutputDebugInfo": {
    "prefix": "OutputDebugInfo",
    "body": "OutputDebugInfo()$0",
    "description": "(Shared) Method: PhysObj:OutputDebugInfo\n\nPrints debug info about the state of the physics object to the console."
  },
  "PhysObj:RecheckCollisionFilter": {
    "prefix": "RecheckCollisionFilter",
    "body": "RecheckCollisionFilter()$0",
    "description": "(Shared) Method: PhysObj:RecheckCollisionFilter\n\nCall this when the collision filter conditions change due to this object's state (e.g. changing solid type or collision group)"
  },
  "PhysObj:RotateAroundAxis": {
    "prefix": "RotateAroundAxis",
    "body": "RotateAroundAxis(${1:Vector dir}, ${2:number ang})$0",
    "description": "(Shared) Method: PhysObj:RotateAroundAxis\n\nA convinience function for Angle.RotateAroundAxis."
  },
  "PhysObj:SetAngleDragCoefficient": {
    "prefix": "SetAngleDragCoefficient",
    "body": "SetAngleDragCoefficient(${1:number coef})$0",
    "description": "(Shared) Method: PhysObj:SetAngleDragCoefficient\n\n"
  },
  "PhysObj:SetAngles": {
    "prefix": "SetAngles",
    "body": "SetAngles(${1:Angle angles})$0",
    "description": "(Shared) Method: PhysObj:SetAngles\n\nSets the angles of the physobject."
  },
  "PhysObj:SetBuoyancyRatio": {
    "prefix": "SetBuoyancyRatio",
    "body": "SetBuoyancyRatio(${1:number buoyancy})$0",
    "description": "(Shared) Method: PhysObj:SetBuoyancyRatio\n\nSets the buoyancy ratio of the physics object. (How well it floats in water)"
  },
  "PhysObj:SetDamping": {
    "prefix": "SetDamping",
    "body": "SetDamping(${1:number linearDamping}, ${2:number angularDamping})$0",
    "description": "(Shared) Method: PhysObj:SetDamping\n\nSets the linear and angular damping of the physics object."
  },
  "PhysObj:SetDragCoefficient": {
    "prefix": "SetDragCoefficient",
    "body": "SetDragCoefficient(${1:number drag})$0",
    "description": "(Shared) Method: PhysObj:SetDragCoefficient\n\nModifies how much drag (air resistance) affects the object."
  },
  "PhysObj:SetInertia": {
    "prefix": "SetInertia",
    "body": "SetInertia(${1:Vector directionalInertia})$0",
    "description": "(Shared) Method: PhysObj:SetInertia\n\nSets the directional inertia."
  },
  "PhysObj:SetMass": {
    "prefix": "SetMass",
    "body": "SetMass(${1:number mass})$0",
    "description": "(Shared) Method: PhysObj:SetMass\n\nSets the mass of the physobject."
  },
  "PhysObj:SetMaterial": {
    "prefix": "SetMaterial",
    "body": "SetMaterial(${1:string materialName})$0",
    "description": "(Shared) Method: PhysObj:SetMaterial\n\nSets the material of the physobject."
  },
  "PhysObj:SetPos": {
    "prefix": "SetPos",
    "body": "SetPos(${1:Vector position}, ${2:boolean teleport=false})$0",
    "description": "(Shared) Method: PhysObj:SetPos\n\nSets the position of the physobject."
  },
  "PhysObj:SetVelocity": {
    "prefix": "SetVelocity",
    "body": "SetVelocity(${1:Vector velocity})$0",
    "description": "(Shared) Method: PhysObj:SetVelocity\n\nSets the velocity of the physics object for the next iteration."
  },
  "PhysObj:SetVelocityInstantaneous": {
    "prefix": "SetVelocityInstantaneous",
    "body": "SetVelocityInstantaneous(${1:Vector velocity})$0",
    "description": "(Shared) Method: PhysObj:SetVelocityInstantaneous\n\nSets the velocity of the physics object."
  },
  "PhysObj:Sleep": {
    "prefix": "Sleep",
    "body": "Sleep()$0",
    "description": "(Shared) Method: PhysObj:Sleep\n\nMakes the physics object \"sleep\"."
  },
  "PhysObj:UpdateShadow": {
    "prefix": "UpdateShadow",
    "body": "UpdateShadow(${1:Vector targetPosition}, ${2:Angle targetAngles}, ${3:number frameTime})$0",
    "description": "(Shared) Method: PhysObj:UpdateShadow\n\nUnlike PhysObj.SetPos and PhysObj.SetAngles, this allows the movement of a physobj while leaving physics interactions intact."
  },
  "PhysObj:Wake": {
    "prefix": "Wake",
    "body": "Wake()$0",
    "description": "(Shared) Method: PhysObj:Wake\n\nWakes the physics object."
  },
  "PhysObj:WorldToLocal": {
    "prefix": "WorldToLocal",
    "body": "WorldToLocal(${1:Vector vec})$0",
    "description": "(Shared) Method: PhysObj:WorldToLocal\n\nConverts a vector to a relative to the physics object coordinate system."
  },
  "PhysObj:WorldToLocalVector": {
    "prefix": "WorldToLocalVector",
    "body": "WorldToLocalVector(${1:Vector WorldVec})$0",
    "description": "(Shared) Method: PhysObj:WorldToLocalVector\n\nRotate a vector from the world frame to the local frame of the physics object."
  },
  "Player:AccountID": {
    "prefix": "AccountID",
    "body": "AccountID()$0",
    "description": "(Shared) Method: Player:AccountID\n\nReturns the player's AccountID aka 32bit SteamID."
  },
  "Player:AddCleanup": {
    "prefix": "AddCleanup",
    "body": "AddCleanup(${1:string type}, ${2:Entity ent})$0",
    "description": "(Shared) Method: Player:AddCleanup\n\nAdds an entity to the players clean up list."
  },
  "Player:AddCount": {
    "prefix": "AddCount",
    "body": "AddCount(${1:string str}, ${2:Entity ent})$0",
    "description": "(Shared) Method: Player:AddCount\n\nAdds an entity to the total count of entities of same class."
  },
  "Player:AddDeaths": {
    "prefix": "AddDeaths",
    "body": "AddDeaths(${1:number count})$0",
    "description": "(Server) Method: Player:AddDeaths\n\nAdd a certain amount to the player's death count"
  },
  "Player:AddFrags": {
    "prefix": "AddFrags",
    "body": "AddFrags(${1:number count})$0",
    "description": "(Server) Method: Player:AddFrags\n\nAdd a certain amount to the player's frag count (or kills count)"
  },
  "Player:AddFrozenPhysicsObject": {
    "prefix": "AddFrozenPhysicsObject",
    "body": "AddFrozenPhysicsObject(${1:Entity ent}, ${2:PhysObj physobj})$0",
    "description": "(Server) Method: Player:AddFrozenPhysicsObject\n\nAdds a entity to the players list of frozen objects."
  },
  "Player:AddPlayerOption": {
    "prefix": "AddPlayerOption",
    "body": "AddPlayerOption(${1:string name}, ${2:number timeout}, ${3:function vote callback}, ${4:function draw callback})$0",
    "description": "(Client) Method: Player:AddPlayerOption\n\nSets up the voting system for the player."
  },
  "Player:AddVCDSequenceToGestureSlot": {
    "prefix": "AddVCDSequenceToGestureSlot",
    "body": "AddVCDSequenceToGestureSlot(${1:number slot}, ${2:number sequenceId}, ${3:number cycle}, ${4:boolean loop})$0",
    "description": "(Shared) Method: Player:AddVCDSequenceToGestureSlot\n\nPlays a sequence directly from a sequence number, similar to Player.AnimRestartGesture. This function has the advantage to play sequences that haven't been bound to an existing Enum.ACT"
  },
  "Player:Alive": {
    "prefix": "Alive",
    "body": "Alive()$0",
    "description": "(Shared) Method: Player:Alive\n\nChecks if the player is alive."
  },
  "Player:AllowFlashlight": {
    "prefix": "AllowFlashlight",
    "body": "AllowFlashlight(${1:boolean canFlashlight})$0",
    "description": "(Shared) Method: Player:AllowFlashlight\n\nSets if the player can toggle his flashlight. Function exists on both the server and client but has no effect when ran on the client."
  },
  "Player:AllowImmediateDecalPainting": {
    "prefix": "AllowImmediateDecalPainting",
    "body": "AllowImmediateDecalPainting(${1:boolean allow})$0",
    "description": "(Server) Method: Player:AllowImmediateDecalPainting\n\nLets the player spray his decal without delay"
  },
  "Player:AnimResetGestureSlot": {
    "prefix": "AnimResetGestureSlot",
    "body": "AnimResetGestureSlot(${1:number slot})$0",
    "description": "(Shared) Method: Player:AnimResetGestureSlot\n\nResets player gesture in selected slot."
  },
  "Player:AnimRestartGesture": {
    "prefix": "AnimRestartGesture",
    "body": "AnimRestartGesture(${1:number slot}, ${2:number activity}, ${3:boolean bAutoKill})$0",
    "description": "(Shared) Method: Player:AnimRestartGesture\n\nRestart a gesture on a player, within a gesture slot."
  },
  "Player:AnimRestartMainSequence": {
    "prefix": "AnimRestartMainSequence",
    "body": "AnimRestartMainSequence()$0",
    "description": "(Shared) Method: Player:AnimRestartMainSequence\n\nRestarts the main animation on the player, has the same effect as calling Entity.SetCycle( 0 )."
  },
  "Player:AnimSetGestureSequence": {
    "prefix": "AnimSetGestureSequence",
    "body": "AnimSetGestureSequence(${1:number slot}, ${2:number sequenceID})$0",
    "description": "(Shared) Method: Player:AnimSetGestureSequence\n\nSets the sequence of the animation playing in the given gesture slot."
  },
  "Player:AnimSetGestureWeight": {
    "prefix": "AnimSetGestureWeight",
    "body": "AnimSetGestureWeight(${1:number slot}, ${2:number weight})$0",
    "description": "(Shared) Method: Player:AnimSetGestureWeight\n\nSets the weight of the animation playing in the given gesture slot."
  },
  "Player:Armor": {
    "prefix": "Armor",
    "body": "Armor()$0",
    "description": "(Shared) Method: Player:Armor\n\nReturns the player's armor."
  },
  "Player:Ban": {
    "prefix": "Ban",
    "body": "Ban(${1:number minutes}, ${2:boolean kick=false})$0",
    "description": "(Server) Method: Player:Ban\n\nBans the player from the server for a certain amount of minutes."
  },
  "Player:CanUseFlashlight": {
    "prefix": "CanUseFlashlight",
    "body": "CanUseFlashlight()$0",
    "description": "(Shared) Method: Player:CanUseFlashlight\n\nReturns true if the player's flashlight hasn't been disabled by  Player.AllowFlashlight"
  },
  "Player:ChatPrint": {
    "prefix": "ChatPrint",
    "body": "ChatPrint(${1:string message})$0",
    "description": "(Shared) Method: Player:ChatPrint\n\nPrints a string to the chatbox of the client."
  },
  "Player:CheckLimit": {
    "prefix": "CheckLimit",
    "body": "CheckLimit(${1:string limitType})$0",
    "description": "(Shared) Method: Player:CheckLimit\n\nChecks if the limit is hit or not. If it is, it will throw a notification saying so."
  },
  "Player:ConCommand": {
    "prefix": "ConCommand",
    "body": "ConCommand(${1:string command})$0",
    "description": "(Shared) Method: Player:ConCommand\n\nRuns the concommand on the player. This does not work on bots."
  },
  "Player:CreateRagdoll": {
    "prefix": "CreateRagdoll",
    "body": "CreateRagdoll()$0",
    "description": "(Server) Method: Player:CreateRagdoll\n\nCreates the player's ragdoll entity."
  },
  "Player:CrosshairDisable": {
    "prefix": "CrosshairDisable",
    "body": "CrosshairDisable()$0",
    "description": "(Server) Method: Player:CrosshairDisable\n\nDisables a players crosshair."
  },
  "Player:CrosshairEnable": {
    "prefix": "CrosshairEnable",
    "body": "CrosshairEnable()$0",
    "description": "(Server) Method: Player:CrosshairEnable\n\nEnables crosshair of player."
  },
  "Player:Crouching": {
    "prefix": "Crouching",
    "body": "Crouching()$0",
    "description": "(Shared) Method: Player:Crouching\n\nReturns whether the player is crouching or not"
  },
  "Player:Deaths": {
    "prefix": "Deaths",
    "body": "Deaths()$0",
    "description": "(Shared) Method: Player:Deaths\n\nReturns the player's death count"
  },
  "Player:DebugInfo": {
    "prefix": "DebugInfo",
    "body": "DebugInfo()$0",
    "description": "(Server) Method: Player:DebugInfo\n\nPrints the players' name and position to the console."
  },
  "Player:DetonateTripmines": {
    "prefix": "DetonateTripmines",
    "body": "DetonateTripmines()$0",
    "description": "(Server) Method: Player:DetonateTripmines\n\nDetonates all tripmines belonging to the player."
  },
  "Player:DoAnimationEvent": {
    "prefix": "DoAnimationEvent",
    "body": "DoAnimationEvent(${1:number data})$0",
    "description": "(Shared) Method: Player:DoAnimationEvent\n\nSends a third person animation event to the player."
  },
  "Player:DoAttackEvent": {
    "prefix": "DoAttackEvent",
    "body": "DoAttackEvent()$0",
    "description": "(Shared) Method: Player:DoAttackEvent\n\nStarts the player's attack animation. The attack animation is determined by the weapon's HoldType."
  },
  "Player:DoCustomAnimEvent": {
    "prefix": "DoCustomAnimEvent",
    "body": "DoCustomAnimEvent(${1:number event}, ${2:number data})$0",
    "description": "(Shared) Method: Player:DoCustomAnimEvent\n\nSends a specified third person animation event to the player."
  },
  "Player:DoReloadEvent": {
    "prefix": "DoReloadEvent",
    "body": "DoReloadEvent()$0",
    "description": "(Shared) Method: Player:DoReloadEvent\n\nSends a third person reload animation event to the player."
  },
  "Player:DoSecondaryAttack": {
    "prefix": "DoSecondaryAttack",
    "body": "DoSecondaryAttack()$0",
    "description": "(Shared) Method: Player:DoSecondaryAttack\n\nSends a third person secondary fire animation event to the player."
  },
  "Player:DrawViewModel": {
    "prefix": "DrawViewModel",
    "body": "DrawViewModel(${1:boolean draw}, ${2:number vm=0})$0",
    "description": "(Server) Method: Player:DrawViewModel\n\nShow/Hide the player's weapon's viewmodel."
  },
  "Player:DrawWorldModel": {
    "prefix": "DrawWorldModel",
    "body": "DrawWorldModel(${1:boolean draw})$0",
    "description": "(Server) Method: Player:DrawWorldModel\n\nShow/Hide the player's weapon's worldmodel."
  },
  "Player:DropNamedWeapon": {
    "prefix": "DropNamedWeapon",
    "body": "DropNamedWeapon(${1:string class})$0",
    "description": "(Server) Method: Player:DropNamedWeapon\n\nDrops the players' weapon of a specific class."
  },
  "Player:DropObject": {
    "prefix": "DropObject",
    "body": "DropObject()$0",
    "description": "(Server) Method: Player:DropObject\n\nDrops any object the player is currently holding with either gravitygun or  Use (E key)"
  },
  "Player:DropWeapon": {
    "prefix": "DropWeapon",
    "body": "DropWeapon(${1:Weapon weapon})$0",
    "description": "(Server) Method: Player:DropWeapon\n\nForces the player to drop the specified weapon"
  },
  "Player:EnterVehicle": {
    "prefix": "EnterVehicle",
    "body": "EnterVehicle(${1:Vehicle vehicle})$0",
    "description": "(Server) Method: Player:EnterVehicle\n\nEnters the player into specified vehicle"
  },
  "Player:EquipSuit": {
    "prefix": "EquipSuit",
    "body": "EquipSuit()$0",
    "description": "(Server) Method: Player:EquipSuit\n\nEquips the player with the HEV suit."
  },
  "Player:ExitVehicle": {
    "prefix": "ExitVehicle",
    "body": "ExitVehicle()$0",
    "description": "(Server) Method: Player:ExitVehicle\n\nMakes the player exit the vehicle if they're in one."
  },
  "Player:Flashlight": {
    "prefix": "Flashlight",
    "body": "Flashlight(${1:boolean isOn})$0",
    "description": "(Server) Method: Player:Flashlight\n\nEnables/Disables the player's flashlight"
  },
  "Player:FlashlightIsOn": {
    "prefix": "FlashlightIsOn",
    "body": "FlashlightIsOn()$0",
    "description": "(Shared) Method: Player:FlashlightIsOn\n\nReturns true if the player's flashlight is on."
  },
  "Player:Frags": {
    "prefix": "Frags",
    "body": "Frags()$0",
    "description": "(Shared) Method: Player:Frags\n\nReturns the amount of kills a player has."
  },
  "Player:Freeze": {
    "prefix": "Freeze",
    "body": "Freeze(${1:boolean frozen=false})$0",
    "description": "(Server) Method: Player:Freeze\n\nFreeze/Unfreezes the player. Frozen players cannot move, attack or turn around. Keybindings are still called. Similar to Player.Lock."
  },
  "Player:GetActiveWeapon": {
    "prefix": "GetActiveWeapon",
    "body": "GetActiveWeapon()$0",
    "description": "(Shared) Method: Player:GetActiveWeapon\n\nReturns the player's active weapon."
  },
  "Player:GetAimVector": {
    "prefix": "GetAimVector",
    "body": "GetAimVector()$0",
    "description": "(Shared) Method: Player:GetAimVector\n\nReturns the direction that the player is aiming."
  },
  "Player:GetAllowFullRotation": {
    "prefix": "GetAllowFullRotation",
    "body": "GetAllowFullRotation()$0",
    "description": "(Shared) Method: Player:GetAllowFullRotation\n\nReturns true if the players' model is allowed to rotate around the pitch and roll axis."
  },
  "Player:GetAllowWeaponsInVehicle": {
    "prefix": "GetAllowWeaponsInVehicle",
    "body": "GetAllowWeaponsInVehicle()$0",
    "description": "(Shared) Method: Player:GetAllowWeaponsInVehicle\n\nReturns whether the player is allowed to use his weapons in a vehicle or not."
  },
  "Player:GetAmmoCount": {
    "prefix": "GetAmmoCount",
    "body": "GetAmmoCount(${1:any ammotype})$0",
    "description": "(Shared) Method: Player:GetAmmoCount\n\nGets the amount of ammo the player has."
  },
  "Player:GetAvoidPlayers": {
    "prefix": "GetAvoidPlayers",
    "body": "GetAvoidPlayers()$0",
    "description": "(Shared) Method: Player:GetAvoidPlayers\n\nGets if the player will be pushed out of nocollided players."
  },
  "Player:GetCanWalk": {
    "prefix": "GetCanWalk",
    "body": "GetCanWalk()$0",
    "description": "(Shared) Method: Player:GetCanWalk\n\nReturns true if the player is able to walk using the (default) alt key."
  },
  "Player:GetCanZoom": {
    "prefix": "GetCanZoom",
    "body": "GetCanZoom()$0",
    "description": "(Shared) Method: Player:GetCanZoom\n\nDetermines whenever the player is allowed to use the zoom functionality."
  },
  "Player:GetClassID": {
    "prefix": "GetClassID",
    "body": "GetClassID()$0",
    "description": "(Shared) Method: Player:GetClassID\n\nReturns the player's class id."
  },
  "Player:GetCount": {
    "prefix": "GetCount",
    "body": "GetCount(${1:string type}, ${2:number minus=0})$0",
    "description": "(Shared) Method: Player:GetCount\n\nGets total count of entities of same class."
  },
  "Player:GetCrouchedWalkSpeed": {
    "prefix": "GetCrouchedWalkSpeed",
    "body": "GetCrouchedWalkSpeed()$0",
    "description": "(Shared) Method: Player:GetCrouchedWalkSpeed\n\nGets the crouched walk speed."
  },
  "Player:GetCurrentCommand": {
    "prefix": "GetCurrentCommand",
    "body": "GetCurrentCommand()$0",
    "description": "(Shared) Method: Player:GetCurrentCommand\n\nReturns the last command which was sent by the specified player. Can only be used in a [[:Category:Predicted_Hooks.Predicted Hook]]."
  },
  "Player:GetCurrentViewOffset": {
    "prefix": "GetCurrentViewOffset",
    "body": "GetCurrentViewOffset()$0",
    "description": "(Shared) Method: Player:GetCurrentViewOffset\n\nGets the '''actual''' view offset which equals the difference between the players actual position and their view when standing."
  },
  "Player:GetDrivingEntity": {
    "prefix": "GetDrivingEntity",
    "body": "GetDrivingEntity()$0",
    "description": "(Shared) Method: Player:GetDrivingEntity\n\nGets the entity the player is currently driving."
  },
  "Player:GetDrivingMode": {
    "prefix": "GetDrivingMode",
    "body": "GetDrivingMode()$0",
    "description": "(Shared) Method: Player:GetDrivingMode\n\nReturns driving mode of the player. See [[Entity Driving]]."
  },
  "Player:GetDuckSpeed": {
    "prefix": "GetDuckSpeed",
    "body": "GetDuckSpeed()$0",
    "description": "(Shared) Method: Player:GetDuckSpeed\n\nReturns a player's duck speed (in seconds)"
  },
  "Player:GetEyeTrace": {
    "prefix": "GetEyeTrace",
    "body": "GetEyeTrace()$0",
    "description": "(Shared) Method: Player:GetEyeTrace\n\nReturns a table with information of what the player is looking at."
  },
  "Player:GetEyeTraceNoCursor": {
    "prefix": "GetEyeTraceNoCursor",
    "body": "GetEyeTraceNoCursor()$0",
    "description": "(Shared) Method: Player:GetEyeTraceNoCursor\n\nReturns the trace according to the players view direction, ignoring their mouse ( Holding C and moving the mouse in Sandbox )."
  },
  "Player:GetFOV": {
    "prefix": "GetFOV",
    "body": "GetFOV()$0",
    "description": "(Shared) Method: Player:GetFOV\n\nReturns the FOV of the player."
  },
  "Player:GetFriendStatus": {
    "prefix": "GetFriendStatus",
    "body": "GetFriendStatus()$0",
    "description": "(Client) Method: Player:GetFriendStatus\n\nReturns the steam \"relationship\" towards the player."
  },
  "Player:GetHands": {
    "prefix": "GetHands",
    "body": "GetHands()$0",
    "description": "(Shared) Method: Player:GetHands\n\nGets the hands entity of a player"
  },
  "Player:GetHoveredWidget": {
    "prefix": "GetHoveredWidget",
    "body": "GetHoveredWidget()$0",
    "description": "(Shared) Method: Player:GetHoveredWidget\n\nReturns the widget the player is hovering with his mouse."
  },
  "Player:GetHull": {
    "prefix": "GetHull",
    "body": "GetHull()$0",
    "description": "(Shared) Method: Player:GetHull\n\nGets the bottom base and the top base size of the player's hull."
  },
  "Player:GetHullDuck": {
    "prefix": "GetHullDuck",
    "body": "GetHullDuck()$0",
    "description": "(Shared) Method: Player:GetHullDuck\n\nGets the bottom base and the top base size of the player's crouch hull."
  },
  "Player:GetInfo": {
    "prefix": "GetInfo",
    "body": "GetInfo(${1:string cVarName})$0",
    "description": "(Server) Method: Player:GetInfo\n\nRetrieves the value of a client-side ConVar. The Type.ConVar must have a [[Enums/FCVAR.FCVAR_USERINFO]] flag for this to work."
  },
  "Player:GetInfoNum": {
    "prefix": "GetInfoNum",
    "body": "GetInfoNum(${1:string cVarName}, ${2:number default})$0",
    "description": "(Server) Method: Player:GetInfoNum\n\nRetrieves the numeric value of a client-side convar, returns nil if value is not convertible to a number. The ConVar must have a [[Enums/FCVAR.FCVAR_USERINFO]] flag for this to work."
  },
  "Player:GetJumpPower": {
    "prefix": "GetJumpPower",
    "body": "GetJumpPower()$0",
    "description": "(Shared) Method: Player:GetJumpPower\n\nReturns the jump power of the player"
  },
  "Player:GetLaggedMovementValue": {
    "prefix": "GetLaggedMovementValue",
    "body": "GetLaggedMovementValue()$0",
    "description": "(Shared) Method: Player:GetLaggedMovementValue\n\nReturns the timescale multiplier of the player movement."
  },
  "Player:GetMaxSpeed": {
    "prefix": "GetMaxSpeed",
    "body": "GetMaxSpeed()$0",
    "description": "(Shared) Method: Player:GetMaxSpeed\n\nReturns the player's maximum movement speed."
  },
  "Player:GetName": {
    "prefix": "GetName",
    "body": "GetName()$0",
    "description": "(Shared) Method: Player:GetName\n\nReturns the player's name, this is an alias of Player.Nick."
  },
  "Player:GetNoCollideWithTeammates": {
    "prefix": "GetNoCollideWithTeammates",
    "body": "GetNoCollideWithTeammates()$0",
    "description": "(Shared) Method: Player:GetNoCollideWithTeammates\n\nReturns whenever the player is set not to collide with their teammates."
  },
  "Player:GetObserverMode": {
    "prefix": "GetObserverMode",
    "body": "GetObserverMode()$0",
    "description": "(Shared) Method: Player:GetObserverMode\n\nReturns the the observer mode of the player"
  },
  "Player:GetObserverTarget": {
    "prefix": "GetObserverTarget",
    "body": "GetObserverTarget()$0",
    "description": "(Shared) Method: Player:GetObserverTarget\n\nReturns the entity the player is currently observing. Returns no value if the player has no target."
  },
  "Player:GetPData": {
    "prefix": "GetPData",
    "body": "GetPData(${1:any key}, ${2:any default})$0",
    "description": "(Shared) Method: Player:GetPData\n\nReturns a player's PData from the server's or client's SQL database. ( sv.db and cl.db respectively ) It is not networked!"
  },
  "Player:GetPlayerColor": {
    "prefix": "GetPlayerColor",
    "body": "GetPlayerColor()$0",
    "description": "(Shared) Method: Player:GetPlayerColor\n\nReturns a player model's color. The part of the model that is colored is determined by the model itself, and is different for each model. The format is Vector(r,g,b), and each color should be between 0 and 1."
  },
  "Player:GetPlayerInfo": {
    "prefix": "GetPlayerInfo",
    "body": "GetPlayerInfo()$0",
    "description": "(Client) Method: Player:GetPlayerInfo\n\nReturns a table containing player information."
  },
  "Player:GetPreferredCarryAngles": {
    "prefix": "GetPreferredCarryAngles",
    "body": "GetPreferredCarryAngles(${1:Entity })$0",
    "description": "(Server) Method: Player:GetPreferredCarryAngles\n\nStub"
  },
  "Player:GetPressedWidget": {
    "prefix": "GetPressedWidget",
    "body": "GetPressedWidget()$0",
    "description": "(Shared) Method: Player:GetPressedWidget\n\nReturns the widget entity the player is using."
  },
  "Player:GetPunchAngle": {
    "prefix": "GetPunchAngle",
    "body": "GetPunchAngle()$0",
    "description": "(Shared) Method: Player:GetPunchAngle\n\n[Deprecated] .You should use Player.GetViewPunchAngles instead."
  },
  "Player:GetRagdollEntity": {
    "prefix": "GetRagdollEntity",
    "body": "GetRagdollEntity()$0",
    "description": "(Shared) Method: Player:GetRagdollEntity\n\nReturns players death ragdoll. The ragdoll is created by Player.CreateRagdoll."
  },
  "Player:GetRenderAngles": {
    "prefix": "GetRenderAngles",
    "body": "GetRenderAngles()$0",
    "description": "(Shared) Method: Player:GetRenderAngles\n\nReturns the render angles for the player."
  },
  "Player:GetRunSpeed": {
    "prefix": "GetRunSpeed",
    "body": "GetRunSpeed()$0",
    "description": "(Shared) Method: Player:GetRunSpeed\n\nReturns the amount of speed the player runs at."
  },
  "Player:GetShootPos": {
    "prefix": "GetShootPos",
    "body": "GetShootPos()$0",
    "description": "(Shared) Method: Player:GetShootPos\n\nReturns the position of a Player's view"
  },
  "Player:GetStepSize": {
    "prefix": "GetStepSize",
    "body": "GetStepSize()$0",
    "description": "(Shared) Method: Player:GetStepSize\n\nReturns the maximum height player can step onto."
  },
  "Player:GetTimeoutSeconds": {
    "prefix": "GetTimeoutSeconds",
    "body": "GetTimeoutSeconds()$0",
    "description": "(Server) Method: Player:GetTimeoutSeconds\n\nReturns the number of seconds that the player has been timing out for. You can check if a player is timing out with Player.IsTimingOut."
  },
  "Player:GetTool": {
    "prefix": "GetTool",
    "body": "GetTool(${1:string mode=nil})$0",
    "description": "(Shared) Method: Player:GetTool\n\nReturns TOOL table of players current tool, or of the one specified."
  },
  "Player:GetUnDuckSpeed": {
    "prefix": "GetUnDuckSpeed",
    "body": "GetUnDuckSpeed()$0",
    "description": "(Shared) Method: Player:GetUnDuckSpeed\n\nReturns a player's unduck speed (in seconds)"
  },
  "Player:GetUserGroup": {
    "prefix": "GetUserGroup",
    "body": "GetUserGroup()$0",
    "description": "(Shared) Method: Player:GetUserGroup\n\nReturns the player's user group."
  },
  "Player:GetVehicle": {
    "prefix": "GetVehicle",
    "body": "GetVehicle()$0",
    "description": "(Shared) Method: Player:GetVehicle\n\nGets the vehicle the player is driving, returns NULL ENTITY if the player is not driving."
  },
  "Player:GetViewEntity": {
    "prefix": "GetViewEntity",
    "body": "GetViewEntity()$0",
    "description": "(Shared) Method: Player:GetViewEntity\n\nReturns the entity the player is using to see from (such as the player itself, the camera, or another entity)."
  },
  "Player:GetViewModel": {
    "prefix": "GetViewModel",
    "body": "GetViewModel(${1:number index=0})$0",
    "description": "(Shared) Method: Player:GetViewModel\n\nReturns the player's view model entity by the index."
  },
  "Player:GetViewOffset": {
    "prefix": "GetViewOffset",
    "body": "GetViewOffset()$0",
    "description": "(Shared) Method: Player:GetViewOffset\n\nReturns the view offset of the player which equals the difference between the players actual position and their view."
  },
  "Player:GetViewOffsetDucked": {
    "prefix": "GetViewOffsetDucked",
    "body": "GetViewOffsetDucked()$0",
    "description": "(Shared) Method: Player:GetViewOffsetDucked\n\nReturns the view offset of the player which equals the difference between the players actual position and their view when ducked."
  },
  "Player:GetViewPunchAngles": {
    "prefix": "GetViewPunchAngles",
    "body": "GetViewPunchAngles()$0",
    "description": "(Shared) Method: Player:GetViewPunchAngles\n\nReturns players screen punch effect angle."
  },
  "Player:GetWalkSpeed": {
    "prefix": "GetWalkSpeed",
    "body": "GetWalkSpeed()$0",
    "description": "(Shared) Method: Player:GetWalkSpeed\n\nReturns a player's walk speed"
  },
  "Player:GetWeapon": {
    "prefix": "GetWeapon",
    "body": "GetWeapon(${1:string className})$0",
    "description": "(Shared) Method: Player:GetWeapon\n\nReturns the weapon for the specified class"
  },
  "Player:GetWeaponColor": {
    "prefix": "GetWeaponColor",
    "body": "GetWeaponColor()$0",
    "description": "(Shared) Method: Player:GetWeaponColor\n\nReturns a player's weapon color. The part of the model that is colored is determined by the model itself, and is different for each model. The format is Vector(r,g,b), and each color should be between 0 and 1."
  },
  "Player:GetWeapons": {
    "prefix": "GetWeapons",
    "body": "GetWeapons()$0",
    "description": "(Shared) Method: Player:GetWeapons\n\nReturns a table of the player's weapons."
  },
  "Player:Give": {
    "prefix": "Give",
    "body": "Give(${1:string weaponClassName}, ${2:boolean bNoAmmo=false})$0",
    "description": "(Server) Method: Player:Give\n\nGive the player a weapon"
  },
  "Player:GiveAmmo": {
    "prefix": "GiveAmmo",
    "body": "GiveAmmo(${1:number amount}, ${2:string type}, ${3:boolean hidePopup=false})$0",
    "description": "(Server) Method: Player:GiveAmmo\n\nGives ammo to a player"
  },
  "Player:GodDisable": {
    "prefix": "GodDisable",
    "body": "GodDisable()$0",
    "description": "(Server) Method: Player:GodDisable\n\nDisables god mode on the player."
  },
  "Player:GodEnable": {
    "prefix": "GodEnable",
    "body": "GodEnable()$0",
    "description": "(Server) Method: Player:GodEnable\n\nEnables god mode on the player."
  },
  "Player:HasGodMode": {
    "prefix": "HasGodMode",
    "body": "HasGodMode()$0",
    "description": "(Shared) Method: Player:HasGodMode\n\nReturns whether the player has god mode or not, contolled by Player.GodEnable and Player.GodDisable."
  },
  "Player:HasWeapon": {
    "prefix": "HasWeapon",
    "body": "HasWeapon(${1:string className})$0",
    "description": "(Shared) Method: Player:HasWeapon\n\nReturns if the player has the specified weapon"
  },
  "Player:InVehicle": {
    "prefix": "InVehicle",
    "body": "InVehicle()$0",
    "description": "(Shared) Method: Player:InVehicle\n\nReturns if the player is in a vehicle"
  },
  "Player:IPAddress": {
    "prefix": "IPAddress",
    "body": "IPAddress()$0",
    "description": "(Server) Method: Player:IPAddress\n\nReturns the player's IP address and connection port in ip:port form"
  },
  "Player:IsAdmin": {
    "prefix": "IsAdmin",
    "body": "IsAdmin()$0",
    "description": "(Shared) Method: Player:IsAdmin\n\nReturns whether the player is an admin or not"
  },
  "Player:IsBot": {
    "prefix": "IsBot",
    "body": "IsBot()$0",
    "description": "(Shared) Method: Player:IsBot\n\nReturns if the player is an bot or not"
  },
  "Player:IsConnected": {
    "prefix": "IsConnected",
    "body": "IsConnected()$0",
    "description": "(Server) Method: Player:IsConnected\n\nReturns true from the point when the player is sending client info but not fully in the game until they disconnect."
  },
  "Player:IsDrivingEntity": {
    "prefix": "IsDrivingEntity",
    "body": "IsDrivingEntity()$0",
    "description": "(Shared) Method: Player:IsDrivingEntity\n\nUsed to find out if a player is currently 'driving' an entity (by which we mean 'right click > drive' )."
  },
  "Player:IsFrozen": {
    "prefix": "IsFrozen",
    "body": "IsFrozen()$0",
    "description": "(Shared) Method: Player:IsFrozen\n\nReturns whether the players movement is currently frozen, contolled by Player.Freeze."
  },
  "Player:IsFullyAuthenticated": {
    "prefix": "IsFullyAuthenticated",
    "body": "IsFullyAuthenticated()$0",
    "description": "(Server) Method: Player:IsFullyAuthenticated\n\nReturns whether the player identity was confirmed by the steam network."
  },
  "Player:IsListenServerHost": {
    "prefix": "IsListenServerHost",
    "body": "IsListenServerHost()$0",
    "description": "(Server) Method: Player:IsListenServerHost\n\nReturns if a player is the host of the current session."
  },
  "Player:IsMuted": {
    "prefix": "IsMuted",
    "body": "IsMuted()$0",
    "description": "(Client) Method: Player:IsMuted\n\nReturns whether or not the player is muted locally."
  },
  "Player:IsPlayingTaunt": {
    "prefix": "IsPlayingTaunt",
    "body": "IsPlayingTaunt()$0",
    "description": "(Shared) Method: Player:IsPlayingTaunt\n\nReturns true if the player is playing a taunt."
  },
  "Player:IsSpeaking": {
    "prefix": "IsSpeaking",
    "body": "IsSpeaking()$0",
    "description": "(Client) Method: Player:IsSpeaking\n\nReturns whenever the player is heard by the local player."
  },
  "Player:IsSuitEquipped": {
    "prefix": "IsSuitEquipped",
    "body": "IsSuitEquipped()$0",
    "description": "(Shared) Method: Player:IsSuitEquipped\n\nReturns whenever the player is equipped with the suit item."
  },
  "Player:IsSuperAdmin": {
    "prefix": "IsSuperAdmin",
    "body": "IsSuperAdmin()$0",
    "description": "(Shared) Method: Player:IsSuperAdmin\n\nReturns whether the player is a superadmin."
  },
  "Player:IsTimingOut": {
    "prefix": "IsTimingOut",
    "body": "IsTimingOut()$0",
    "description": "(Server) Method: Player:IsTimingOut\n\nReturns true if the player is timing out (i.e. is losing connection), false otherwise."
  },
  "Player:IsTyping": {
    "prefix": "IsTyping",
    "body": "IsTyping()$0",
    "description": "(Shared) Method: Player:IsTyping\n\nReturns whether the player is typing in their chat."
  },
  "Player:IsUserGroup": {
    "prefix": "IsUserGroup",
    "body": "IsUserGroup(${1:string groupname})$0",
    "description": "(Shared) Method: Player:IsUserGroup\n\nReturns true/false if the player is in specified group or not."
  },
  "Player:IsVoiceAudible": {
    "prefix": "IsVoiceAudible",
    "body": "IsVoiceAudible()$0",
    "description": "(Client) Method: Player:IsVoiceAudible\n\nReturns if the player can be heard by the local player."
  },
  "Player:IsWorldClicking": {
    "prefix": "IsWorldClicking",
    "body": "IsWorldClicking()$0",
    "description": "(Shared) Method: Player:IsWorldClicking\n\nReturns if the player is in the context menu."
  },
  "Player:KeyDown": {
    "prefix": "KeyDown",
    "body": "KeyDown(${1:number key})$0",
    "description": "(Shared) Method: Player:KeyDown\n\nGets whether a key is down. This is not networked to other players, meaning only the local client can see the keys they are pressing."
  },
  "Player:KeyDownLast": {
    "prefix": "KeyDownLast",
    "body": "KeyDownLast(${1:number key})$0",
    "description": "(Shared) Method: Player:KeyDownLast\n\nGets whether a key was down one tick ago."
  },
  "Player:KeyPressed": {
    "prefix": "KeyPressed",
    "body": "KeyPressed(${1:number key})$0",
    "description": "(Shared) Method: Player:KeyPressed\n\nGets whether a key was just pressed this tick"
  },
  "Player:KeyReleased": {
    "prefix": "KeyReleased",
    "body": "KeyReleased(${1:number key})$0",
    "description": "(Shared) Method: Player:KeyReleased\n\nGets whether a key was just released this tick"
  },
  "Player:Kick": {
    "prefix": "Kick",
    "body": "Kick(${1:string reason=\"No reason given\"})$0",
    "description": "(Server) Method: Player:Kick\n\nKicks the player from the server."
  },
  "Player:Kill": {
    "prefix": "Kill",
    "body": "Kill()$0",
    "description": "(Server) Method: Player:Kill\n\nKills a player and calls GM.PlayerDeath."
  },
  "Player:KillSilent": {
    "prefix": "KillSilent",
    "body": "KillSilent()$0",
    "description": "(Server) Method: Player:KillSilent\n\nKills a player without notifying the rest of the server."
  },
  "Player:LagCompensation": {
    "prefix": "LagCompensation",
    "body": "LagCompensation(${1:boolean lagCompensation})$0",
    "description": "(Shared) Method: Player:LagCompensation\n\nThis allows the server to mitigate the lag of the player by moving back all the entities that can be lag compensated to the time the player attacked with his weapon."
  },
  "Player:LastHitGroup": {
    "prefix": "LastHitGroup",
    "body": "LastHitGroup()$0",
    "description": "(Server) Method: Player:LastHitGroup\n\nReturns the hitgroup where the player was last hit."
  },
  "Player:LimitHit": {
    "prefix": "LimitHit",
    "body": "LimitHit(${1:string type})$0",
    "description": "(Shared) Method: Player:LimitHit\n\nShows \"limit hit\" notification in sandbox."
  },
  "Player:Lock": {
    "prefix": "Lock",
    "body": "Lock()$0",
    "description": "(Server) Method: Player:Lock\n\nStops a player from using any inputs, such as moving and shooting. Similar to Player.Freeze but the player remains frozen/locked after death."
  },
  "Player:MotionSensorPos": {
    "prefix": "MotionSensorPos",
    "body": "MotionSensorPos(${1:number bone})$0",
    "description": "(Shared) Method: Player:MotionSensorPos\n\nReturns the position of a Kinect bone."
  },
  "Player:Name": {
    "prefix": "Name",
    "body": "Name()$0",
    "description": "(Shared) Method: Player:Name\n\nReturns the players name. Identical to Player.Nick and Player.GetName"
  },
  "Player:Nick": {
    "prefix": "Nick",
    "body": "Nick()$0",
    "description": "(Shared) Method: Player:Nick\n\nReturns the player's nickname"
  },
  "Player:PacketLoss": {
    "prefix": "PacketLoss",
    "body": "PacketLoss()$0",
    "description": "(Server) Method: Player:PacketLoss\n\nReturns the packet loss of the client. It is not networked so it only returns 0 when run clientside."
  },
  "Player:PhysgunUnfreeze": {
    "prefix": "PhysgunUnfreeze",
    "body": "PhysgunUnfreeze()$0",
    "description": "(Shared) Method: Player:PhysgunUnfreeze\n\nUnfreezes the props player is looking at. This is essentially the same as pressing reload with the physics gun, including double press for unfreeze all."
  },
  "Player:PickupObject": {
    "prefix": "PickupObject",
    "body": "PickupObject(${1:Entity entity})$0",
    "description": "(Server) Method: Player:PickupObject\n\nThis makes the player hold ( same as pressing Key.E on a small prop ) the provided entity."
  },
  "Player:Ping": {
    "prefix": "Ping",
    "body": "Ping()$0",
    "description": "(Shared) Method: Player:Ping\n\nReturns the player's ping to server."
  },
  "Player:PlayStepSound": {
    "prefix": "PlayStepSound",
    "body": "PlayStepSound(${1:number volume})$0",
    "description": "(Server) Method: Player:PlayStepSound\n\nPlays the correct step sound according to what the player is staying on."
  },
  "Player:PrintMessage": {
    "prefix": "PrintMessage",
    "body": "PrintMessage(${1:number type}, ${2:string message})$0",
    "description": "(Shared) Method: Player:PrintMessage\n\nDisplays a message either in their chat, console, or center of the screen. See also _G.PrintMessage."
  },
  "Player:RemoveAllAmmo": {
    "prefix": "RemoveAllAmmo",
    "body": "RemoveAllAmmo()$0",
    "description": "(Server) Method: Player:RemoveAllAmmo\n\nRemoves all ammo from a certain player"
  },
  "Player:RemoveAllItems": {
    "prefix": "RemoveAllItems",
    "body": "RemoveAllItems()$0",
    "description": "(Server) Method: Player:RemoveAllItems\n\nRemoves all weapons and ammonition from the player."
  },
  "Player:RemoveAmmo": {
    "prefix": "RemoveAmmo",
    "body": "RemoveAmmo(${1:number ammoCount}, ${2:string ammoName})$0",
    "description": "(Shared) Method: Player:RemoveAmmo\n\nRemoves the amount of the specified ammo from the player."
  },
  "Player:RemovePData": {
    "prefix": "RemovePData",
    "body": "RemovePData(${1:any key})$0",
    "description": "(Shared) Method: Player:RemovePData\n\nDeletes a key from a player's data"
  },
  "Player:RemoveSuit": {
    "prefix": "RemoveSuit",
    "body": "RemoveSuit()$0",
    "description": "(Server) Method: Player:RemoveSuit\n\nStrips the player's suit item."
  },
  "Player:ResetHull": {
    "prefix": "ResetHull",
    "body": "ResetHull()$0",
    "description": "(Shared) Method: Player:ResetHull\n\nResets both normal and duck hulls to their default values."
  },
  "Player:Say": {
    "prefix": "Say",
    "body": "Say(${1:string text}, ${2:boolean teamOnly=false})$0",
    "description": "(Server) Method: Player:Say\n\nForces the player to say whatever the first argument is. Works on bots too."
  },
  "Player:ScreenFade": {
    "prefix": "ScreenFade",
    "body": "ScreenFade(${1:number flags}, ${2:number clr=color_white}, ${3:number fadeTime}, ${4:number fadeHold})$0",
    "description": "(Shared) Method: Player:ScreenFade\n\nFades the screen"
  },
  "Player:SelectWeapon": {
    "prefix": "SelectWeapon",
    "body": "SelectWeapon(${1:string className})$0",
    "description": "(Server) Method: Player:SelectWeapon\n\nSets the active weapon of the player by its class name."
  },
  "Player:SendHint": {
    "prefix": "SendHint",
    "body": "SendHint(${1:string name}, ${2:number delay})$0",
    "description": "(Server) Method: Player:SendHint\n\nSends a hint to a player."
  },
  "Player:SendLua": {
    "prefix": "SendLua",
    "body": "SendLua(${1:string script})$0",
    "description": "(Server) Method: Player:SendLua\n\nExecutes a simple Lua string on the player. "
  },
  "Player:SetActiveWeapon": {
    "prefix": "SetActiveWeapon",
    "body": "SetActiveWeapon(${1:Weapon weapon})$0",
    "description": "(Server) Method: Player:SetActiveWeapon\n\nSets the player's active weapon."
  },
  "Player:SetAllowFullRotation": {
    "prefix": "SetAllowFullRotation",
    "body": "SetAllowFullRotation(${1:boolean Allowed})$0",
    "description": "(Shared) Method: Player:SetAllowFullRotation\n\nSet if the players' model is allowed to rotate around the pitch and roll axis."
  },
  "Player:SetAllowWeaponsInVehicle": {
    "prefix": "SetAllowWeaponsInVehicle",
    "body": "SetAllowWeaponsInVehicle(${1:boolean allow})$0",
    "description": "(Server) Method: Player:SetAllowWeaponsInVehicle\n\nAllows player to use his weapons in a vehicle. You need to call this before entering a vehicle."
  },
  "Player:SetAmmo": {
    "prefix": "SetAmmo",
    "body": "SetAmmo(${1:number ammoCount}, ${2:any ammoType})$0",
    "description": "(Shared) Method: Player:SetAmmo\n\nSets the amount of the specified ammo for the player."
  },
  "Player:SetArmor": {
    "prefix": "SetArmor",
    "body": "SetArmor(${1:number Amount})$0",
    "description": "(Server) Method: Player:SetArmor\n\nSets the player armor to the argument."
  },
  "Player:SetAvoidPlayers": {
    "prefix": "SetAvoidPlayers",
    "body": "SetAvoidPlayers(${1:boolean avoidPlayers})$0",
    "description": "(Shared) Method: Player:SetAvoidPlayers\n\nPushes the player away from another player whenever it's inside the other players bounding box."
  },
  "Player:SetCanWalk": {
    "prefix": "SetCanWalk",
    "body": "SetCanWalk(${1:boolean abletowalk})$0",
    "description": "(Shared) Method: Player:SetCanWalk\n\nSet if the player should be allowed to walk using the (default) alt key."
  },
  "Player:SetCanZoom": {
    "prefix": "SetCanZoom",
    "body": "SetCanZoom(${1:boolean canZoom})$0",
    "description": "(Server) Method: Player:SetCanZoom\n\nSets whether the player can use the HL2 suit zoom (\" zoom\" bind) or not."
  },
  "Player:SetClassID": {
    "prefix": "SetClassID",
    "body": "SetClassID(${1:number classID})$0",
    "description": "(Shared) Method: Player:SetClassID\n\nSets the player's class id."
  },
  "Player:SetCrouchedWalkSpeed": {
    "prefix": "SetCrouchedWalkSpeed",
    "body": "SetCrouchedWalkSpeed(${1:number speed})$0",
    "description": "(Shared) Method: Player:SetCrouchedWalkSpeed\n\nSets the crouched walk speed multiplier."
  },
  "Player:SetCurrentViewOffset": {
    "prefix": "SetCurrentViewOffset",
    "body": "SetCurrentViewOffset(${1:Vector viewOffset})$0",
    "description": "(Shared) Method: Player:SetCurrentViewOffset\n\nSets the '''actual''' view offset which equals the difference between the players actual position and their view when standing."
  },
  "Player:SetDeaths": {
    "prefix": "SetDeaths",
    "body": "SetDeaths(${1:number deathcount})$0",
    "description": "(Server) Method: Player:SetDeaths\n\nSets a player's death count"
  },
  "Player:SetDrivingEntity": {
    "prefix": "SetDrivingEntity",
    "body": "SetDrivingEntity(${1:Entity drivingEntity=NULL}, ${2:number drivingMode})$0",
    "description": "(Shared) Method: Player:SetDrivingEntity\n\n[Internal] "
  },
  "Player:SetDSP": {
    "prefix": "SetDSP",
    "body": "SetDSP(${1:number soundFilter}, ${2:boolean fastReset})$0",
    "description": "(Shared) Method: Player:SetDSP\n\nApplies the specified sound filter to the player."
  },
  "Player:SetDuckSpeed": {
    "prefix": "SetDuckSpeed",
    "body": "SetDuckSpeed(${1:number duckSpeed})$0",
    "description": "(Shared) Method: Player:SetDuckSpeed\n\nSets how quickly a player ducks."
  },
  "Player:SetEyeAngles": {
    "prefix": "SetEyeAngles",
    "body": "SetEyeAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: Player:SetEyeAngles\n\nSets the angle of the player's view (may rotate body too if angular difference is large)"
  },
  "Player:SetFOV": {
    "prefix": "SetFOV",
    "body": "SetFOV(${1:number fov}, ${2:number time})$0",
    "description": "(Shared) Method: Player:SetFOV\n\nSet a player's FOV (Field Of View) over a certain amount of time."
  },
  "Player:SetFrags": {
    "prefix": "SetFrags",
    "body": "SetFrags(${1:number fragcount})$0",
    "description": "(Server) Method: Player:SetFrags\n\nSets a player's frags (kills)"
  },
  "Player:SetHands": {
    "prefix": "SetHands",
    "body": "SetHands(${1:Entity hands})$0",
    "description": "(Shared) Method: Player:SetHands\n\nSets the hands entity of a player."
  },
  "Player:SetHoveredWidget": {
    "prefix": "SetHoveredWidget",
    "body": "SetHoveredWidget(${1:Entity widget=NULL})$0",
    "description": "(Shared) Method: Player:SetHoveredWidget\n\nSets the widget that is currently hovered by the player's mouse."
  },
  "Player:SetHull": {
    "prefix": "SetHull",
    "body": "SetHull(${1:Vector hullMins}, ${2:Vector hullMaxs})$0",
    "description": "(Shared) Method: Player:SetHull\n\nSets the mins and maxs of the AABB of the players collision."
  },
  "Player:SetHullDuck": {
    "prefix": "SetHullDuck",
    "body": "SetHullDuck(${1:Vector hullMins}, ${2:Vector hullMaxs})$0",
    "description": "(Shared) Method: Player:SetHullDuck\n\nSets the mins and maxs of the AABB of the players collision when ducked."
  },
  "Player:SetJumpPower": {
    "prefix": "SetJumpPower",
    "body": "SetJumpPower(${1:number jumpPower})$0",
    "description": "(Shared) Method: Player:SetJumpPower\n\nSets the jump power, eg. the velocity the player will applied to when he jumps."
  },
  "Player:SetLaggedMovementValue": {
    "prefix": "SetLaggedMovementValue",
    "body": "SetLaggedMovementValue(${1:number timescale})$0",
    "description": "(Server) Method: Player:SetLaggedMovementValue\n\nSlows down the player movement simulation by the timescale, this is used internally in the HL2 weapon stripping sequence."
  },
  "Player:SetMaxSpeed": {
    "prefix": "SetMaxSpeed",
    "body": "SetMaxSpeed(${1:number walkSpeed})$0",
    "description": "(Shared) Method: Player:SetMaxSpeed\n\nSets the maximum speed which the player can move at."
  },
  "Player:SetMuted": {
    "prefix": "SetMuted",
    "body": "SetMuted(${1:boolean mute})$0",
    "description": "(Client) Method: Player:SetMuted\n\nSets if the player should be muted locally."
  },
  "Player:SetNoCollideWithTeammates": {
    "prefix": "SetNoCollideWithTeammates",
    "body": "SetNoCollideWithTeammates(${1:boolean shouldNotCollide})$0",
    "description": "(Server) Method: Player:SetNoCollideWithTeammates\n\nSets whenever the player should not collide with their teammates."
  },
  "Player:SetNoTarget": {
    "prefix": "SetNoTarget",
    "body": "SetNoTarget(${1:boolean visibility})$0",
    "description": "(Server) Method: Player:SetNoTarget\n\nSets the players visibility towards NPCs."
  },
  "Player:SetObserverMode": {
    "prefix": "SetObserverMode",
    "body": "SetObserverMode(${1:number observeMode})$0",
    "description": "(Shared) Method: Player:SetObserverMode\n\nSets the players observer mode."
  },
  "Player:SetPData": {
    "prefix": "SetPData",
    "body": "SetPData(${1:any key}, ${2:any value})$0",
    "description": "(Shared) Method: Player:SetPData\n\nSets a player's PData from the server's or client's SQL database ( sv.db and cl.db respectively ), It is not networked!"
  },
  "Player:SetPlayerColor": {
    "prefix": "SetPlayerColor",
    "body": "SetPlayerColor(${1:Vector Color})$0",
    "description": "(Shared) Method: Player:SetPlayerColor\n\nSets the player model's color. The part of the model that is colored is determined by the model itself, and is different for each model."
  },
  "Player:SetPressedWidget": {
    "prefix": "SetPressedWidget",
    "body": "SetPressedWidget(${1:Entity pressedWidget=NULL})$0",
    "description": "(Shared) Method: Player:SetPressedWidget\n\nSets the widget that is currently in use by the player's mouse."
  },
  "Player:SetRenderAngles": {
    "prefix": "SetRenderAngles",
    "body": "SetRenderAngles(${1:Angle ang})$0",
    "description": "(Shared) Method: Player:SetRenderAngles\n\nSets the render angles of a player."
  },
  "Player:SetRunSpeed": {
    "prefix": "SetRunSpeed",
    "body": "SetRunSpeed(${1:number runSpeed})$0",
    "description": "(Shared) Method: Player:SetRunSpeed\n\nSets the run speed eg. the speed when sprinting."
  },
  "Player:SetStepSize": {
    "prefix": "SetStepSize",
    "body": "SetStepSize(${1:number stepHeight})$0",
    "description": "(Shared) Method: Player:SetStepSize\n\nSets the maximum height a player can step onto without jumping."
  },
  "Player:SetSuppressPickupNotices": {
    "prefix": "SetSuppressPickupNotices",
    "body": "SetSuppressPickupNotices(${1:boolean doSuppress})$0",
    "description": "(Shared) Method: Player:SetSuppressPickupNotices\n\nSets whenever to suppress the pickup notification for the player."
  },
  "Player:SetTeam": {
    "prefix": "SetTeam",
    "body": "SetTeam(${1:number Team})$0",
    "description": "(Server) Method: Player:SetTeam\n\nSets the player to the chosen team."
  },
  "Player:SetUnDuckSpeed": {
    "prefix": "SetUnDuckSpeed",
    "body": "SetUnDuckSpeed(${1:number UnDuckSpeed})$0",
    "description": "(Shared) Method: Player:SetUnDuckSpeed\n\nSets how quickly a player un-ducks"
  },
  "Player:SetupHands": {
    "prefix": "SetupHands",
    "body": "SetupHands(${1:Entity ent})$0",
    "description": "(Server) Method: Player:SetupHands\n\nSets up the players view model hands. Calls GM.PlayerSetHandsModel to set the model of the hands."
  },
  "Player:SetUserGroup": {
    "prefix": "SetUserGroup",
    "body": "SetUserGroup(${1:string groupName})$0",
    "description": "(Server) Method: Player:SetUserGroup\n\nSets the usergroup of the player."
  },
  "Player:SetViewEntity": {
    "prefix": "SetViewEntity",
    "body": "SetViewEntity(${1:Entity viewEntity})$0",
    "description": "(Server) Method: Player:SetViewEntity\n\nAttaches the players view to the position and angles of the specified entity."
  },
  "Player:SetViewOffset": {
    "prefix": "SetViewOffset",
    "body": "SetViewOffset(${1:Vector viewOffset})$0",
    "description": "(Shared) Method: Player:SetViewOffset\n\nSets the '''desired''' view offset which equals the difference between the players actual position and their view when standing."
  },
  "Player:SetViewOffsetDucked": {
    "prefix": "SetViewOffsetDucked",
    "body": "SetViewOffsetDucked(${1:Vector viewOffset})$0",
    "description": "(Shared) Method: Player:SetViewOffsetDucked\n\nSets the '''desired''' view offset which equals the difference between the players actual position and their view when crouching."
  },
  "Player:SetViewPunchAngles": {
    "prefix": "SetViewPunchAngles",
    "body": "SetViewPunchAngles(${1:Angle punchAngle})$0",
    "description": "(Shared) Method: Player:SetViewPunchAngles\n\nSets client's view punch. See Player.ViewPunch"
  },
  "Player:SetWalkSpeed": {
    "prefix": "SetWalkSpeed",
    "body": "SetWalkSpeed(${1:number walkSpeed})$0",
    "description": "(Shared) Method: Player:SetWalkSpeed\n\nSets the walk speed eg. the speed when normally walking."
  },
  "Player:SetWeaponColor": {
    "prefix": "SetWeaponColor",
    "body": "SetWeaponColor(${1:Vector Color})$0",
    "description": "(Shared) Method: Player:SetWeaponColor\n\nSets the player weapon's color. The part of the model that is colored is determined by the model itself, and is different for each model."
  },
  "Player:ShouldDrawLocalPlayer": {
    "prefix": "ShouldDrawLocalPlayer",
    "body": "ShouldDrawLocalPlayer()$0",
    "description": "(Client) Method: Player:ShouldDrawLocalPlayer\n\nPolls the engine to request if the player should be drawn at the time the function is called."
  },
  "Player:ShouldDropWeapon": {
    "prefix": "ShouldDropWeapon",
    "body": "ShouldDropWeapon(${1:boolean drop})$0",
    "description": "(Server) Method: Player:ShouldDropWeapon\n\nSets whether the player's current weapon should drop on death."
  },
  "Player:ShowProfile": {
    "prefix": "ShowProfile",
    "body": "ShowProfile()$0",
    "description": "(Client) Method: Player:ShowProfile\n\nOpens the player steam profile page in the steam overlay browser."
  },
  "Player:SimulateGravGunDrop": {
    "prefix": "SimulateGravGunDrop",
    "body": "SimulateGravGunDrop(${1:Entity ent})$0",
    "description": "(Server) Method: Player:SimulateGravGunDrop\n\nSignals the entity that it was dropped by the gravity gun. "
  },
  "Player:SimulateGravGunPickup": {
    "prefix": "SimulateGravGunPickup",
    "body": "SimulateGravGunPickup(${1:Entity ent})$0",
    "description": "(Server) Method: Player:SimulateGravGunPickup\n\nSignals the entity that it was picked up by the gravity gun. This call is only required if you want to simulate the situation of picking up objects."
  },
  "Player:Spectate": {
    "prefix": "Spectate",
    "body": "Spectate(${1:number spectateMode})$0",
    "description": "(Server) Method: Player:Spectate\n\nSets the spectate mode of the player."
  },
  "Player:SpectateEntity": {
    "prefix": "SpectateEntity",
    "body": "SpectateEntity(${1:Entity entity})$0",
    "description": "(Server) Method: Player:SpectateEntity\n\nMakes the player spectate the entity"
  },
  "Player:SprayDecal": {
    "prefix": "SprayDecal",
    "body": "SprayDecal(${1:Vector sprayOrigin}, ${2:Vector sprayEndPos})$0",
    "description": "(Server) Method: Player:SprayDecal\n\nMakes a player spray their decal."
  },
  "Player:SprintDisable": {
    "prefix": "SprintDisable",
    "body": "SprintDisable()$0",
    "description": "(Server) Method: Player:SprintDisable\n\nDisables the sprint on the player. Not working! Use Player.SetRunSpeed instead."
  },
  "Player:SprintEnable": {
    "prefix": "SprintEnable",
    "body": "SprintEnable()$0",
    "description": "(Server) Method: Player:SprintEnable\n\nEnables the sprint on the player. Not working! Use Player.SetRunSpeed instead."
  },
  "Player:StartSprinting": {
    "prefix": "StartSprinting",
    "body": "StartSprinting()$0",
    "description": "(Shared) Method: Player:StartSprinting\n\nStubCurrently does nothing"
  },
  "Player:StartWalking": {
    "prefix": "StartWalking",
    "body": "StartWalking()$0",
    "description": "(Shared) Method: Player:StartWalking\n\nStubCurrently does nothing"
  },
  "Player:SteamID": {
    "prefix": "SteamID",
    "body": "SteamID()$0",
    "description": "(Shared) Method: Player:SteamID\n\nReturns the player's SteamID. In singleplayer, this will be STEAM_ID_PENDING serverside."
  },
  "Player:SteamID64": {
    "prefix": "SteamID64",
    "body": "SteamID64()$0",
    "description": "(Shared) Method: Player:SteamID64\n\nReturns the player's 64bit SteamID aka CommunityID."
  },
  "Player:StopSprinting": {
    "prefix": "StopSprinting",
    "body": "StopSprinting()$0",
    "description": "(Shared) Method: Player:StopSprinting\n\nStubCurrently does nothing"
  },
  "Player:StopWalking": {
    "prefix": "StopWalking",
    "body": "StopWalking()$0",
    "description": "(Shared) Method: Player:StopWalking\n\nStubCurrently does nothing"
  },
  "Player:StopZooming": {
    "prefix": "StopZooming",
    "body": "StopZooming()$0",
    "description": "(Server) Method: Player:StopZooming\n\nTurns off the zoom mode of the player."
  },
  "Player:StripAmmo": {
    "prefix": "StripAmmo",
    "body": "StripAmmo()$0",
    "description": "(Server) Method: Player:StripAmmo\n\nRemoves all ammo from the player."
  },
  "Player:StripWeapon": {
    "prefix": "StripWeapon",
    "body": "StripWeapon(${1:string weapon})$0",
    "description": "(Server) Method: Player:StripWeapon\n\nRemoves the specified weapon class from a certain player"
  },
  "Player:StripWeapons": {
    "prefix": "StripWeapons",
    "body": "StripWeapons()$0",
    "description": "(Server) Method: Player:StripWeapons\n\nRemoves all weapons from a certain player"
  },
  "Player:SuppressHint": {
    "prefix": "SuppressHint",
    "body": "SuppressHint(${1:string name})$0",
    "description": "(Server) Method: Player:SuppressHint\n\nPrevents a hint from showing up."
  },
  "Player:SwitchToDefaultWeapon": {
    "prefix": "SwitchToDefaultWeapon",
    "body": "SwitchToDefaultWeapon()$0",
    "description": "(Server) Method: Player:SwitchToDefaultWeapon\n\nAttempts to switch the player weapon to the one specified in the \"cl_defaultweapon\" convar, if the player does not own the specified weapon nothing will happen."
  },
  "Player:Team": {
    "prefix": "Team",
    "body": "Team()$0",
    "description": "(Shared) Method: Player:Team\n\nReturns the player's team ID."
  },
  "Player:TimeConnected": {
    "prefix": "TimeConnected",
    "body": "TimeConnected()$0",
    "description": "(Server) Method: Player:TimeConnected\n\nReturns the time in second since the player connected."
  },
  "Player:TraceHullAttack": {
    "prefix": "TraceHullAttack",
    "body": "TraceHullAttack(${1:Vector startPos}, ${2:Vector endPos}, ${3:Vector mins}, ${4:Vector maxs}, ${5:number damage}, ${6:Vector damageFlags}, ${7:number damageForce}, ${8:boolean damageAllNPCs})$0",
    "description": "(Server) Method: Player:TraceHullAttack\n\nPerforms a trace hull and applies damage to the entities hit, returns the first entity hit."
  },
  "Player:TranslateWeaponActivity": {
    "prefix": "TranslateWeaponActivity",
    "body": "TranslateWeaponActivity(${1:number act})$0",
    "description": "(Shared) Method: Player:TranslateWeaponActivity\n\nTranslates Enum.ACT according to the holdtype of players currently held weapon."
  },
  "Player:UnfreezePhysicsObjects": {
    "prefix": "UnfreezePhysicsObjects",
    "body": "UnfreezePhysicsObjects()$0",
    "description": "(Shared) Method: Player:UnfreezePhysicsObjects\n\nUnfreezes all objects the player has frozen with their Physics Gun. Same as double pressing R while holding Physics Gun."
  },
  "Player:UniqueID": {
    "prefix": "UniqueID",
    "body": "UniqueID()$0",
    "description": "(Shared) Method: Player:UniqueID\n\nWarning.'''This function has collisions,''' where more than one player has the same UniqueID. It is '''highly''' recommended to use Player.AccountID, Player.SteamID or Player.SteamID64 instead, which are guaranteed to be unique to each player."
  },
  "Player:UniqueIDTable": {
    "prefix": "UniqueIDTable",
    "body": "UniqueIDTable(${1:any key})$0",
    "description": "(Shared) Method: Player:UniqueIDTable\n\nReturns a table that will stay allocated for the specific player between connects until the server shuts down. Note, that this table is not synchronized between client and server."
  },
  "Player:UnLock": {
    "prefix": "UnLock",
    "body": "UnLock()$0",
    "description": "(Server) Method: Player:UnLock\n\nUnlocks the player movement if locked previously. "
  },
  "Player:UnSpectate": {
    "prefix": "UnSpectate",
    "body": "UnSpectate()$0",
    "description": "(Server) Method: Player:UnSpectate\n\nStops the player from spectating another entity."
  },
  "Player:UserID": {
    "prefix": "UserID",
    "body": "UserID()$0",
    "description": "(Shared) Method: Player:UserID\n\nReturns the player's ID."
  },
  "Player:ViewPunch": {
    "prefix": "ViewPunch",
    "body": "ViewPunch(${1:Angle PunchAngle})$0",
    "description": "(Shared) Method: Player:ViewPunch\n\nSimulates a push on the client's screen."
  },
  "Player:ViewPunchReset": {
    "prefix": "ViewPunchReset",
    "body": "ViewPunchReset(${1:number tolerance=0})$0",
    "description": "(Shared) Method: Player:ViewPunchReset\n\nResets the player's view punch ( Player.ViewPunch ) effect back to normal."
  },
  "Player:VoiceVolume": {
    "prefix": "VoiceVolume",
    "body": "VoiceVolume()$0",
    "description": "(Client) Method: Player:VoiceVolume\n\nReturns the players voice volume as a normal number. Doesn't work on local player unless the voice_loopback convar is set to 1."
  },
  "ProjectedTexture:GetAngles": {
    "prefix": "GetAngles",
    "body": "GetAngles()$0",
    "description": "(Client) Method: ProjectedTexture:GetAngles\n\nReturns the angle of the ProjectedTexture, which were previously set by ProjectedTexture.SetAngles"
  },
  "ProjectedTexture:GetBrightness": {
    "prefix": "GetBrightness",
    "body": "GetBrightness()$0",
    "description": "(Client) Method: ProjectedTexture:GetBrightness\n\nReturns the brightness of the ProjectedTexture, which was previously set by ProjectedTexture.SetBrightness"
  },
  "ProjectedTexture:GetColor": {
    "prefix": "GetColor",
    "body": "GetColor()$0",
    "description": "(Client) Method: ProjectedTexture:GetColor\n\nReturns the color of the ProjectedTexture, which was previously set by ProjectedTexture.SetColor"
  },
  "ProjectedTexture:GetEnableShadows": {
    "prefix": "GetEnableShadows",
    "body": "GetEnableShadows()$0",
    "description": "(Client) Method: ProjectedTexture:GetEnableShadows\n\nReturns whether shadows are enabled for this ProjectedTexture, which was previously set by ProjectedTexture.SetEnableShadows"
  },
  "ProjectedTexture:GetFarZ": {
    "prefix": "GetFarZ",
    "body": "GetFarZ()$0",
    "description": "(Client) Method: ProjectedTexture:GetFarZ\n\nReturns the projection distance of the ProjectedTexture, which was previously set by ProjectedTexture.SetFarZ"
  },
  "ProjectedTexture:GetHorizontalFOV": {
    "prefix": "GetHorizontalFOV",
    "body": "GetHorizontalFOV()$0",
    "description": "(Client) Method: ProjectedTexture:GetHorizontalFOV\n\nReturns the horizontal FOV of the ProjectedTexture, which was previously set by ProjectedTexture.SetHorizontalFOV or ProjectedTexture.SetFOV"
  },
  "ProjectedTexture:GetNearZ": {
    "prefix": "GetNearZ",
    "body": "GetNearZ()$0",
    "description": "(Client) Method: ProjectedTexture:GetNearZ\n\nReturns the NearZ value of the ProjectedTexture, which was previously set by ProjectedTexture.SetNearZ"
  },
  "ProjectedTexture:GetOrthographic": {
    "prefix": "GetOrthographic",
    "body": "GetOrthographic()$0",
    "description": "(Client) Method: ProjectedTexture:GetOrthographic\n\nReturns the current orthographic settings of the Projected Texture. To set these values, use ProjectedTexture.SetOrthographic."
  },
  "ProjectedTexture:GetPos": {
    "prefix": "GetPos",
    "body": "GetPos()$0",
    "description": "(Client) Method: ProjectedTexture:GetPos\n\nReturns the position of the ProjectedTexture, which was previously set by ProjectedTexture.SetPos"
  },
  "ProjectedTexture:GetTexture": {
    "prefix": "GetTexture",
    "body": "GetTexture()$0",
    "description": "(Client) Method: ProjectedTexture:GetTexture\n\nReturns the texture of the ProjectedTexture, which was previously set by ProjectedTexture.SetTexture"
  },
  "ProjectedTexture:GetTextureFrame": {
    "prefix": "GetTextureFrame",
    "body": "GetTextureFrame()$0",
    "description": "(Client) Method: ProjectedTexture:GetTextureFrame\n\nReturns the texture frame of the ProjectedTexture, which was previously set by ProjectedTexture.SetTextureFrame"
  },
  "ProjectedTexture:GetVerticalFOV": {
    "prefix": "GetVerticalFOV",
    "body": "GetVerticalFOV()$0",
    "description": "(Client) Method: ProjectedTexture:GetVerticalFOV\n\nReturns the vertical FOV of the ProjectedTexture, which was previously set by ProjectedTexture.SetVerticalFOV or ProjectedTexture.SetFOV"
  },
  "ProjectedTexture:IsValid": {
    "prefix": "IsValid",
    "body": "IsValid()$0",
    "description": "(Client) Method: ProjectedTexture:IsValid\n\nReturns true if the projected texture is valid (i.e. has not been removed), false otherwise."
  },
  "ProjectedTexture:Remove": {
    "prefix": "Remove",
    "body": "Remove()$0",
    "description": "(Client) Method: ProjectedTexture:Remove\n\nRemoves the projected texture. After calling this, ProjectedTexture.IsValid will return false, and any hooks with the projected texture as the identifier will be automatically deleted."
  },
  "ProjectedTexture:SetAngles": {
    "prefix": "SetAngles",
    "body": "SetAngles(${1:Angle angle})$0",
    "description": "(Client) Method: ProjectedTexture:SetAngles\n\nSets the angles (direction) of the projected texture."
  },
  "ProjectedTexture:SetBrightness": {
    "prefix": "SetBrightness",
    "body": "SetBrightness(${1:number brightness})$0",
    "description": "(Client) Method: ProjectedTexture:SetBrightness\n\nSets the brightness of the projected texture."
  },
  "ProjectedTexture:SetColor": {
    "prefix": "SetColor",
    "body": "SetColor(${1:table color})$0",
    "description": "(Client) Method: ProjectedTexture:SetColor\n\nSets the color of the projected texture."
  },
  "ProjectedTexture:SetEnableShadows": {
    "prefix": "SetEnableShadows",
    "body": "SetEnableShadows(${1:boolean })$0",
    "description": "(Client) Method: ProjectedTexture:SetEnableShadows\n\nEnable or disable shadows cast from the projected texture."
  },
  "ProjectedTexture:SetFarZ": {
    "prefix": "SetFarZ",
    "body": "SetFarZ(${1:number farZ})$0",
    "description": "(Client) Method: ProjectedTexture:SetFarZ\n\nSets the distance at which the projected texture ends."
  },
  "ProjectedTexture:SetFOV": {
    "prefix": "SetFOV",
    "body": "SetFOV(${1:number fov})$0",
    "description": "(Client) Method: ProjectedTexture:SetFOV\n\nSets the angle of projection."
  },
  "ProjectedTexture:SetHorizontalFOV": {
    "prefix": "SetHorizontalFOV",
    "body": "SetHorizontalFOV(${1:number hFOV})$0",
    "description": "(Client) Method: ProjectedTexture:SetHorizontalFOV\n\nSets the horizontal angle of projection without affecting the vertical angle."
  },
  "ProjectedTexture:SetNearZ": {
    "prefix": "SetNearZ",
    "body": "SetNearZ(${1:number nearZ})$0",
    "description": "(Client) Method: ProjectedTexture:SetNearZ\n\nSets the distance at which the projected texture begins its projection."
  },
  "ProjectedTexture:SetOrthographic": {
    "prefix": "SetOrthographic",
    "body": "SetOrthographic(${1:boolean orthographic}, ${2:number left}, ${3:number top}, ${4:number right}, ${5:number bottom})$0",
    "description": "(Client) Method: ProjectedTexture:SetOrthographic\n\nChanges the current projected texture between orthographic and perspective projection."
  },
  "ProjectedTexture:SetPos": {
    "prefix": "SetPos",
    "body": "SetPos(${1:Vector position})$0",
    "description": "(Client) Method: ProjectedTexture:SetPos\n\nMove the Projected Texture to the specified position."
  },
  "ProjectedTexture:SetTexture": {
    "prefix": "SetTexture",
    "body": "SetTexture(${1:string texture})$0",
    "description": "(Client) Method: ProjectedTexture:SetTexture\n\nSets the texture to be projected."
  },
  "ProjectedTexture:SetTextureFrame": {
    "prefix": "SetTextureFrame",
    "body": "SetTextureFrame(${1:number frame})$0",
    "description": "(Client) Method: ProjectedTexture:SetTextureFrame\n\nFor animated textures, this will choose which frame in the animation will be projected."
  },
  "ProjectedTexture:SetVerticalFOV": {
    "prefix": "SetVerticalFOV",
    "body": "SetVerticalFOV(${1:number vFOV})$0",
    "description": "(Client) Method: ProjectedTexture:SetVerticalFOV\n\nSets the vertical angle of projection without affecting the horizontal angle."
  },
  "ProjectedTexture:Update": {
    "prefix": "Update",
    "body": "Update()$0",
    "description": "(Client) Method: ProjectedTexture:Update\n\nUpdates the Projected Light and applies all previously set parameters."
  },
  "Schedule:AddTask": {
    "prefix": "AddTask",
    "body": "AddTask(${1:string taskname}, ${2:number taskdata})$0",
    "description": "(Server) Method: Schedule:AddTask\n\nStub Adds a task to the schedule."
  },
  "Schedule:AddTaskEx": {
    "prefix": "AddTaskEx",
    "body": "AddTaskEx(${1:string start}, ${2:string run}, ${3:number data})$0",
    "description": "(Server) Method: Schedule:AddTaskEx\n\n"
  },
  "Schedule:EngTask": {
    "prefix": "EngTask",
    "body": "EngTask(${1:string taskname}, ${2:number taskdata})$0",
    "description": "(Server) Method: Schedule:EngTask\n\nAdds an engine task to the schedule."
  },
  "Schedule:GetTask": {
    "prefix": "GetTask",
    "body": "GetTask(${1:number num})$0",
    "description": "(Server) Method: Schedule:GetTask\n\nReturns the task at the given index."
  },
  "Schedule:Init": {
    "prefix": "Init",
    "body": "Init(${1:string debugName})$0",
    "description": "(Server) Method: Schedule:Init\n\n[Internal]  Initialises the Schedule. Called by ai_schedule.New when the Schedule is created."
  },
  "Schedule:NumTasks": {
    "prefix": "NumTasks",
    "body": "NumTasks()$0",
    "description": "(Server) Method: Schedule:NumTasks\n\nReturns the number of tasks in the schedule."
  },
  "Stack:Pop": {
    "prefix": "Pop",
    "body": "Pop(${1:number amount=1})$0",
    "description": "(Shared) Method: Stack:Pop\n\nPop an item from the stack"
  },
  "Stack:Push": {
    "prefix": "Push",
    "body": "Push(${1:any object})$0",
    "description": "(Shared) Method: Stack:Push\n\nPush an item onto the stack"
  },
  "Stack:Size": {
    "prefix": "Size",
    "body": "Size()$0",
    "description": "(Shared) Method: Stack:Size\n\nReturns the size of the stack"
  },
  "Stack:Top": {
    "prefix": "Top",
    "body": "Top()$0",
    "description": "(Shared) Method: Stack:Top\n\nGet the item at the top of the stack"
  },
  "Task:Init": {
    "prefix": "Init",
    "body": "Init()$0",
    "description": "(Server) Method: Task:Init\n\n[Internal]  Initialises the AI task. Called by ai_task.New."
  },
  "Task:InitEngine": {
    "prefix": "InitEngine",
    "body": "InitEngine(${1:string taskname}, ${2:number taskdata})$0",
    "description": "(Server) Method: Task:InitEngine\n\nInitialises the AI task as an engine task."
  },
  "Task:InitFunctionName": {
    "prefix": "InitFunctionName",
    "body": "InitFunctionName(${1:string startname}, ${2:string runname}, ${3:number taskdata})$0",
    "description": "(Server) Method: Task:InitFunctionName\n\nInitialises the AI task as NPC method-based."
  },
  "Task:IsEngineType": {
    "prefix": "IsEngineType",
    "body": "IsEngineType()$0",
    "description": "(Server) Method: Task:IsEngineType\n\nDetermines if the task is an engine task (''TYPE_ENGINE'', 1)."
  },
  "Task:IsFNameType": {
    "prefix": "IsFNameType",
    "body": "IsFNameType()$0",
    "description": "(Server) Method: Task:IsFNameType\n\nDetermines if the task is an NPC method-based task (''TYPE_FNAME'', 2)."
  },
  "Task:Run": {
    "prefix": "Run",
    "body": "Run(${1:NPC target})$0",
    "description": "(Server) Method: Task:Run\n\nRuns the AI task."
  },
  "Task:Run_FName": {
    "prefix": "Run_FName",
    "body": "Run_FName(${1:NPC target})$0",
    "description": "(Server) Method: Task:Run_FName\n\n[Internal]  Runs the AI task as an NPC method. This requires the task to be of type ''TYPE_FNAME''."
  },
  "Task:Start": {
    "prefix": "Start",
    "body": "Start(${1:NPC target})$0",
    "description": "(Server) Method: Task:Start\n\nStarts the AI task."
  },
  "Task:Start_FName": {
    "prefix": "Start_FName",
    "body": "Start_FName(${1:NPC target})$0",
    "description": "(Server) Method: Task:Start_FName\n\n[Internal]  Starts the AI task as an NPC method."
  },
  "Tool:ClearObjects": {
    "prefix": "ClearObjects",
    "body": "ClearObjects()$0",
    "description": "(Shared) Method: Tool:ClearObjects\n\nClears all objects previously set with Tool.SetObject."
  },
  "Tool:GetBone": {
    "prefix": "GetBone",
    "body": "GetBone(${1:number id})$0",
    "description": "(Shared) Method: Tool:GetBone\n\nRetrieves a physics bone number previously stored using Tool.SetObject."
  },
  "TOOL:GetClientInfo": {
    "prefix": "GetClientInfo",
    "body": "GetClientInfo(${1:string name})$0",
    "description": "(Shared) Method: TOOL:GetClientInfo\n\nAttempts to grab a clientside tool ConVar."
  },
  "TOOL:GetClientNumber": {
    "prefix": "GetClientNumber",
    "body": "GetClientNumber(${1:string name}, ${2:number default=0})$0",
    "description": "(Shared) Method: TOOL:GetClientNumber\n\nAttempts to grab a clientside tool ConVar."
  },
  "Tool:GetEnt": {
    "prefix": "GetEnt",
    "body": "GetEnt(${1:number id})$0",
    "description": "(Shared) Method: Tool:GetEnt\n\nRetrieves an Entity previously stored using Tool.SetObject."
  },
  "Tool:GetOperation": {
    "prefix": "GetOperation",
    "body": "GetOperation()$0",
    "description": "(Shared) Method: Tool:GetOperation\n\nReturns the current operation of the tool set by Tool.SetOperation."
  },
  "TOOL:GetOwner": {
    "prefix": "GetOwner",
    "body": "GetOwner()$0",
    "description": "(Shared) Method: TOOL:GetOwner\n\nReturns the owner of this tool. "
  },
  "TOOL:GetServerInfo": {
    "prefix": "GetServerInfo",
    "body": "GetServerInfo(${1:string name})$0",
    "description": "(Shared) Method: TOOL:GetServerInfo\n\nAttempts to grab a serverside tool ConVar."
  },
  "Tool:GetStage": {
    "prefix": "GetStage",
    "body": "GetStage()$0",
    "description": "(Shared) Method: Tool:GetStage\n\nReturns the current stage of the tool set by Tool.SetStage."
  },
  "Tool:NumObjects": {
    "prefix": "NumObjects",
    "body": "NumObjects()$0",
    "description": "(Shared) Method: Tool:NumObjects\n\nReturns the amount of stored objects ( Entitys ) the tool has."
  },
  "TOOL:SetObject": {
    "prefix": "SetObject",
    "body": "SetObject(${1:number id}, ${2:Entity ent}, ${3:Vector pos}, ${4:PhysObj phys}, ${5:number bone}, ${6:Vector norm})$0",
    "description": "(Shared) Method: TOOL:SetObject\n\nStores an Entity for later use in the tool."
  },
  "Tool:SetOperation": {
    "prefix": "SetOperation",
    "body": "SetOperation(${1:number operation})$0",
    "description": "(Shared) Method: Tool:SetOperation\n\nSets the current operation of the tool. Does nothing clientside. See also Tool.SetStage."
  },
  "Tool:SetStage": {
    "prefix": "SetStage",
    "body": "SetStage(${1:number stage})$0",
    "description": "(Shared) Method: Tool:SetStage\n\nSets the current stage of the tool. Does nothing clientside."
  },
  "Vector:Add": {
    "prefix": "Add",
    "body": "Add(${1:Vector vector})$0",
    "description": "(Shared) Method: Vector:Add\n\nAdds the values of the second vector to the orignal vector, this function can be used to avoid garbage collection."
  },
  "Vector:Angle": {
    "prefix": "Angle",
    "body": "Angle()$0",
    "description": "(Shared) Method: Vector:Angle\n\nReturns an angle representing the normal of the vector."
  },
  "Vector:AngleEx": {
    "prefix": "AngleEx",
    "body": "AngleEx(${1:Vector up})$0",
    "description": "(Shared) Method: Vector:AngleEx\n\nReturns the angle of the vector, but instead of assuming that up is _G.Vector( 0, 0, 1 ) (Like Vector.Angle does) you can specify which direction is 'up' for the angle."
  },
  "Vector:Cross": {
    "prefix": "Cross",
    "body": "Cross(${1:Vector otherVector})$0",
    "description": "(Shared) Method: Vector:Cross\n\nCalculates the cross product of this vector and the passed one."
  },
  "Vector:Distance": {
    "prefix": "Distance",
    "body": "Distance(${1:Vector otherVector})$0",
    "description": "(Shared) Method: Vector:Distance\n\nReturns the pythagorean distance between the vector and the other vector."
  },
  "Vector:DistToSqr": {
    "prefix": "DistToSqr",
    "body": "DistToSqr(${1:Vector otherVec})$0",
    "description": "(Shared) Method: Vector:DistToSqr\n\nReturns the squared distance of 2 vectors, this is faster than Vector.Distance as calculating the square root is an expensive process."
  },
  "Vector:Dot": {
    "prefix": "Dot",
    "body": "Dot(${1:Vector otherVector})$0",
    "description": "(Shared) Method: Vector:Dot\n\nReturns the [[wikipedia:Dot product#Geometric definition.dot product]] of this vector and the passed one."
  },
  "Vector:DotProduct": {
    "prefix": "DotProduct",
    "body": "DotProduct(${1:Vector Vector})$0",
    "description": "(Shared) Method: Vector:DotProduct\n\n[Deprecated] .This is an alias of Vector.Dot. Use that instead.Returns the dot product of the two vectors."
  },
  "Vector:GetNormal": {
    "prefix": "GetNormal",
    "body": "GetNormal()$0",
    "description": "(Shared) Method: Vector:GetNormal\n\n[Deprecated] .Use Vector.GetNormalized instead."
  },
  "Vector:GetNormalized": {
    "prefix": "GetNormalized",
    "body": "GetNormalized()$0",
    "description": "(Shared) Method: Vector:GetNormalized\n\nReturns a normalized version of the vector. Normalized means vector with same direction but with length of 1."
  },
  "Vector:IsEqualTol": {
    "prefix": "IsEqualTol",
    "body": "IsEqualTol(${1:Vector compare}, ${2:number tolerance})$0",
    "description": "(Shared) Method: Vector:IsEqualTol\n\nReturns if the vector is equal to another vector with the given tolerance."
  },
  "Vector:IsZero": {
    "prefix": "IsZero",
    "body": "IsZero()$0",
    "description": "(Shared) Method: Vector:IsZero\n\nChecks whenever all fields of the vector are 0."
  },
  "Vector:Length": {
    "prefix": "Length",
    "body": "Length()$0",
    "description": "(Shared) Method: Vector:Length\n\nReturns the Euclidean length of the vector: x   y   z"
  },
  "Vector:Length2D": {
    "prefix": "Length2D",
    "body": "Length2D()$0",
    "description": "(Shared) Method: Vector:Length2D\n\nReturns the length of the vector in two dimensions, without the Z axis."
  },
  "Vector:Length2DSqr": {
    "prefix": "Length2DSqr",
    "body": "Length2DSqr()$0",
    "description": "(Shared) Method: Vector:Length2DSqr\n\nReturns the squared length of the vectors x and y value, x   y."
  },
  "Vector:LengthSqr": {
    "prefix": "LengthSqr",
    "body": "LengthSqr()$0",
    "description": "(Shared) Method: Vector:LengthSqr\n\nReturns the squared length of the vector, x   y   z."
  },
  "Vector:Mul": {
    "prefix": "Mul",
    "body": "Mul(${1:number multiplier})$0",
    "description": "(Shared) Method: Vector:Mul\n\nScales the vector by the given number, that means x, y and z are multiplied by that value."
  },
  "Vector:Normalize": {
    "prefix": "Normalize",
    "body": "Normalize()$0",
    "description": "(Shared) Method: Vector:Normalize\n\nNormalizes the given vector. This changes the vector you call it on, if you want to return a normalized copy without affecting the original, use Vector.GetNormalized."
  },
  "Vector:Rotate": {
    "prefix": "Rotate",
    "body": "Rotate(${1:Angle rotation})$0",
    "description": "(Shared) Method: Vector:Rotate\n\nRotates a vector by the given angle."
  },
  "Vector:Set": {
    "prefix": "Set",
    "body": "Set(${1:Vector vector})$0",
    "description": "(Shared) Method: Vector:Set\n\nCopies the values from the second vector to the first vector."
  },
  "Vector:Sub": {
    "prefix": "Sub",
    "body": "Sub(${1:Vector vector})$0",
    "description": "(Shared) Method: Vector:Sub\n\nSubstracts the values of the second vector from the orignal vector, this function can be used to avoid garbage collection."
  },
  "Vector:ToColor": {
    "prefix": "ToColor",
    "body": "ToColor()$0",
    "description": "(Shared) Method: Vector:ToColor\n\nTranslates the vector normalized vector ( length is 1 ) into a Color."
  },
  "Vector:ToScreen": {
    "prefix": "ToScreen",
    "body": "ToScreen()$0",
    "description": "(Client) Method: Vector:ToScreen\n\nReturns where on the screen the specified position vector would appear. A related function is gui.ScreenToVector, which converts a 2D coordinate to a 3D direction."
  },
  "Vector:WithinAABox": {
    "prefix": "WithinAABox",
    "body": "WithinAABox(${1:Vector boxStart}, ${2:Vector boxEnd})$0",
    "description": "(Shared) Method: Vector:WithinAABox\n\nReturns whenever the given vector is in a box created by the 2 other vectors."
  },
  "Vector:Zero": {
    "prefix": "Zero",
    "body": "Zero()$0",
    "description": "(Shared) Method: Vector:Zero\n\nSets x, y and z to 0."
  },
  "Vehicle:BoostTimeLeft": {
    "prefix": "BoostTimeLeft",
    "body": "BoostTimeLeft()$0",
    "description": "(Server) Method: Vehicle:BoostTimeLeft\n\nReturns the remaining boosting time left."
  },
  "Vehicle:CheckExitPoint": {
    "prefix": "CheckExitPoint",
    "body": "CheckExitPoint(${1:number yaw}, ${2:number distance}, ${3:Vector endPoint})$0",
    "description": "(Server) Method: Vehicle:CheckExitPoint\n\n"
  },
  "Vehicle:EnableEngine": {
    "prefix": "EnableEngine",
    "body": "EnableEngine(${1:boolean enable})$0",
    "description": "(Server) Method: Vehicle:EnableEngine\n\nSets whether the engine is enabled or disabled, i.e. can be started or not."
  },
  "Vehicle:GetAmmo": {
    "prefix": "GetAmmo",
    "body": "GetAmmo()$0",
    "description": "(Client) Method: Vehicle:GetAmmo\n\nReturns information about the ammo of the vehicle"
  },
  "Vehicle:GetCameraDistance": {
    "prefix": "GetCameraDistance",
    "body": "GetCameraDistance()$0",
    "description": "(Shared) Method: Vehicle:GetCameraDistance\n\nReturns third person camera distance."
  },
  "Vehicle:GetDriver": {
    "prefix": "GetDriver",
    "body": "GetDriver()$0",
    "description": "(Server) Method: Vehicle:GetDriver\n\nGets the driver of the vehicle, returns NULL if no driver is present."
  },
  "Vehicle:GetHLSpeed": {
    "prefix": "GetHLSpeed",
    "body": "GetHLSpeed()$0",
    "description": "(Server) Method: Vehicle:GetHLSpeed\n\nReturns the current speed of the vehicle in Half-Life Hammer Units (in/s). Same as Entity.GetVelocity   Vector.Length."
  },
  "Vehicle:GetMaxSpeed": {
    "prefix": "GetMaxSpeed",
    "body": "GetMaxSpeed()$0",
    "description": "(Server) Method: Vehicle:GetMaxSpeed\n\nReturns the max speed of the vehicle in MPH."
  },
  "Vehicle:GetOperatingParams": {
    "prefix": "GetOperatingParams",
    "body": "GetOperatingParams()$0",
    "description": "(Server) Method: Vehicle:GetOperatingParams\n\nReturns some info about the vehicle."
  },
  "Vehicle:GetPassenger": {
    "prefix": "GetPassenger",
    "body": "GetPassenger(${1:number passenger})$0",
    "description": "(Server) Method: Vehicle:GetPassenger\n\nGets the passenger of the vehicle, returns NULL if no drivers is present."
  },
  "Vehicle:GetPassengerSeatPoint": {
    "prefix": "GetPassengerSeatPoint",
    "body": "GetPassengerSeatPoint(${1:number role})$0",
    "description": "(Server) Method: Vehicle:GetPassengerSeatPoint\n\nReturns the seat position and angle of a given passenger seat."
  },
  "Vehicle:GetRPM": {
    "prefix": "GetRPM",
    "body": "GetRPM()$0",
    "description": "(Server) Method: Vehicle:GetRPM\n\nReturns the current RPM of the vehicle. This value is fake and doesn't actually affect the vehicle movement. "
  },
  "Vehicle:GetSpeed": {
    "prefix": "GetSpeed",
    "body": "GetSpeed()$0",
    "description": "(Server) Method: Vehicle:GetSpeed\n\nReturns the current speed of the vehicle in MPH."
  },
  "Vehicle:GetSteering": {
    "prefix": "GetSteering",
    "body": "GetSteering()$0",
    "description": "(Server) Method: Vehicle:GetSteering\n\nReturns the current steering of the vehicle."
  },
  "Vehicle:GetSteeringDegrees": {
    "prefix": "GetSteeringDegrees",
    "body": "GetSteeringDegrees()$0",
    "description": "(Server) Method: Vehicle:GetSteeringDegrees\n\nReturns the maximum steering degree of the vehicle"
  },
  "Vehicle:GetThirdPersonMode": {
    "prefix": "GetThirdPersonMode",
    "body": "GetThirdPersonMode()$0",
    "description": "(Shared) Method: Vehicle:GetThirdPersonMode\n\nReturns if vehicle has thirdperson mode enabled or not."
  },
  "Vehicle:GetThrottle": {
    "prefix": "GetThrottle",
    "body": "GetThrottle()$0",
    "description": "(Server) Method: Vehicle:GetThrottle\n\nReturns the current throttle of the vehicle."
  },
  "Vehicle:GetVehicleClass": {
    "prefix": "GetVehicleClass",
    "body": "GetVehicleClass()$0",
    "description": "(Shared) Method: Vehicle:GetVehicleClass\n\nReturns the vehicle class name. This is only useful for Sandbox spawned vehicles or any vehicle that properly sets the vehicle class with Vehicle.SetVehicleClass."
  },
  "Vehicle:GetVehicleParams": {
    "prefix": "GetVehicleParams",
    "body": "GetVehicleParams()$0",
    "description": "(Server) Method: Vehicle:GetVehicleParams\n\nReturns the vehicle parameters of given vehicle."
  },
  "Vehicle:GetVehicleViewPosition": {
    "prefix": "GetVehicleViewPosition",
    "body": "GetVehicleViewPosition(${1:number role})$0",
    "description": "(Server) Method: Vehicle:GetVehicleViewPosition\n\nReturns the view position and forward angle of a given passenger seat."
  },
  "Vehicle:GetWheel": {
    "prefix": "GetWheel",
    "body": "GetWheel(${1:number wheel})$0",
    "description": "(Server) Method: Vehicle:GetWheel\n\nReturns the PhysObj of given wheel."
  },
  "Vehicle:GetWheelBaseHeight": {
    "prefix": "GetWheelBaseHeight",
    "body": "GetWheelBaseHeight(${1:number wheel})$0",
    "description": "(Server) Method: Vehicle:GetWheelBaseHeight\n\nReturns the base wheel height."
  },
  "Vehicle:GetWheelContactPoint": {
    "prefix": "GetWheelContactPoint",
    "body": "GetWheelContactPoint(${1:number wheel})$0",
    "description": "(Server) Method: Vehicle:GetWheelContactPoint\n\nReturns the wheel contact point."
  },
  "Vehicle:GetWheelCount": {
    "prefix": "GetWheelCount",
    "body": "GetWheelCount()$0",
    "description": "(Server) Method: Vehicle:GetWheelCount\n\nReturns the wheel count of the vehicle"
  },
  "Vehicle:GetWheelTotalHeight": {
    "prefix": "GetWheelTotalHeight",
    "body": "GetWheelTotalHeight(${1:number wheel})$0",
    "description": "(Server) Method: Vehicle:GetWheelTotalHeight\n\nReturns the total wheel height."
  },
  "Vehicle:HasBoost": {
    "prefix": "HasBoost",
    "body": "HasBoost()$0",
    "description": "(Server) Method: Vehicle:HasBoost\n\nReturns whether this vehicle has boost at all."
  },
  "Vehicle:HasBrakePedal": {
    "prefix": "HasBrakePedal",
    "body": "HasBrakePedal()$0",
    "description": "(Server) Method: Vehicle:HasBrakePedal\n\nReturns whether this vehicle has a brake pedal. See Vehicle.SetHasBrakePedal."
  },
  "Vehicle:IsBoosting": {
    "prefix": "IsBoosting",
    "body": "IsBoosting()$0",
    "description": "(Server) Method: Vehicle:IsBoosting\n\nReturns whether this vehicle is currently boosting or not."
  },
  "Vehicle:IsEngineEnabled": {
    "prefix": "IsEngineEnabled",
    "body": "IsEngineEnabled()$0",
    "description": "(Server) Method: Vehicle:IsEngineEnabled\n\nReturns whether the engine is enabled or not, i.e. whether it can be started."
  },
  "Vehicle:IsEngineStarted": {
    "prefix": "IsEngineStarted",
    "body": "IsEngineStarted()$0",
    "description": "(Server) Method: Vehicle:IsEngineStarted\n\nReturns whether the engine is started or not."
  },
  "Vehicle:IsValidVehicle": {
    "prefix": "IsValidVehicle",
    "body": "IsValidVehicle()$0",
    "description": "(Shared) Method: Vehicle:IsValidVehicle\n\nReturns true if the vehicle object is a valid or not. This will return false when Vehicle functions are not usable on the vehicle."
  },
  "Vehicle:IsVehicleBodyInWater": {
    "prefix": "IsVehicleBodyInWater",
    "body": "IsVehicleBodyInWater()$0",
    "description": "(Server) Method: Vehicle:IsVehicleBodyInWater\n\nReturns whether this vehicle's engine is underwater or not. ( Internally the attachment point \"engine\" or \"vehicle_engine\" is checked )"
  },
  "Vehicle:ReleaseHandbrake": {
    "prefix": "ReleaseHandbrake",
    "body": "ReleaseHandbrake()$0",
    "description": "(Server) Method: Vehicle:ReleaseHandbrake\n\n"
  },
  "Vehicle:SetBoost": {
    "prefix": "SetBoost",
    "body": "SetBoost(${1:number boost})$0",
    "description": "(Server) Method: Vehicle:SetBoost\n\nSets the boost. It is possible that this function does not work while the vehicle has a valid driver in it."
  },
  "Vehicle:SetCameraDistance": {
    "prefix": "SetCameraDistance",
    "body": "SetCameraDistance(${1:number distance})$0",
    "description": "(Shared) Method: Vehicle:SetCameraDistance\n\nSets the third person camera distance of the vehicle."
  },
  "Vehicle:SetHandbrake": {
    "prefix": "SetHandbrake",
    "body": "SetHandbrake(${1:boolean handbrake})$0",
    "description": "(Server) Method: Vehicle:SetHandbrake\n\n"
  },
  "Vehicle:SetHasBrakePedal": {
    "prefix": "SetHasBrakePedal",
    "body": "SetHasBrakePedal(${1:boolean brakePedal})$0",
    "description": "(Server) Method: Vehicle:SetHasBrakePedal\n\nSets whether this vehicle has a brake pedal."
  },
  "Vehicle:SetMaxReverseThrottle": {
    "prefix": "SetMaxReverseThrottle",
    "body": "SetMaxReverseThrottle(${1:number maxRevThrottle})$0",
    "description": "(Server) Method: Vehicle:SetMaxReverseThrottle\n\nSets maximum reverse throttle"
  },
  "Vehicle:SetMaxThrottle": {
    "prefix": "SetMaxThrottle",
    "body": "SetMaxThrottle(${1:number maxThrottle})$0",
    "description": "(Server) Method: Vehicle:SetMaxThrottle\n\nSets maximum forward throttle"
  },
  "Vehicle:SetSpringLength": {
    "prefix": "SetSpringLength",
    "body": "SetSpringLength(${1:number wheel}, ${2:number length})$0",
    "description": "(Server) Method: Vehicle:SetSpringLength\n\nSets spring length of given wheel"
  },
  "Vehicle:SetSteering": {
    "prefix": "SetSteering",
    "body": "SetSteering(${1:number steering})$0",
    "description": "(Server) Method: Vehicle:SetSteering\n\nSets the steering of the vehicle."
  },
  "Vehicle:SetSteeringDegrees": {
    "prefix": "SetSteeringDegrees",
    "body": "SetSteeringDegrees(${1:number steeringDegrees})$0",
    "description": "(Server) Method: Vehicle:SetSteeringDegrees\n\nSets the maximum steering degrees of the vehicle"
  },
  "Vehicle:SetThirdPersonMode": {
    "prefix": "SetThirdPersonMode",
    "body": "SetThirdPersonMode(${1:boolean enable})$0",
    "description": "(Shared) Method: Vehicle:SetThirdPersonMode\n\nSets the third person mode state."
  },
  "Vehicle:SetThrottle": {
    "prefix": "SetThrottle",
    "body": "SetThrottle(${1:number throttle})$0",
    "description": "(Server) Method: Vehicle:SetThrottle\n\nSets the throttle of the vehicle. It is possible that this function does not work with a valid driver in it."
  },
  "Vehicle:SetVehicleClass": {
    "prefix": "SetVehicleClass",
    "body": "SetVehicleClass(${1:string class})$0",
    "description": "(Shared) Method: Vehicle:SetVehicleClass\n\n[Internal] Sets the vehicle class name."
  },
  "Vehicle:SetVehicleEntryAnim": {
    "prefix": "SetVehicleEntryAnim",
    "body": "SetVehicleEntryAnim(${1:boolean bOn})$0",
    "description": "(Server) Method: Vehicle:SetVehicleEntryAnim\n\nSets whether the entry or exit camera animation should be played or not."
  },
  "Vehicle:SetVehicleParams": {
    "prefix": "SetVehicleParams",
    "body": "SetVehicleParams(${1:table params})$0",
    "description": "(Server) Method: Vehicle:SetVehicleParams\n\nSets the vehicle parameters for given vehicle."
  },
  "Vehicle:SetWheelFriction": {
    "prefix": "SetWheelFriction",
    "body": "SetWheelFriction(${1:number wheel}, ${2:number friction})$0",
    "description": "(Server) Method: Vehicle:SetWheelFriction\n\nSets friction of given wheel.  This function may be broken."
  },
  "Vehicle:StartEngine": {
    "prefix": "StartEngine",
    "body": "StartEngine(${1:boolean start})$0",
    "description": "(Server) Method: Vehicle:StartEngine\n\nStarts or stops the engine."
  },
  "VMatrix:GetAngles": {
    "prefix": "GetAngles",
    "body": "GetAngles()$0",
    "description": "(Shared) Method: VMatrix:GetAngles\n\nReturns the absolute rotation of the matrix."
  },
  "VMatrix:GetField": {
    "prefix": "GetField",
    "body": "GetField(${1:number row}, ${2:number column})$0",
    "description": "(Shared) Method: VMatrix:GetField\n\nReturns a specific field in the matrix."
  },
  "VMatrix:GetForward": {
    "prefix": "GetForward",
    "body": "GetForward()$0",
    "description": "(Shared) Method: VMatrix:GetForward\n\nGets the forward direction of the matrix."
  },
  "VMatrix:GetInverse": {
    "prefix": "GetInverse",
    "body": "GetInverse()$0",
    "description": "(Shared) Method: VMatrix:GetInverse\n\nReturns an inverted matrix without modifying the original matrix."
  },
  "VMatrix:GetInverseTR": {
    "prefix": "GetInverseTR",
    "body": "GetInverseTR()$0",
    "description": "(Shared) Method: VMatrix:GetInverseTR\n\nReturns an inverted matrix without modifying the original matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation."
  },
  "VMatrix:GetRight": {
    "prefix": "GetRight",
    "body": "GetRight()$0",
    "description": "(Shared) Method: VMatrix:GetRight\n\nGets the right direction of the matrix."
  },
  "VMatrix:GetScale": {
    "prefix": "GetScale",
    "body": "GetScale()$0",
    "description": "(Shared) Method: VMatrix:GetScale\n\nReturns the absolute scale of the matrix."
  },
  "VMatrix:GetTranslation": {
    "prefix": "GetTranslation",
    "body": "GetTranslation()$0",
    "description": "(Shared) Method: VMatrix:GetTranslation\n\nReturns the absolute translation of the matrix."
  },
  "VMatrix:GetUp": {
    "prefix": "GetUp",
    "body": "GetUp()$0",
    "description": "(Shared) Method: VMatrix:GetUp\n\nGets the up direction of the matrix."
  },
  "VMatrix:Identity": {
    "prefix": "Identity",
    "body": "Identity()$0",
    "description": "(Shared) Method: VMatrix:Identity\n\nInitializes the matrix as Identity matrix."
  },
  "VMatrix:Invert": {
    "prefix": "Invert",
    "body": "Invert()$0",
    "description": "(Shared) Method: VMatrix:Invert\n\nInverts the matrix."
  },
  "VMatrix:InvertTR": {
    "prefix": "InvertTR",
    "body": "InvertTR()$0",
    "description": "(Shared) Method: VMatrix:InvertTR\n\nInverts the matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation."
  },
  "VMatrix:IsIdentity": {
    "prefix": "IsIdentity",
    "body": "IsIdentity()$0",
    "description": "(Shared) Method: VMatrix:IsIdentity\n\nReturns whether the matrix is equal to Identity matrix or not."
  },
  "VMatrix:IsRotationMatrix": {
    "prefix": "IsRotationMatrix",
    "body": "IsRotationMatrix()$0",
    "description": "(Shared) Method: VMatrix:IsRotationMatrix\n\nReturns whether the matrix is a rotation matrix or not."
  },
  "VMatrix:Rotate": {
    "prefix": "Rotate",
    "body": "Rotate(${1:Angle rotation})$0",
    "description": "(Shared) Method: VMatrix:Rotate\n\nRotates the matrix by the given angle."
  },
  "VMatrix:Scale": {
    "prefix": "Scale",
    "body": "Scale(${1:Vector scale})$0",
    "description": "(Shared) Method: VMatrix:Scale\n\nScales the matrix by the given vector."
  },
  "VMatrix:ScaleTranslation": {
    "prefix": "ScaleTranslation",
    "body": "ScaleTranslation(${1:number scale})$0",
    "description": "(Shared) Method: VMatrix:ScaleTranslation\n\nScales the absolute translation with the given value."
  },
  "VMatrix:Set": {
    "prefix": "Set",
    "body": "Set(${1:VMatrix src})$0",
    "description": "(Shared) Method: VMatrix:Set\n\nCopies values from the given matrix object."
  },
  "VMatrix:SetAngles": {
    "prefix": "SetAngles",
    "body": "SetAngles(${1:Angle angle})$0",
    "description": "(Shared) Method: VMatrix:SetAngles\n\nSets the absolute rotation of the matrix."
  },
  "VMatrix:SetField": {
    "prefix": "SetField",
    "body": "SetField(${1:number row}, ${2:number column}, ${3:number value})$0",
    "description": "(Shared) Method: VMatrix:SetField\n\nSets a specific field in the matrix."
  },
  "VMatrix:SetForward": {
    "prefix": "SetForward",
    "body": "SetForward(${1:Vector forward})$0",
    "description": "(Shared) Method: VMatrix:SetForward\n\nSets the forward direction of the matrix."
  },
  "VMatrix:SetRight": {
    "prefix": "SetRight",
    "body": "SetRight(${1:Vector forward})$0",
    "description": "(Shared) Method: VMatrix:SetRight\n\nSets the right direction of the matrix."
  },
  "VMatrix:SetScale": {
    "prefix": "SetScale",
    "body": "SetScale(${1:Vector scale})$0",
    "description": "(Shared) Method: VMatrix:SetScale\n\nModifies the scale of the matrix while preserving the rotation and translation."
  },
  "VMatrix:SetTranslation": {
    "prefix": "SetTranslation",
    "body": "SetTranslation(${1:Vector translation})$0",
    "description": "(Shared) Method: VMatrix:SetTranslation\n\nSets the absolute translation of the matrix."
  },
  "VMatrix:SetUp": {
    "prefix": "SetUp",
    "body": "SetUp(${1:Vector forward})$0",
    "description": "(Shared) Method: VMatrix:SetUp\n\nSets the up direction of the matrix."
  },
  "VMatrix:ToTable": {
    "prefix": "ToTable",
    "body": "ToTable()$0",
    "description": "(Shared) Method: VMatrix:ToTable\n\nConverts the matrix to a 4x4 table. See _G.Matrix function."
  },
  "VMatrix:Translate": {
    "prefix": "Translate",
    "body": "Translate(${1:Vector translation})$0",
    "description": "(Shared) Method: VMatrix:Translate\n\nTranslates the matrix by the given vector aka. adds the vector to the translation."
  },
  "Weapon:AllowsAutoSwitchFrom": {
    "prefix": "AllowsAutoSwitchFrom",
    "body": "AllowsAutoSwitchFrom()$0",
    "description": "(Shared) Method: Weapon:AllowsAutoSwitchFrom\n\nReturns whether the weapon allows to being switched from when a better ( Weapon.GetWeight ) weapon is being picked up."
  },
  "Weapon:AllowsAutoSwitchTo": {
    "prefix": "AllowsAutoSwitchTo",
    "body": "AllowsAutoSwitchTo()$0",
    "description": "(Shared) Method: Weapon:AllowsAutoSwitchTo\n\nReturns whether the weapon allows to being switched to when a better ( Weapon.GetWeight ) weapon is being picked up."
  },
  "Weapon:CallOnClient": {
    "prefix": "CallOnClient",
    "body": "CallOnClient(${1:string functionName}, ${2:string arguments=\"\"})$0",
    "description": "(Shared) Method: Weapon:CallOnClient\n\nCalls a SWEP function on client."
  },
  "Weapon:Clip1": {
    "prefix": "Clip1",
    "body": "Clip1()$0",
    "description": "(Shared) Method: Weapon:Clip1\n\nReturns how much primary ammo is in the magazine."
  },
  "Weapon:Clip2": {
    "prefix": "Clip2",
    "body": "Clip2()$0",
    "description": "(Shared) Method: Weapon:Clip2\n\nReturns how much secondary ammo is in magazine."
  },
  "Weapon:DefaultReload": {
    "prefix": "DefaultReload",
    "body": "DefaultReload(${1:number act})$0",
    "description": "(Shared) Method: Weapon:DefaultReload\n\nForces the weapon to reload while playing given animation."
  },
  "Weapon:GetActivity": {
    "prefix": "GetActivity",
    "body": "GetActivity()$0",
    "description": "(Shared) Method: Weapon:GetActivity\n\nReturns the sequence enumeration number that the weapon is playing."
  },
  "Weapon:GetHoldType": {
    "prefix": "GetHoldType",
    "body": "GetHoldType()$0",
    "description": "(Shared) Method: Weapon:GetHoldType\n\nReturns the hold type of the weapon."
  },
  "Weapon:GetMaxClip1": {
    "prefix": "GetMaxClip1",
    "body": "GetMaxClip1()$0",
    "description": "(Shared) Method: Weapon:GetMaxClip1\n\nReturns maximum primary clip size"
  },
  "Weapon:GetMaxClip2": {
    "prefix": "GetMaxClip2",
    "body": "GetMaxClip2()$0",
    "description": "(Shared) Method: Weapon:GetMaxClip2\n\nReturns maximum secondary clip size"
  },
  "Weapon:GetNextPrimaryFire": {
    "prefix": "GetNextPrimaryFire",
    "body": "GetNextPrimaryFire()$0",
    "description": "(Shared) Method: Weapon:GetNextPrimaryFire\n\nGets the next time the weapon can primary fire. ( Can call WEAPON.PrimaryAttack )"
  },
  "Weapon:GetNextSecondaryFire": {
    "prefix": "GetNextSecondaryFire",
    "body": "GetNextSecondaryFire()$0",
    "description": "(Shared) Method: Weapon:GetNextSecondaryFire\n\nGets the next time the weapon can secondary fire. ( Can call WEAPON.SecondaryAttack )"
  },
  "Weapon:GetPrimaryAmmoType": {
    "prefix": "GetPrimaryAmmoType",
    "body": "GetPrimaryAmmoType()$0",
    "description": "(Shared) Method: Weapon:GetPrimaryAmmoType\n\nGets the primary ammo type of the given weapon."
  },
  "Weapon:GetPrintName": {
    "prefix": "GetPrintName",
    "body": "GetPrintName()$0",
    "description": "(Shared) Method: Weapon:GetPrintName\n\nReturns the non-internal name of the weapon, that should be for displaying."
  },
  "Weapon:GetSecondaryAmmoType": {
    "prefix": "GetSecondaryAmmoType",
    "body": "GetSecondaryAmmoType()$0",
    "description": "(Shared) Method: Weapon:GetSecondaryAmmoType\n\nGets the ammo type of the given weapons secondary fire."
  },
  "Weapon:GetSlot": {
    "prefix": "GetSlot",
    "body": "GetSlot()$0",
    "description": "(Shared) Method: Weapon:GetSlot\n\nReturns the slot of the weapon (slot numbers start from 0)"
  },
  "Weapon:GetSlotPos": {
    "prefix": "GetSlotPos",
    "body": "GetSlotPos()$0",
    "description": "(Shared) Method: Weapon:GetSlotPos\n\nReturns slot position of the weapon"
  },
  "Weapon:GetWeaponViewModel": {
    "prefix": "GetWeaponViewModel",
    "body": "GetWeaponViewModel()$0",
    "description": "(Shared) Method: Weapon:GetWeaponViewModel\n\nReturns the view model of the weapon."
  },
  "Weapon:GetWeaponWorldModel": {
    "prefix": "GetWeaponWorldModel",
    "body": "GetWeaponWorldModel()$0",
    "description": "(Shared) Method: Weapon:GetWeaponWorldModel\n\nReturns the world model of the weapon."
  },
  "Weapon:GetWeight": {
    "prefix": "GetWeight",
    "body": "GetWeight()$0",
    "description": "(Shared) Method: Weapon:GetWeight\n\nReturns the \"weight\" of the weapon, which is used when deciding which Weapon is better by the engine."
  },
  "Weapon:HasAmmo": {
    "prefix": "HasAmmo",
    "body": "HasAmmo()$0",
    "description": "(Shared) Method: Weapon:HasAmmo\n\nReturns whether the weapon has ammo left or not. It will return false when there's no ammo left in the magazine '''and''' when there's no reserve ammo left."
  },
  "Weapon:IsCarriedByLocalPlayer": {
    "prefix": "IsCarriedByLocalPlayer",
    "body": "IsCarriedByLocalPlayer()$0",
    "description": "(Client) Method: Weapon:IsCarriedByLocalPlayer\n\nReturns whenever the weapon is carried by the local player."
  },
  "Weapon:IsScripted": {
    "prefix": "IsScripted",
    "body": "IsScripted()$0",
    "description": "(Shared) Method: Weapon:IsScripted\n\nChecks if the weapon is a SWEP or a built-in weapon."
  },
  "Weapon:IsWeaponVisible": {
    "prefix": "IsWeaponVisible",
    "body": "IsWeaponVisible()$0",
    "description": "(Shared) Method: Weapon:IsWeaponVisible\n\nReturns whether the weapon is visible. The term visibility is not exactly what gets checked here, first it checks if the owner is a player, then checks if the active view model has EF_NODRAW flag NOT set."
  },
  "Weapon:LastShootTime": {
    "prefix": "LastShootTime",
    "body": "LastShootTime()$0",
    "description": "(Shared) Method: Weapon:LastShootTime\n\nReturns the time since this weapon last fired a bullet with Entity.FireBullets in seconds. It is not networked."
  },
  "Weapon:SendWeaponAnim": {
    "prefix": "SendWeaponAnim",
    "body": "SendWeaponAnim(${1:number act})$0",
    "description": "(Shared) Method: Weapon:SendWeaponAnim\n\nForces weapon to play activity/animation."
  },
  "Weapon:SetClip1": {
    "prefix": "SetClip1",
    "body": "SetClip1(${1:number ammo})$0",
    "description": "(Shared) Method: Weapon:SetClip1\n\nLets you change the number of bullets in the given weapons primary clip."
  },
  "Weapon:SetClip2": {
    "prefix": "SetClip2",
    "body": "SetClip2(${1:number ammo})$0",
    "description": "(Shared) Method: Weapon:SetClip2\n\nLets you change the number of bullets in the given weapons secondary clip."
  },
  "Weapon:SetHoldType": {
    "prefix": "SetHoldType",
    "body": "SetHoldType(${1:string name})$0",
    "description": "(Shared) Method: Weapon:SetHoldType\n\nSets the hold type of the weapon. This function also calls WEAPON.SetWeaponHoldType and properly networks it to all clients."
  },
  "Weapon:SetLastShootTime": {
    "prefix": "SetLastShootTime",
    "body": "SetLastShootTime(${1:number time=CurTime()})$0",
    "description": "(Shared) Method: Weapon:SetLastShootTime\n\nSets the time since this weapon last fired in seconds. Used in conjunction with Weapon.LastShootTime"
  },
  "Weapon:SetNextPrimaryFire": {
    "prefix": "SetNextPrimaryFire",
    "body": "SetNextPrimaryFire(${1:number time})$0",
    "description": "(Shared) Method: Weapon:SetNextPrimaryFire\n\nSets when the weapon can fire again. Time should be based on _G.CurTime."
  }
}