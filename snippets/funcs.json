{
  "achievements.BalloonPopped": {
    "prefix": "achievements.BalloonPopped",
    "body": "achievements.BalloonPopped()$0",
    "description": "(Client) Function: achievements.BalloonPopped\n\n[Internal] Adds one to the count of balloons burst. Once this count reaches 1000, the 'Popper' achievement is unlocked."
  },
  "achievements.Count": {
    "prefix": "achievements.Count",
    "body": "achievements.Count()$0",
    "description": "(Client and Menu) Function: achievements.Count\n\nReturns the amount of achievements in Garry's Mod."
  },
  "achievements.EatBall": {
    "prefix": "achievements.EatBall",
    "body": "achievements.EatBall()$0",
    "description": "(Client) Function: achievements.EatBall\n\n[Internal] Adds one to the count of balls eaten. Once this count reaches 200, the 'Ball Eater' achievement is unlocked."
  },
  "achievements.GetCount": {
    "prefix": "achievements.GetCount",
    "body": "achievements.GetCount(${1:number achievementID})$0",
    "description": "(Client and Menu) Function: achievements.GetCount\n\nRetrieves progress of given achievement"
  },
  "achievements.GetDesc": {
    "prefix": "achievements.GetDesc",
    "body": "achievements.GetDesc(${1:number achievementID})$0",
    "description": "(Client and Menu) Function: achievements.GetDesc\n\nRetrieves description of given achievement"
  },
  "achievements.GetGoal": {
    "prefix": "achievements.GetGoal",
    "body": "achievements.GetGoal(${1:number achievementID})$0",
    "description": "(Client and Menu) Function: achievements.GetGoal\n\nRetrieves progress goal of given achievement"
  },
  "achievements.GetName": {
    "prefix": "achievements.GetName",
    "body": "achievements.GetName(${1:number achievementID})$0",
    "description": "(Client and Menu) Function: achievements.GetName\n\nRetrieves name of given achievement"
  },
  "achievements.IncBaddies": {
    "prefix": "achievements.IncBaddies",
    "body": "achievements.IncBaddies()$0",
    "description": "(Client) Function: achievements.IncBaddies\n\n[Internal] Adds one to the count of baddies killed. Once this count reaches 1000, the 'War Zone' achievement is unlocked."
  },
  "achievements.IncBystander": {
    "prefix": "achievements.IncBystander",
    "body": "achievements.IncBystander()$0",
    "description": "(Client) Function: achievements.IncBystander\n\n[Internal] Adds one to the count of innocent animals killed. Once this count reaches 1000, the 'Innocent Bystander' achievement is unlocked."
  },
  "achievements.IncGoodies": {
    "prefix": "achievements.IncGoodies",
    "body": "achievements.IncGoodies()$0",
    "description": "(Client) Function: achievements.IncGoodies\n\n[Internal] Adds one to the count of friendly NPCs killed. Once this count reaches 1000, the 'Bad Friend' achievement is unlocked."
  },
  "achievements.IsAchieved": {
    "prefix": "achievements.IsAchieved",
    "body": "achievements.IsAchieved(${1:number AchievementID})$0",
    "description": "(Client and Menu) Function: achievements.IsAchieved\n\nUsed in GMod 12 in the achievements menu to show the user if they have unlocked certain achievements."
  },
  "achievements.Remover": {
    "prefix": "achievements.Remover",
    "body": "achievements.Remover()$0",
    "description": "(Client) Function: achievements.Remover\n\n[Internal] Adds one to the count of things removed. Once this count reaches 5000, the 'Destroyer' achievement is unlocked."
  },
  "achievements.SpawnedNPC": {
    "prefix": "achievements.SpawnedNPC",
    "body": "achievements.SpawnedNPC()$0",
    "description": "(Client) Function: achievements.SpawnedNPC\n\n[Internal] Adds one to the count of NPCs spawned. Once this count reaches 1000, the 'Procreator' achievement is unlocked."
  },
  "achievements.SpawnedProp": {
    "prefix": "achievements.SpawnedProp",
    "body": "achievements.SpawnedProp()$0",
    "description": "(Client) Function: achievements.SpawnedProp\n\n[Internal] Adds one to the count of props spawned. Once this count reaches 5000, the 'Creator' achievement is unlocked."
  },
  "achievements.SpawnedRagdoll": {
    "prefix": "achievements.SpawnedRagdoll",
    "body": "achievements.SpawnedRagdoll()$0",
    "description": "(Client) Function: achievements.SpawnedRagdoll\n\n[Internal] Adds one to the count of ragdolls spawned. Once this count reaches 2000, the 'Dollhouse' achievement is unlocked."
  },
  "achievements.SpawnMenuOpen": {
    "prefix": "achievements.SpawnMenuOpen",
    "body": "achievements.SpawnMenuOpen()$0",
    "description": "(Client) Function: achievements.SpawnMenuOpen\n\n[Internal] Adds one to the count of how many times the spawnmenu has been opened. Once this count reaches 100,000, the 'Menu User' achievement is unlocked."
  },
  "achievements": [],
  "ai_schedule.New": {
    "prefix": "ai_schedule.New",
    "body": "ai_schedule.New(${1:string name})$0",
    "description": "(Server) Function: ai_schedule.New\n\nCreates a schedule for scripted NPC."
  },
  "ai_schedule": [],
  "ai_task.New": {
    "prefix": "ai_task.New",
    "body": "ai_task.New()$0",
    "description": "(Server) Function: ai_task.New\n\nCreate a new empty task. Used by Schedule.AddTask and Schedule.EngTask."
  },
  "ai_task": [],
  "ai.GetScheduleID": {
    "prefix": "ai.GetScheduleID",
    "body": "ai.GetScheduleID(${1:string sched})$0",
    "description": "(Server) Function: ai.GetScheduleID\n\n"
  },
  "ai.GetTaskID": {
    "prefix": "ai.GetTaskID",
    "body": "ai.GetTaskID(${1:string taskName})$0",
    "description": "(Server) Function: ai.GetTaskID\n\nReturns the task Id corresponding to the given task name."
  },
  "ai": [],
  "baseclass.Get": {
    "prefix": "baseclass.Get",
    "body": "baseclass.Get(${1:string name})$0",
    "description": "(All) Function: baseclass.Get\n\nGets the base class of an an object."
  },
  "baseclass.Set": {
    "prefix": "baseclass.Set",
    "body": "baseclass.Set(${1:string name}, ${2:table tab})$0",
    "description": "(All) Function: baseclass.Set\n\nAdd a new base class that can be derived by others. This is done automatically for:"
  },
  "baseclass": [],
  "bit.arshift": {
    "prefix": "bit.arshift",
    "body": "bit.arshift(${1:number value}, ${2:number shiftCount})$0",
    "description": "(All) Function: bit.arshift\n\nReturns the arithmetically shifted value."
  },
  "bit.band": {
    "prefix": "bit.band",
    "body": "bit.band(${1:number value}, ${2:number otherValues=nil})$0",
    "description": "(All) Function: bit.band\n\nReturns the bitwise and of all values specified."
  },
  "bit.bnot": {
    "prefix": "bit.bnot",
    "body": "bit.bnot(${1:number value})$0",
    "description": "(All) Function: bit.bnot\n\nReturns the bitwise not of the value."
  },
  "bit.bor": {
    "prefix": "bit.bor",
    "body": "bit.bor(${1:number value1}, ${2:vararg ...})$0",
    "description": "(All) Function: bit.bor\n\nReturns the bitwise OR of all values specified."
  },
  "bit.bswap": {
    "prefix": "bit.bswap",
    "body": "bit.bswap(${1:number value})$0",
    "description": "(All) Function: bit.bswap\n\nSwaps the byte order."
  },
  "bit.bxor": {
    "prefix": "bit.bxor",
    "body": "bit.bxor(${1:number value}, ${2:number otherValues=nil})$0",
    "description": "(All) Function: bit.bxor\n\nReturns the bitwise xor of all values specified."
  },
  "bit.lshift": {
    "prefix": "bit.lshift",
    "body": "bit.lshift(${1:number value}, ${2:number shiftCount})$0",
    "description": "(All) Function: bit.lshift\n\nReturns the left shifted value."
  },
  "bit.rol": {
    "prefix": "bit.rol",
    "body": "bit.rol(${1:number value}, ${2:number shiftCount})$0",
    "description": "(All) Function: bit.rol\n\nReturns the left rotated value."
  },
  "bit.ror": {
    "prefix": "bit.ror",
    "body": "bit.ror(${1:number value}, ${2:number shiftCount})$0",
    "description": "(All) Function: bit.ror\n\nReturns the right rotated value."
  },
  "bit.rshift": {
    "prefix": "bit.rshift",
    "body": "bit.rshift(${1:number value}, ${2:number shiftCount})$0",
    "description": "(All) Function: bit.rshift\n\nReturns the right shifted value."
  },
  "bit.tobit": {
    "prefix": "bit.tobit",
    "body": "bit.tobit(${1:number value})$0",
    "description": "(All) Function: bit.tobit\n\nNormalizes the specified value and clamps it in the range of a signed 32bit integer."
  },
  "bit.tohex": {
    "prefix": "bit.tohex",
    "body": "bit.tohex(${1:number value}, ${2:number digits=8})$0",
    "description": "(All) Function: bit.tohex\n\nReturns the hexadecimal representation of the number with the specified digits."
  },
  "bit": [],
  "cam.ApplyShake": {
    "prefix": "cam.ApplyShake",
    "body": "cam.ApplyShake(${1:Vector pos}, ${2:Angle angles}, ${3:number factor})$0",
    "description": "(Client) Function: cam.ApplyShake\n\nShakes the screen at a certain position."
  },
  "cam.End": {
    "prefix": "cam.End",
    "body": "cam.End()$0",
    "description": "(Client) Function: cam.End\n\nSwitches the renderer back to the previous drawing mode from a 3D context."
  },
  "cam.End2D": {
    "prefix": "cam.End2D",
    "body": "cam.End2D()$0",
    "description": "(Client) Function: cam.End2D\n\nSwitches the renderer back to the previous drawing mode from a 2D context."
  },
  "cam.End3D": {
    "prefix": "cam.End3D",
    "body": "cam.End3D()$0",
    "description": "(Client) Function: cam.End3D\n\nSwitches the renderer back to the previous drawing mode from a 3D context."
  },
  "cam.End3D2D": {
    "prefix": "cam.End3D2D",
    "body": "cam.End3D2D()$0",
    "description": "(Client) Function: cam.End3D2D\n\nSwitches the renderer back to the previous drawing mode from a 3D2D context."
  },
  "cam.EndOrthoView": {
    "prefix": "cam.EndOrthoView",
    "body": "cam.EndOrthoView()$0",
    "description": "(Client) Function: cam.EndOrthoView\n\nSwitches the renderer back to the previous drawing mode from a 3D orthographic rendering context."
  },
  "cam.IgnoreZ": {
    "prefix": "cam.IgnoreZ",
    "body": "cam.IgnoreZ(${1:boolean ignoreZ})$0",
    "description": "(Client) Function: cam.IgnoreZ\n\nTells the renderer to ignore the depth buffer and draw any upcoming operation \"ontop\" of everything that was drawn yet."
  },
  "cam.PopModelMatrix": {
    "prefix": "cam.PopModelMatrix",
    "body": "cam.PopModelMatrix()$0",
    "description": "(Client) Function: cam.PopModelMatrix\n\nPops the current active rendering matrix from the stack and reinstates the previous one."
  },
  "cam.PushModelMatrix": {
    "prefix": "cam.PushModelMatrix",
    "body": "cam.PushModelMatrix(${1:VMatrix matrix})$0",
    "description": "(Client) Function: cam.PushModelMatrix\n\nPushes the specified matrix onto the render matrix stack. Unlike opengl, this will replace the current model matrix."
  },
  "cam.Start": {
    "prefix": "cam.Start",
    "body": "cam.Start(${1:table dataTbl})$0",
    "description": "(Client) Function: cam.Start\n\nSets up a new rendering context. You can easily use this instead of cam.Start3D or cam.Start2D"
  },
  "cam.Start2D": {
    "prefix": "cam.Start2D",
    "body": "cam.Start2D()$0",
    "description": "(Client) Function: cam.Start2D\n\nSets up a new 2D rendering context. Must be finished by cam.End2D."
  },
  "cam.Start3D": {
    "prefix": "cam.Start3D",
    "body": "cam.Start3D(${1:Vector pos=EyePos()}, ${2:Angle angles=EyeAngles()}, ${3:number fov=nil}, ${4:number x=0}, ${5:number y=0}, ${6:number w=ScrW()}, ${7:number h=ScrH()}, ${8:number zNear=nil}, ${9:number zFar=nil})$0",
    "description": "(Client) Function: cam.Start3D\n\nSets up a new 3D rendering context. Must be finished by cam.End3D."
  },
  "cam.Start3D2D": {
    "prefix": "cam.Start3D2D",
    "body": "cam.Start3D2D(${1:Vector pos}, ${2:Angle angles}, ${3:number scale})$0",
    "description": "(Client) Function: cam.Start3D2D\n\nSets up a new 2D rendering context. Must be finished by cam.End3D2D."
  },
  "cam.StartOrthoView": {
    "prefix": "cam.StartOrthoView",
    "body": "cam.StartOrthoView(${1:number leftOffset}, ${2:number topOffset}, ${3:number rightOffset}, ${4:number bottomOffset})$0",
    "description": "(Client) Function: cam.StartOrthoView\n\nSets up a new 3d context using orthographic projection."
  },
  "cam": [],
  "chat.AddText": {
    "prefix": "chat.AddText",
    "body": "chat.AddText(${1:vararg arguments})$0",
    "description": "(Client) Function: chat.AddText\n\nAdds text to the local player's chat box (which only they can read)."
  },
  "chat.Close": {
    "prefix": "chat.Close",
    "body": "chat.Close()$0",
    "description": "(Client) Function: chat.Close\n\nCloses the chat window."
  },
  "chat.GetChatBoxPos": {
    "prefix": "chat.GetChatBoxPos",
    "body": "chat.GetChatBoxPos()$0",
    "description": "(Client) Function: chat.GetChatBoxPos\n\nReturns the chatbox position."
  },
  "chat.GetChatBoxSize": {
    "prefix": "chat.GetChatBoxSize",
    "body": "chat.GetChatBoxSize()$0",
    "description": "(Client) Function: chat.GetChatBoxSize\n\nReturns the chatbox size."
  },
  "chat.Open": {
    "prefix": "chat.Open",
    "body": "chat.Open(${1:number mode})$0",
    "description": "(Client) Function: chat.Open\n\nOpens the chat window."
  },
  "chat.PlaySound": {
    "prefix": "chat.PlaySound",
    "body": "chat.PlaySound()$0",
    "description": "(Client) Function: chat.PlaySound\n\nPlays the chat \"tick\" sound."
  },
  "chat": [],
  "cleanup.Add": {
    "prefix": "cleanup.Add",
    "body": "cleanup.Add(${1:Player pl}, ${2:string type}, ${3:Entity ent})$0",
    "description": "(Server) Function: cleanup.Add\n\nAdds an entity to a player's cleanup list."
  },
  "cleanup.CC_AdminCleanup": {
    "prefix": "cleanup.CC_AdminCleanup",
    "body": "cleanup.CC_AdminCleanup(${1:Player pl}, ${2:string command}, ${3:table args})$0",
    "description": "(Server) Function: cleanup.CC_AdminCleanup\n\n[Internal]  Called by the ''gmod_admin_cleanup'' console command. Allows admins to clean up the server."
  },
  "cleanup.CC_Cleanup": {
    "prefix": "cleanup.CC_Cleanup",
    "body": "cleanup.CC_Cleanup(${1:Player pl}, ${2:string command}, ${3:table args})$0",
    "description": "(Server) Function: cleanup.CC_Cleanup\n\n[Internal]  Called by the ''gmod_cleanup'' console command. Allows players to cleanup their own props."
  },
  "cleanup.GetList": {
    "prefix": "cleanup.GetList",
    "body": "cleanup.GetList()$0",
    "description": "(Server) Function: cleanup.GetList\n\nGets the cleanup list."
  },
  "cleanup.GetTable": {
    "prefix": "cleanup.GetTable",
    "body": "cleanup.GetTable()$0",
    "description": "(Shared) Function: cleanup.GetTable\n\nGets the table of cleanup types."
  },
  "cleanup.Register": {
    "prefix": "cleanup.Register",
    "body": "cleanup.Register(${1:string type})$0",
    "description": "(Shared) Function: cleanup.Register\n\nRegisters a new cleanup type."
  },
  "cleanup.ReplaceEntity": {
    "prefix": "cleanup.ReplaceEntity",
    "body": "cleanup.ReplaceEntity(${1:Entity from}, ${2:Entity to})$0",
    "description": "(Server) Function: cleanup.ReplaceEntity\n\nReplaces one entity in the cleanup module with another"
  },
  "cleanup.UpdateUI": {
    "prefix": "cleanup.UpdateUI",
    "body": "cleanup.UpdateUI()$0",
    "description": "(Client) Function: cleanup.UpdateUI\n\nRepopulates the clients cleanup menu"
  },
  "cleanup": [],
  "concommand.Add": {
    "prefix": "concommand.Add",
    "body": "concommand.Add(${1:string name}, ${2:function callback}, ${3:function autoComplete=nil}, ${4:string helpText=nil}, ${5:number flags=0})$0",
    "description": "(All) Function: concommand.Add\n\nCreates a console command that runs a function in lua with optional autocompletion function and help text."
  },
  "concommand.AutoComplete": {
    "prefix": "concommand.AutoComplete",
    "body": "concommand.AutoComplete(${1:string command}, ${2:string arguments})$0",
    "description": "(All) Function: concommand.AutoComplete\n\n[Internal]  Used by the engine to call the autocomplete function for a console command, and retrieve returned options."
  },
  "concommand.GetTable": {
    "prefix": "concommand.GetTable",
    "body": "concommand.GetTable()$0",
    "description": "(All) Function: concommand.GetTable\n\nReturns the tables of all console command callbacks, and autocomplete functions, that were added to the game with concommand.Add."
  },
  "concommand.Remove": {
    "prefix": "concommand.Remove",
    "body": "concommand.Remove(${1:string name})$0",
    "description": "(All) Function: concommand.Remove\n\nRemoves a console command."
  },
  "concommand.Run": {
    "prefix": "concommand.Run",
    "body": "concommand.Run(${1:Player ply}, ${2:string cmd}, ${3:any args}, ${4:string argumentString})$0",
    "description": "(All) Function: concommand.Run\n\n[Internal] .You might be looking for _G.RunConsoleCommand or Player.ConCommand. Used by the engine to run a console command's callback function, that was added with concommand.Add. An error is sent to the player's chat if no callback is found."
  },
  "concommand": [],
  "constraint.AddConstraintTable": {
    "prefix": "constraint.AddConstraintTable",
    "body": "constraint.AddConstraintTable(${1:Entity ent1}, ${2:Entity constrt}, ${3:Entity ent2=nil}, ${4:Entity ent3=nil}, ${5:Entity ent4=nil})$0",
    "description": "(Server) Function: constraint.AddConstraintTable\n\nStores information about constraints in an entity's table."
  },
  "constraint.AddConstraintTableNoDelete": {
    "prefix": "constraint.AddConstraintTableNoDelete",
    "body": "constraint.AddConstraintTableNoDelete(${1:Entity ent1}, ${2:Entity constrt}, ${3:Entity ent2=nil}, ${4:Entity ent3=nil}, ${5:Entity ent4=nil})$0",
    "description": "(Server) Function: constraint.AddConstraintTableNoDelete\n\nStores info about the constraints on the entity's table. The only difference between this and constraint.AddConstraintTable is that the constraint does not get deleted when the entity is removed."
  },
  "constraint.AdvBallsocket": {
    "prefix": "constraint.AdvBallsocket",
    "body": "constraint.AdvBallsocket(${1:Entity Ent1}, ${2:Entity Ent2}, ${3:number Bone1}, ${4:number Bone2}, ${5:Vector LPos1}, ${6:Vector LPos2}, ${7:number forcelimit}, ${8:number torquelimit}, ${9:number xmin}, ${10:number ymin}, ${11:number zmin}, ${12:number xmax}, ${13:number ymax}, ${14:number zmax}, ${15:number xfric}, ${16:number yfric}, ${17:number zfric}, ${18:number onlyrotation}, ${19:number nocollide})$0",
    "description": "(Server) Function: constraint.AdvBallsocket\n\nCreates an advanced ballsocket (ragdoll) constraint."
  },
  "constraint.Axis": {
    "prefix": "constraint.Axis",
    "body": "constraint.Axis(${1:Entity Ent1}, ${2:Entity Ent2}, ${3:number Bone1}, ${4:number Bone2}, ${5:Vector LPos1}, ${6:Vector LPos2}, ${7:number forcelimit}, ${8:number torquelimit}, ${9:number friction}, ${10:number nocollide}, ${11:Vector LocalAxis}, ${12:boolean DontAddTable})$0",
    "description": "(Server) Function: constraint.Axis\n\nCreates an axis constraint."
  },
  "constraint.Ballsocket": {
    "prefix": "constraint.Ballsocket",
    "body": "constraint.Ballsocket(${1:Entity Ent1}, ${2:Entity Ent2}, ${3:number Bone1}, ${4:number Bone2}, ${5:Vector LocalPos}, ${6:number forcelimit}, ${7:number torquelimit}, ${8:number nocollide})$0",
    "description": "(Server) Function: constraint.Ballsocket\n\nCreates a ballsocket joint."
  },
  "constraint.CanConstrain": {
    "prefix": "constraint.CanConstrain",
    "body": "constraint.CanConstrain(${1:Entity ent}, ${2:number bone})$0",
    "description": "(Server) Function: constraint.CanConstrain\n\nBasic checks to make sure that the specified entity and bone are valid. Returns false if we should not be constraining the entity."
  },
  "constraint.CreateKeyframeRope": {
    "prefix": "constraint.CreateKeyframeRope",
    "body": "constraint.CreateKeyframeRope(${1:Vector pos}, ${2:number width}, ${3:string material}, ${4:Entity Constraint}, ${5:Entity Ent1}, ${6:Vector LPos1}, ${7:number Bone1}, ${8:Entity Ent2}, ${9:Vector LPos2}, ${10:number Bone2}, ${11:table kv})$0",
    "description": "(Server) Function: constraint.CreateKeyframeRope\n\nCreates a rope without any constraint"
  },
  "constraint.CreateStaticAnchorPoint": {
    "prefix": "constraint.CreateStaticAnchorPoint",
    "body": "constraint.CreateStaticAnchorPoint(${1:Vector pos})$0",
    "description": "(Server) Function: constraint.CreateStaticAnchorPoint\n\nCreates an invisible, non-moveable anchor point in the world to which things can be attached."
  },
  "constraint.Elastic": {
    "prefix": "constraint.Elastic",
    "body": "constraint.Elastic(${1:Entity Ent1}, ${2:Entity Ent2}, ${3:number Bone1}, ${4:number Bone2}, ${5:Vector LPos1}, ${6:Vector LPos2}, ${7:number constant}, ${8:number damping}, ${9:number rdamping}, ${10:string material}, ${11:number width}, ${12:boolean stretchonly})$0",
    "description": "(Server) Function: constraint.Elastic\n\nCreates an elastic constraint."
  },
  "constraint.Find": {
    "prefix": "constraint.Find",
    "body": "constraint.Find(${1:Entity ent1}, ${2:Entity ent2}, ${3:string type}, ${4:number bone1}, ${5:number bone2})$0",
    "description": "(Server) Function: constraint.Find\n\nReturns the constraint of a specified type between two entities, if it exists"
  },
  "constraint.FindConstraint": {
    "prefix": "constraint.FindConstraint",
    "body": "constraint.FindConstraint(${1:Entity ent}, ${2:string type})$0",
    "description": "(Server) Function: constraint.FindConstraint\n\nReturns the first constraint of a specific type directly connected to the entity found"
  },
  "constraint.FindConstraintEntity": {
    "prefix": "constraint.FindConstraintEntity",
    "body": "constraint.FindConstraintEntity(${1:Entity ent}, ${2:string type})$0",
    "description": "(Server) Function: constraint.FindConstraintEntity\n\nReturns the other entity involved in the first constraint of a specific type directly connected to the entity"
  },
  "constraint.FindConstraints": {
    "prefix": "constraint.FindConstraints",
    "body": "constraint.FindConstraints(${1:Entity ent}, ${2:string type})$0",
    "description": "(Server) Function: constraint.FindConstraints\n\nReturns a table of all constraints of a specific type directly connected to the entity"
  },
  "constraint.ForgetConstraints": {
    "prefix": "constraint.ForgetConstraints",
    "body": "constraint.ForgetConstraints(${1:Entity ent})$0",
    "description": "(Server) Function: constraint.ForgetConstraints\n\nMake this entity forget any constraints it knows about. Note that this will not actually remove the constraints."
  },
  "constraint.GetAllConstrainedEntities": {
    "prefix": "constraint.GetAllConstrainedEntities",
    "body": "constraint.GetAllConstrainedEntities(${1:Entity ent}, ${2:table ResultTable=nil})$0",
    "description": "(Server) Function: constraint.GetAllConstrainedEntities\n\nReturns a table of all entities recursively constrained to an entitiy."
  },
  "constraint.GetTable": {
    "prefix": "constraint.GetTable",
    "body": "constraint.GetTable(${1:Entity ent})$0",
    "description": "(Server) Function: constraint.GetTable\n\nReturns a table of all constraints directly connected to the entity"
  },
  "constraint.HasConstraints": {
    "prefix": "constraint.HasConstraints",
    "body": "constraint.HasConstraints(${1:Entity ent})$0",
    "description": "(Server) Function: constraint.HasConstraints\n\nReturns true if the entity has constraints attached to it"
  },
  "constraint.Hydraulic": {
    "prefix": "constraint.Hydraulic",
    "body": "constraint.Hydraulic(${1:Player pl}, ${2:Entity Ent1}, ${3:Entity Ent2}, ${4:number Bone1}, ${5:number Bone2}, ${6:Vector LPos1}, ${7:Vector LPos2}, ${8:number Length1}, ${9:number Length2}, ${10:number width}, ${11:number key}, ${12:number fixed}, ${13:number speed}, ${14:string material})$0",
    "description": "(Server) Function: constraint.Hydraulic\n\nCreates a Hydraulic constraint."
  },
  "constraint.Keepupright": {
    "prefix": "constraint.Keepupright",
    "body": "constraint.Keepupright(${1:Entity ent}, ${2:Angle ang}, ${3:number bone}, ${4:number angularLimit})$0",
    "description": "(Server) Function: constraint.Keepupright\n\nCreates a keep upright constraint."
  },
  "constraint.Motor": {
    "prefix": "constraint.Motor",
    "body": "constraint.Motor(${1:Entity Ent1}, ${2:Entity Ent2}, ${3:number Bone1}, ${4:number Bone2}, ${5:Vector LPos1}, ${6:Vector LPos2}, ${7:number friction}, ${8:number torque}, ${9:number forcetime}, ${10:number nocollide}, ${11:number toggle}, ${12:Player pl}, ${13:number forcelimit}, ${14:number numpadkey_fwd}, ${15:number numpadkey_bwd}, ${16:number direction}, ${17:Vector LocalAxis})$0",
    "description": "(Server) Function: constraint.Motor\n\nCreates a motor constraint."
  },
  "constraint.Muscle": {
    "prefix": "constraint.Muscle",
    "body": "constraint.Muscle(${1:Player pl}, ${2:Entity Ent1}, ${3:Entity Ent2}, ${4:number Bone1}, ${5:number Bone2}, ${6:Vector LPos1}, ${7:Vector LPos2}, ${8:number Length1}, ${9:number Length2}, ${10:number width}, ${11:number key}, ${12:number fixed}, ${13:number period}, ${14:number amplitude}, ${15:boolean starton}, ${16:string material})$0",
    "description": "(Server) Function: constraint.Muscle\n\nCreates a muscle constraint."
  },
  "constraint.NoCollide": {
    "prefix": "constraint.NoCollide",
    "body": "constraint.NoCollide(${1:Entity Ent1}, ${2:Entity Ent2}, ${3:number Bone1}, ${4:number Bone2})$0",
    "description": "(Server) Function: constraint.NoCollide\n\nCreates an no-collide \"constraint\". Disables collision between two entities."
  },
  "constraint.Pulley": {
    "prefix": "constraint.Pulley",
    "body": "constraint.Pulley(${1:Entity Ent1}, ${2:Entity Ent4}, ${3:number Bone1}, ${4:number Bone4}, ${5:Vector LPos1}, ${6:Vector LPos4}, ${7:Vector WPos2}, ${8:Vector WPos3}, ${9:number forcelimit}, ${10:boolean rigid}, ${11:number width}, ${12:string material})$0",
    "description": "(Server) Function: constraint.Pulley\n\nCreates a pulley constraint."
  },
  "constraint.RemoveAll": {
    "prefix": "constraint.RemoveAll",
    "body": "constraint.RemoveAll(${1:Entity ent})$0",
    "description": "(Server) Function: constraint.RemoveAll\n\nAttempts to remove all constraints associated with an entity"
  },
  "constraint.RemoveConstraints": {
    "prefix": "constraint.RemoveConstraints",
    "body": "constraint.RemoveConstraints(${1:Entity ent}, ${2:string type})$0",
    "description": "(Server) Function: constraint.RemoveConstraints\n\nAttempts to remove all constraints of a specified type associated with an entity"
  },
  "constraint.Rope": {
    "prefix": "constraint.Rope",
    "body": "constraint.Rope(${1:Entity Ent1}, ${2:number Ent2}, ${3:number Bone1}, ${4:number Bone2}, ${5:Vector LPos1}, ${6:Vector LPos2}, ${7:number length}, ${8:number addlength}, ${9:number forcelimit}, ${10:number width}, ${11:string material}, ${12:boolean rigid})$0",
    "description": "(Server) Function: constraint.Rope\n\nCreates a rope constraint - with rope!"
  },
  "constraint.Slider": {
    "prefix": "constraint.Slider",
    "body": "constraint.Slider(${1:Entity Ent1}, ${2:Entity Ent2}, ${3:number Bone1}, ${4:number Bone2}, ${5:Vector LPos1}, ${6:Vector LPos2}, ${7:number width}, ${8:string material})$0",
    "description": "(Server) Function: constraint.Slider\n\nCreates a slider constraint."
  },
  "constraint.Weld": {
    "prefix": "constraint.Weld",
    "body": "constraint.Weld(${1:Entity ent1}, ${2:Entity ent2}, ${3:number bone1}, ${4:number bone2}, ${5:number forcelimit}, ${6:boolean nocollide}, ${7:boolean deleteent1onbreak})$0",
    "description": "(Server) Function: constraint.Weld\n\nCreates a weld constraint"
  },
  "constraint.Winch": {
    "prefix": "constraint.Winch",
    "body": "constraint.Winch(${1:Player pl}, ${2:Entity Ent1}, ${3:Entity Ent2}, ${4:number Bone1}, ${5:number Bone2}, ${6:Vector LPos1}, ${7:Vector LPos2}, ${8:number width}, ${9:number key}, ${10:number key}, ${11:number fwd_speed}, ${12:number bwd_speed}, ${13:string material}, ${14:boolean toggle})$0",
    "description": "(Server) Function: constraint.Winch\n\nCreates a Winch constraint."
  },
  "constraint": [],
  "construct.Magnet": {
    "prefix": "construct.Magnet",
    "body": "construct.Magnet(${1:Player ply}, ${2:Vector pos}, ${3:Angle ang}, ${4:string model}, ${5:string material}, ${6:number key}, ${7:number maxObjects}, ${8:number strength}, ${9:number nopull=0}, ${10:number allowrot=0}, ${11:number startOn=0}, ${12:number toggle}, ${13:Vector vel=Vector( 0, 0, 0 )}, ${14:Angle aVel=Angle( 0, 0, 0 )}, ${15:boolean frozen=false})$0",
    "description": "(Server) Function: construct.Magnet\n\nCreates a magnet."
  },
  "construct.SetPhysProp": {
    "prefix": "construct.SetPhysProp",
    "body": "construct.SetPhysProp(${1:Player ply}, ${2:Entity ent}, ${3:number physObjID}, ${4:PhysObj physObj}, ${5:table data})$0",
    "description": "(Server) Function: construct.SetPhysProp\n\nSets props physical properties."
  },
  "construct": [],
  "controlpanel.Clear": {
    "prefix": "controlpanel.Clear",
    "body": "controlpanel.Clear()$0",
    "description": "(Client) Function: controlpanel.Clear\n\nClears ALL the control panels ( for tools )"
  },
  "controlpanel.Get": {
    "prefix": "controlpanel.Get",
    "body": "controlpanel.Get(${1:string name})$0",
    "description": "(Client) Function: controlpanel.Get\n\nReturns (or creates if not exists) a controlpanel."
  },
  "controlpanel": [],
  "cookie.Delete": {
    "prefix": "cookie.Delete",
    "body": "cookie.Delete(${1:string name})$0",
    "description": "(All) Function: cookie.Delete\n\nDeletes a cookie on the client."
  },
  "cookie.GetNumber": {
    "prefix": "cookie.GetNumber",
    "body": "cookie.GetNumber(${1:string name}, ${2:any default=nil})$0",
    "description": "(All) Function: cookie.GetNumber\n\nGets the value of a cookie on the client as a number."
  },
  "cookie.GetString": {
    "prefix": "cookie.GetString",
    "body": "cookie.GetString(${1:string name}, ${2:any default=nil})$0",
    "description": "(All) Function: cookie.GetString\n\nGets the value of a cookie on the client as a string."
  },
  "cookie.Set": {
    "prefix": "cookie.Set",
    "body": "cookie.Set(${1:string key}, ${2:string value})$0",
    "description": "(Shared) Function: cookie.Set\n\nSets the value of a cookie, which is saved automatically by the sql."
  },
  "cookie": [],
  "coroutine.create": {
    "prefix": "coroutine.create",
    "body": "coroutine.create(${1:function func})$0",
    "description": "(All) Function: coroutine.create\n\nCreates a coroutine of the given function."
  },
  "coroutine.resume": {
    "prefix": "coroutine.resume",
    "body": "coroutine.resume(${1:thread coroutine}, ${2:vararg args})$0",
    "description": "(All) Function: coroutine.resume\n\nResumes the given coroutine and passes the given vararg to either the function arguments or the coroutine.yield that is inside that function and returns whatever yield is called with the next time or by the final return in the function."
  },
  "coroutine.running": {
    "prefix": "coroutine.running",
    "body": "coroutine.running()$0",
    "description": "(All) Function: coroutine.running\n\nReturns the active coroutine or nil if we are not within a coroutine."
  },
  "coroutine.status": {
    "prefix": "coroutine.status",
    "body": "coroutine.status(${1:thread coroutine})$0",
    "description": "(All) Function: coroutine.status\n\nReturns the status of the coroutine passed to it, the possible statuses are \"suspended\", \"running\", and \"dead\"."
  },
  "coroutine.wait": {
    "prefix": "coroutine.wait",
    "body": "coroutine.wait(${1:number duration})$0",
    "description": "(Shared) Function: coroutine.wait\n\nYields the coroutine for the given duration before returning."
  },
  "coroutine.wrap": {
    "prefix": "coroutine.wrap",
    "body": "coroutine.wrap(${1:function coroutine})$0",
    "description": "(All) Function: coroutine.wrap\n\nReturns a function which calling is equivalent with calling coroutine.resume with the coroutine and all extra parameters."
  },
  "coroutine.yield": {
    "prefix": "coroutine.yield",
    "body": "coroutine.yield(${1:vararg returnValue})$0",
    "description": "(All) Function: coroutine.yield\n\nPauses the active coroutine and passes all additional variables to the call of coroutine.resume that resumed the coroutine last time, and returns all additional variables that were passed to the previous call of resume."
  },
  "coroutine": [],
  "cvars.AddChangeCallback": {
    "prefix": "cvars.AddChangeCallback",
    "body": "cvars.AddChangeCallback(${1:string name}, ${2:function callback}, ${3:string indentifier=nil})$0",
    "description": "(All) Function: cvars.AddChangeCallback\n\nAdds a callback to be called when the named convar changes."
  },
  "cvars.Bool": {
    "prefix": "cvars.Bool",
    "body": "cvars.Bool(${1:string cvar}, ${2:boolean default=false})$0",
    "description": "(All) Function: cvars.Bool\n\nRetrieves console variable as a boolean."
  },
  "cvars.GetConVarCallbacks": {
    "prefix": "cvars.GetConVarCallbacks",
    "body": "cvars.GetConVarCallbacks(${1:string name}, ${2:boolean createIfNotFound=false})$0",
    "description": "(All) Function: cvars.GetConVarCallbacks\n\nReturns a table of the given ConVars callbacks."
  },
  "cvars.Number": {
    "prefix": "cvars.Number",
    "body": "cvars.Number(${1:string cvar}, ${2:any default=nil})$0",
    "description": "(All) Function: cvars.Number\n\nRetrieves console variable as a number."
  },
  "cvars.OnConVarChanged": {
    "prefix": "cvars.OnConVarChanged",
    "body": "cvars.OnConVarChanged(${1:string name}, ${2:string oldVal}, ${3:string newVal})$0",
    "description": "(All) Function: cvars.OnConVarChanged\n\n[Internal] .You are probably looking for cvars.AddChangeCallback."
  },
  "cvars.RemoveChangeCallback": {
    "prefix": "cvars.RemoveChangeCallback",
    "body": "cvars.RemoveChangeCallback(${1:string name}, ${2:string indentifier})$0",
    "description": "(All) Function: cvars.RemoveChangeCallback\n\nRemoves a callback for a convar using the the callback's identifier. The identifier should be the third argument specified for cvars.AddChangeCallback."
  },
  "cvars.String": {
    "prefix": "cvars.String",
    "body": "cvars.String(${1:string cvar}, ${2:any default=nil})$0",
    "description": "(All) Function: cvars.String\n\nRetrieves console variable as a string."
  },
  "cvars": [],
  "debug.debug": {
    "prefix": "debug.debug",
    "body": "debug.debug()$0",
    "description": "(All) Function: debug.debug\n\nEnters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution."
  },
  "debug.getfenv": {
    "prefix": "debug.getfenv",
    "body": "debug.getfenv(${1:table object})$0",
    "description": "(All) Function: debug.getfenv\n\nReturns the environment of the passed object. This can be set with debug.setfenv"
  },
  "debug.gethook": {
    "prefix": "debug.gethook",
    "body": "debug.gethook(${1:thread thread=nil})$0",
    "description": "(All) Function: debug.gethook\n\nReturns the current hook settings of the passed thread. The thread argument can be omitted. This is unrelated to [[:Category:GM Hooks.gamemode hooks]]. More information on hooks can be found at http://www.lua.org/pil/23.2.html"
  },
  "debug.getinfo": {
    "prefix": "debug.getinfo",
    "body": "debug.getinfo(${1:function funcOrStackLevel}, ${2:string fields=\"flnSu\"})$0",
    "description": "(All) Function: debug.getinfo\n\nReturns debug information about a function."
  },
  "debug.getlocal": {
    "prefix": "debug.getlocal",
    "body": "debug.getlocal(${1:thread thread=Current thread}, ${2:number level}, ${3:number index})$0",
    "description": "(All) Function: debug.getlocal\n\nGets the name and value of a local variable indexed from the level"
  },
  "debug.getmetatable": {
    "prefix": "debug.getmetatable",
    "body": "debug.getmetatable(${1:any object})$0",
    "description": "(All) Function: debug.getmetatable\n\nReturns the metatable of an object. This function ignores the metatable's __metatable field."
  },
  "debug.getregistry": {
    "prefix": "debug.getregistry",
    "body": "debug.getregistry()$0",
    "description": "(All) Function: debug.getregistry\n\nReturns the internal Lua registry table."
  },
  "debug.getupvalue": {
    "prefix": "debug.getupvalue",
    "body": "debug.getupvalue(${1:function func}, ${2:number index})$0",
    "description": "(All) Function: debug.getupvalue\n\nUsed for getting variable values in an index from the passed function"
  },
  "debug.setfenv": {
    "prefix": "debug.setfenv",
    "body": "debug.setfenv(${1:table object}, ${2:table env})$0",
    "description": "(All) Function: debug.setfenv\n\nSets the environment of the passed object."
  },
  "debug.sethook": {
    "prefix": "debug.sethook",
    "body": "debug.sethook(${1:thread thread}, ${2:function hook}, ${3:string mask}, ${4:number count})$0",
    "description": "(All) Function: debug.sethook\n\nSets the given function as a Lua hook. This is completely different to gamemode hooks. The thread argument can be completely omitted and calling this function with no arguments will remove the current hook. This is used by default for infinite loop detection. More information on hooks can be found at http://www.lua.org/pil/23.2.html"
  },
  "debug.setlocal": {
    "prefix": "debug.setlocal",
    "body": "debug.setlocal(${1:thread thread=Current Thread}, ${2:number level}, ${3:number index}, ${4:any value=nil})$0",
    "description": "(All) Function: debug.setlocal\n\nThis function was removed due to security concerns."
  },
  "debug.setmetatable": {
    "prefix": "debug.setmetatable",
    "body": "debug.setmetatable(${1:any object}, ${2:table metatable})$0",
    "description": "(All) Function: debug.setmetatable\n\nSets the object's metatable. Unlike _G.setmetatable, this function works regardless of whether the first object passed is a valid table or not; this function even works on primitive datatypes such as numbers, functions, and even nil."
  },
  "debug.setupvalue": {
    "prefix": "debug.setupvalue",
    "body": "debug.setupvalue(${1:function func}, ${2:number index}, ${3:any val=nil})$0",
    "description": "(All) Function: debug.setupvalue\n\nThis function was removed due to security concerns."
  },
  "debug.Trace": {
    "prefix": "debug.Trace",
    "body": "debug.Trace()$0",
    "description": "(All) Function: debug.Trace\n\nPrints out the lua function call stack to the console."
  },
  "debug.traceback": {
    "prefix": "debug.traceback",
    "body": "debug.traceback(${1:thread thread=current thread}, ${2:string message=nil}, ${3:number level=1})$0",
    "description": "(All) Function: debug.traceback\n\nReturns a full execution stack trace."
  },
  "debug.upvalueid": {
    "prefix": "debug.upvalueid",
    "body": "debug.upvalueid(${1:function func}, ${2:number index})$0",
    "description": "(All) Function: debug.upvalueid\n\nThis function was removed due to security concerns."
  },
  "debug.upvaluejoin": {
    "prefix": "debug.upvaluejoin",
    "body": "debug.upvaluejoin(${1:function f1}, ${2:number n1}, ${3:function f2}, ${4:number n2})$0",
    "description": "(All) Function: debug.upvaluejoin\n\nThis function was removed due to security concerns."
  },
  "debug": [],
  "debugoverlay.Axis": {
    "prefix": "debugoverlay.Axis",
    "body": "debugoverlay.Axis(${1:Vector origin}, ${2:Angle ang}, ${3:number size}, ${4:number lifetime=1}, ${5:boolean ignoreZ=false})$0",
    "description": "(Shared) Function: debugoverlay.Axis\n\nDisplays an axis indicator at the specified position."
  },
  "debugoverlay.Box": {
    "prefix": "debugoverlay.Box",
    "body": "debugoverlay.Box(${1:Vector origin}, ${2:Vector mins}, ${3:Vector maxs}, ${4:number lifetime=1}, ${5:table color=Color( 255, 255, 255 )})$0",
    "description": "(Shared) Function: debugoverlay.Box\n\nDisplays a solid coloured box at the specified position."
  },
  "debugoverlay.BoxAngles": {
    "prefix": "debugoverlay.BoxAngles",
    "body": "debugoverlay.BoxAngles(${1:Vector pos}, ${2:Vector mins}, ${3:Vector maxs}, ${4:Angle ang}, ${5:number lifetime=1}, ${6:table color=Color( 255, 255, 255 )})$0",
    "description": "(Shared) Function: debugoverlay.BoxAngles\n\nDisplays a solid colored rotated box at the specified position."
  },
  "debugoverlay.Cross": {
    "prefix": "debugoverlay.Cross",
    "body": "debugoverlay.Cross(${1:Vector position}, ${2:number size}, ${3:number lifetime=1}, ${4:table color=Color( 255, 255, 255 )}, ${5:boolean ignoreZ=false})$0",
    "description": "(Shared) Function: debugoverlay.Cross\n\nCreates a coloured cross at the specified position for the specified time."
  },
  "debugoverlay.EntityTextAtPosition": {
    "prefix": "debugoverlay.EntityTextAtPosition",
    "body": "debugoverlay.EntityTextAtPosition(${1:Vector pos}, ${2:number line}, ${3:string text}, ${4:number lifetime=1}, ${5:table color=Color( 255, 255, 255 )})$0",
    "description": "(Shared) Function: debugoverlay.EntityTextAtPosition\n\nDisplays 2D text at the specified coordinates."
  },
  "debugoverlay.Grid": {
    "prefix": "debugoverlay.Grid",
    "body": "debugoverlay.Grid(${1:Vector position})$0",
    "description": "(Shared) Function: debugoverlay.Grid\n\nDraws a 3D grid of limited size in given position."
  },
  "debugoverlay.Line": {
    "prefix": "debugoverlay.Line",
    "body": "debugoverlay.Line(${1:Vector pos1}, ${2:Vector pos2}, ${3:number lifetime=1}, ${4:table color=Color( 255, 255, 255 )}, ${5:boolean ignoreZ=false})$0",
    "description": "(Shared) Function: debugoverlay.Line\n\nDisplays a coloured line at the specified position."
  },
  "debugoverlay.ScreenText": {
    "prefix": "debugoverlay.ScreenText",
    "body": "debugoverlay.ScreenText(${1:number x}, ${2:number y}, ${3:string text}, ${4:number lifetime=1}, ${5:table color=Color( 255, 255, 255 )})$0",
    "description": "(Shared) Function: debugoverlay.ScreenText\n\nDisplays text triangle at the specified coordinates."
  },
  "debugoverlay.Sphere": {
    "prefix": "debugoverlay.Sphere",
    "body": "debugoverlay.Sphere(${1:Vector origin}, ${2:number size}, ${3:number lifetime=1}, ${4:table color=Color( 255, 255, 255 )}, ${5:boolean ignoreZ=false})$0",
    "description": "(Shared) Function: debugoverlay.Sphere\n\nDisplays a coloured sphere at the specified position."
  },
  "debugoverlay.SweptBox": {
    "prefix": "debugoverlay.SweptBox",
    "body": "debugoverlay.SweptBox(${1:Vector vStart}, ${2:Vector vEnd}, ${3:Vector vMins}, ${4:Vector vMaxs}, ${5:Angle ang}, ${6:number lifetime=1}, ${7:table color=Color( 255, 255, 255 )})$0",
    "description": "(Shared) Function: debugoverlay.SweptBox\n\nDisplays \"swept\" box, two boxes connected with lines by their verices."
  },
  "debugoverlay.Text": {
    "prefix": "debugoverlay.Text",
    "body": "debugoverlay.Text(${1:Vector origin}, ${2:string text}, ${3:number lifetime=1}, ${4:boolean viewCheck=false})$0",
    "description": "(Shared) Function: debugoverlay.Text\n\nDisplays text at the specified position."
  },
  "debugoverlay.Triangle": {
    "prefix": "debugoverlay.Triangle",
    "body": "debugoverlay.Triangle(${1:Vector pos1}, ${2:Vector pos2}, ${3:Vector pos3}, ${4:number lifetime=1}, ${5:table color=Color( 255, 255, 255 )}, ${6:boolean ignoreZ=false})$0",
    "description": "(Shared) Function: debugoverlay.Triangle\n\nDisplays a colored triangle at the specified coordinates."
  },
  "debugoverlay": [],
  "derma.Color": {
    "prefix": "derma.Color",
    "body": "derma.Color(${1:string name}, ${2:Panel pnl}, ${3:table default})$0",
    "description": "(Client and Menu) Function: derma.Color\n\nGets the color from a Derma skin of a panel and returns default color if not found"
  },
  "derma.DefineControl": {
    "prefix": "derma.DefineControl",
    "body": "derma.DefineControl(${1:string name}, ${2:string description}, ${3:table tab}, ${4:string base})$0",
    "description": "(Client and Menu) Function: derma.DefineControl\n\nDefines a new Derma control with an optional base"
  },
  "derma.DefineSkin": {
    "prefix": "derma.DefineSkin",
    "body": "derma.DefineSkin(${1:string name}, ${2:string descriptions}, ${3:table skin})$0",
    "description": "(Client and Menu) Function: derma.DefineSkin\n\nDefines a new skin so that it is usable by Derma. The default skin can be found in \"garrysmod/lua/skins/default.lua\""
  },
  "derma.GetControlList": {
    "prefix": "derma.GetControlList",
    "body": "derma.GetControlList()$0",
    "description": "(Client and Menu) Function: derma.GetControlList\n\nReturns the [[derma/Controls.derma.Controls]] table."
  },
  "derma.GetDefaultSkin": {
    "prefix": "derma.GetDefaultSkin",
    "body": "derma.GetDefaultSkin()$0",
    "description": "(Client and Menu) Function: derma.GetDefaultSkin\n\nReturns the default skin table, which can be changed with the hook [[GM/ForceDermaSkin]]"
  },
  "derma.GetNamedSkin": {
    "prefix": "derma.GetNamedSkin",
    "body": "derma.GetNamedSkin(${1:string name})$0",
    "description": "(Client and Menu) Function: derma.GetNamedSkin\n\nReturns the skin table of the skin with the supplied name"
  },
  "derma.GetSkinTable": {
    "prefix": "derma.GetSkinTable",
    "body": "derma.GetSkinTable()$0",
    "description": "(Client and Menu) Function: derma.GetSkinTable\n\nReturns a copy of the table containing every Derma skin"
  },
  "derma.RefreshSkins": {
    "prefix": "derma.RefreshSkins",
    "body": "derma.RefreshSkins()$0",
    "description": "(Client and Menu) Function: derma.RefreshSkins\n\nClears all cached panels so that they reassess which skin they should be using."
  },
  "derma.SkinChangeIndex": {
    "prefix": "derma.SkinChangeIndex",
    "body": "derma.SkinChangeIndex()$0",
    "description": "(Client and Menu) Function: derma.SkinChangeIndex\n\nReturns how many times derma.RefreshSkins has been called."
  },
  "derma.SkinHook": {
    "prefix": "derma.SkinHook",
    "body": "derma.SkinHook(${1:string type}, ${2:string name}, ${3:Panel panel}, ${4:number w}, ${5:number h})$0",
    "description": "(Client and Menu) Function: derma.SkinHook\n\nCalls the specified hook for the given panel"
  },
  "derma.SkinTexture": {
    "prefix": "derma.SkinTexture",
    "body": "derma.SkinTexture(${1:string name}, ${2:Panel pnl}, ${3:any fallback=nil})$0",
    "description": "(Client and Menu) Function: derma.SkinTexture\n\nReturns a function to draw a specified texture of panels skin."
  },
  "derma": [],
  "dragndrop.CallReceiverFunction": {
    "prefix": "dragndrop.CallReceiverFunction",
    "body": "dragndrop.CallReceiverFunction(${1:boolean bDoDrop}, ${2:number command}, ${3:number mx}, ${4:number my})$0",
    "description": "(Client and Menu) Function: dragndrop.CallReceiverFunction\n\n[Internal] "
  },
  "dragndrop.Clear": {
    "prefix": "dragndrop.Clear",
    "body": "dragndrop.Clear()$0",
    "description": "(Client and Menu) Function: dragndrop.Clear\n\nClears all the internal drag'n'drop variables."
  },
  "dragndrop.Drop": {
    "prefix": "dragndrop.Drop",
    "body": "dragndrop.Drop()$0",
    "description": "(Client and Menu) Function: dragndrop.Drop\n\n[Internal] Handles the drop action of drag'n'drop library."
  },
  "dragndrop.GetDroppable": {
    "prefix": "dragndrop.GetDroppable",
    "body": "dragndrop.GetDroppable(${1:string name=nil})$0",
    "description": "(Client and Menu) Function: dragndrop.GetDroppable\n\nReturns a table of currently dragged panels."
  },
  "dragndrop.HandleDroppedInGame": {
    "prefix": "dragndrop.HandleDroppedInGame",
    "body": "dragndrop.HandleDroppedInGame()$0",
    "description": "(Client and Menu) Function: dragndrop.HandleDroppedInGame\n\nIf returns true, calls dragndrop.StopDragging in dragndrop.Drop. Seems to be broken and does nothing. Is it for override?"
  },
  "dragndrop.HoverThink": {
    "prefix": "dragndrop.HoverThink",
    "body": "dragndrop.HoverThink()$0",
    "description": "(Client and Menu) Function: dragndrop.HoverThink\n\n[Internal] "
  },
  "dragndrop.IsDragging": {
    "prefix": "dragndrop.IsDragging",
    "body": "dragndrop.IsDragging()$0",
    "description": "(Client and Menu) Function: dragndrop.IsDragging\n\nReturns whether the user is dragging something with the drag'n'drop system."
  },
  "dragndrop.StartDragging": {
    "prefix": "dragndrop.StartDragging",
    "body": "dragndrop.StartDragging()$0",
    "description": "(Client and Menu) Function: dragndrop.StartDragging\n\n[Internal] "
  },
  "dragndrop.StopDragging": {
    "prefix": "dragndrop.StopDragging",
    "body": "dragndrop.StopDragging()$0",
    "description": "(Client and Menu) Function: dragndrop.StopDragging\n\nStops the drag'n'drop and calls dragndrop.Clear."
  },
  "dragndrop.Think": {
    "prefix": "dragndrop.Think",
    "body": "dragndrop.Think()$0",
    "description": "(Client and Menu) Function: dragndrop.Think\n\n[Internal] "
  },
  "dragndrop.UpdateReceiver": {
    "prefix": "dragndrop.UpdateReceiver",
    "body": "dragndrop.UpdateReceiver()$0",
    "description": "(Client and Menu) Function: dragndrop.UpdateReceiver\n\n[Internal] "
  },
  "dragndrop": [],
  "draw.DrawText": {
    "prefix": "draw.DrawText",
    "body": "draw.DrawText(${1:string text}, ${2:string font=\"DermaDefault\"}, ${3:number x=0}, ${4:number y=0}, ${5:table color=Color( 255, 255, 255, 255 )}, ${6:number xAlign=TEXT_ALIGN_LEFT})$0",
    "description": "(Client and Menu) Function: draw.DrawText\n\nSimple draw text at position, but this will expand newlines and tabs."
  },
  "draw.GetFontHeight": {
    "prefix": "draw.GetFontHeight",
    "body": "draw.GetFontHeight(${1:string font})$0",
    "description": "(Client and Menu) Function: draw.GetFontHeight\n\nReturns the height of the specified font in pixels."
  },
  "draw.NoTexture": {
    "prefix": "draw.NoTexture",
    "body": "draw.NoTexture()$0",
    "description": "(Client and Menu) Function: draw.NoTexture\n\nSets drawing texture to a default white texture (vgui/white) via surface.SetMaterial. Useful for resetting the drawing texture."
  },
  "draw.RoundedBox": {
    "prefix": "draw.RoundedBox",
    "body": "draw.RoundedBox(${1:number cornerRadius}, ${2:number x}, ${3:number y}, ${4:number width}, ${5:number height}, ${6:table color})$0",
    "description": "(Client and Menu) Function: draw.RoundedBox\n\nDraws a rounded rectangle."
  },
  "draw.RoundedBoxEx": {
    "prefix": "draw.RoundedBoxEx",
    "body": "draw.RoundedBoxEx(${1:number cornerRadius}, ${2:number x}, ${3:number y}, ${4:number width}, ${5:number height}, ${6:table color}, ${7:boolean roundTopLeft=false}, ${8:boolean roundTopRight=false}, ${9:boolean roundBottomLeft=false}, ${10:boolean roundBottomRight=false})$0",
    "description": "(Client and Menu) Function: draw.RoundedBoxEx\n\nDraws a rounded rectangle. This function also lets you specify which corners are drawn rounded."
  },
  "draw.SimpleText": {
    "prefix": "draw.SimpleText",
    "body": "draw.SimpleText(${1:string text}, ${2:string font=\"DermaDefault\"}, ${3:number x=0}, ${4:number y=0}, ${5:table color=Color( 255, 255, 255, 255 )}, ${6:number xAlign=TEXT_ALIGN_LEFT}, ${7:number yAlign=TEXT_ALIGN_TOP})$0",
    "description": "(Client and Menu) Function: draw.SimpleText\n\nDraws text on the screen."
  },
  "draw.SimpleTextOutlined": {
    "prefix": "draw.SimpleTextOutlined",
    "body": "draw.SimpleTextOutlined(${1:string Text}, ${2:string font=\"DermaDefault\"}, ${3:number x=0}, ${4:number y=0}, ${5:table color=Color( 255, 255, 255, 255 )}, ${6:number xAlign=TEXT_ALIGN_LEFT}, ${7:number yAlign=TEXT_ALIGN_TOP}, ${8:number outlinewidth}, ${9:table outlinecolor=Color( 255, 255, 255, 255 )})$0",
    "description": "(Client and Menu) Function: draw.SimpleTextOutlined\n\nCreates a simple line of text that is outlined."
  },
  "draw.Text": {
    "prefix": "draw.Text",
    "body": "draw.Text(${1:table textdata})$0",
    "description": "(Client and Menu) Function: draw.Text\n\nWorks like draw.SimpleText but uses a table structure instead."
  },
  "draw.TextShadow": {
    "prefix": "draw.TextShadow",
    "body": "draw.TextShadow(${1:table textdata}, ${2:number distance}, ${3:number alpha=200})$0",
    "description": "(Client and Menu) Function: draw.TextShadow\n\nWorks like draw.Text, but draws the text as a shadow."
  },
  "draw.TexturedQuad": {
    "prefix": "draw.TexturedQuad",
    "body": "draw.TexturedQuad(${1:table texturedata})$0",
    "description": "(Client and Menu) Function: draw.TexturedQuad\n\nDraws a texture with a table structure."
  },
  "draw.WordBox": {
    "prefix": "draw.WordBox",
    "body": "draw.WordBox(${1:number bordersize}, ${2:number x}, ${3:number y}, ${4:string text}, ${5:string font}, ${6:table boxcolor}, ${7:table textcolor})$0",
    "description": "(Client and Menu) Function: draw.WordBox\n\nDraws a rounded box with text in it."
  },
  "draw": [],
  "drive.CalcView": {
    "prefix": "drive.CalcView",
    "body": "drive.CalcView(${1:Player ply}, ${2:table view})$0",
    "description": "(Shared) Function: drive.CalcView\n\n[Internal] "
  },
  "drive.CreateMove": {
    "prefix": "drive.CreateMove",
    "body": "drive.CreateMove(${1:CUserCmd cmd})$0",
    "description": "(Shared) Function: drive.CreateMove\n\n[Internal] "
  },
  "drive.DestroyMethod": {
    "prefix": "drive.DestroyMethod",
    "body": "drive.DestroyMethod(${1:Player ply})$0",
    "description": "(Shared) Function: drive.DestroyMethod\n\n[Internal] "
  },
  "drive.End": {
    "prefix": "drive.End",
    "body": "drive.End(${1:Player ply}, ${2:Entity ent})$0",
    "description": "(Shared) Function: drive.End\n\nPlayer has stopped driving the entity."
  },
  "drive.FinishMove": {
    "prefix": "drive.FinishMove",
    "body": "drive.FinishMove(${1:Player ply}, ${2:CMoveData mv})$0",
    "description": "(Shared) Function: drive.FinishMove\n\n[Internal] "
  },
  "drive.GetMethod": {
    "prefix": "drive.GetMethod",
    "body": "drive.GetMethod(${1:Player ply})$0",
    "description": "(Shared) Function: drive.GetMethod\n\n[Internal] "
  },
  "drive.Move": {
    "prefix": "drive.Move",
    "body": "drive.Move(${1:Player ply}, ${2:CMoveData mv})$0",
    "description": "(Shared) Function: drive.Move\n\n[Internal] "
  },
  "drive.PlayerStartDriving": {
    "prefix": "drive.PlayerStartDriving",
    "body": "drive.PlayerStartDriving(${1:Player ply}, ${2:Entity ent}, ${3:string mode})$0",
    "description": "(Shared) Function: drive.PlayerStartDriving\n\nStarts driving for the player."
  },
  "drive.PlayerStopDriving": {
    "prefix": "drive.PlayerStopDriving",
    "body": "drive.PlayerStopDriving(${1:Player ply})$0",
    "description": "(Shared) Function: drive.PlayerStopDriving\n\nStops the player from driving anything. ( For example a prop in sandbox )"
  },
  "drive.Register": {
    "prefix": "drive.Register",
    "body": "drive.Register(${1:string name}, ${2:table data}, ${3:string base})$0",
    "description": "(Shared) Function: drive.Register\n\nRegisters a new entity drive."
  },
  "drive.Start": {
    "prefix": "drive.Start",
    "body": "drive.Start(${1:Player ply}, ${2:Entity ent})$0",
    "description": "(Shared) Function: drive.Start\n\nCalled when the player first starts driving this entity"
  },
  "drive.StartMove": {
    "prefix": "drive.StartMove",
    "body": "drive.StartMove(${1:Player ply}, ${2:CMoveData mv}, ${3:CUserCmd cmd})$0",
    "description": "(Shared) Function: drive.StartMove\n\n[Internal] "
  },
  "drive": [],
  "duplicator.Allow": {
    "prefix": "duplicator.Allow",
    "body": "duplicator.Allow(${1:string classname})$0",
    "description": "(Shared) Function: duplicator.Allow\n\nAllow this entity to be duplicated"
  },
  "duplicator.ApplyBoneModifiers": {
    "prefix": "duplicator.ApplyBoneModifiers",
    "body": "duplicator.ApplyBoneModifiers(${1:Player ply}, ${2:Entity ent})$0",
    "description": "(Server) Function: duplicator.ApplyBoneModifiers\n\nCalls every function registered with duplicator.RegisterBoneModifier on each bone the ent has."
  },
  "duplicator.ApplyEntityModifiers": {
    "prefix": "duplicator.ApplyEntityModifiers",
    "body": "duplicator.ApplyEntityModifiers(${1:Player ply}, ${2:Entity ent})$0",
    "description": "(Server) Function: duplicator.ApplyEntityModifiers\n\nCalls every function registered with duplicator.RegisterEntityModifier on the entity."
  },
  "duplicator.ClearEntityModifier": {
    "prefix": "duplicator.ClearEntityModifier",
    "body": "duplicator.ClearEntityModifier(${1:Entity ent}, ${2:any key})$0",
    "description": "(Server) Function: duplicator.ClearEntityModifier\n\nClears/removes the chosen entity modifier from the entity."
  },
  "duplicator.Copy": {
    "prefix": "duplicator.Copy",
    "body": "duplicator.Copy(${1:Entity ent}, ${2:table tableToAdd={}})$0",
    "description": "(Server) Function: duplicator.Copy\n\nCopies the entity, and all of its constraints and entities, then returns them in a table."
  },
  "duplicator.CopyEnts": {
    "prefix": "duplicator.CopyEnts",
    "body": "duplicator.CopyEnts(${1:table ents})$0",
    "description": "(Server) Function: duplicator.CopyEnts\n\nCopies the passed table of entities to save for later."
  },
  "duplicator.CopyEntTable": {
    "prefix": "duplicator.CopyEntTable",
    "body": "duplicator.CopyEntTable(${1:Entity ent})$0",
    "description": "(Server) Function: duplicator.CopyEntTable\n\nReturns a table with some entity data that can be used to create a new entity with duplicator.CreateEntityFromTable"
  },
  "duplicator.CreateConstraintFromTable": {
    "prefix": "duplicator.CreateConstraintFromTable",
    "body": "duplicator.CreateConstraintFromTable(${1:table constraint}, ${2:table entityList})$0",
    "description": "(Server) Function: duplicator.CreateConstraintFromTable\n\n[Internal]  Creates a constraint from a saved/copied constraint table."
  },
  "duplicator.CreateEntityFromTable": {
    "prefix": "duplicator.CreateEntityFromTable",
    "body": "duplicator.CreateEntityFromTable(${1:Player ply}, ${2:table entTable})$0",
    "description": "(Server) Function: duplicator.CreateEntityFromTable\n\n\"Create an entity from a table.\" "
  },
  "duplicator.DoBoneManipulator": {
    "prefix": "duplicator.DoBoneManipulator",
    "body": "duplicator.DoBoneManipulator(${1:Entity ent}, ${2:table bones})$0",
    "description": "(Server) Function: duplicator.DoBoneManipulator\n\n\"Restores the bone's data.\""
  },
  "duplicator.DoFlex": {
    "prefix": "duplicator.DoFlex",
    "body": "duplicator.DoFlex(${1:Entity ent}, ${2:table flex}, ${3:number scale=nil})$0",
    "description": "(Server) Function: duplicator.DoFlex\n\nRestores the flex data using Entity.SetFlexWeight and Entity.SetFlexScale"
  },
  "duplicator.DoGeneric": {
    "prefix": "duplicator.DoGeneric",
    "body": "duplicator.DoGeneric(${1:Entity ent}, ${2:table data})$0",
    "description": "(Server) Function: duplicator.DoGeneric\n\n\"Applies generic every-day entity stuff for ent from table data.\""
  },
  "duplicator.DoGenericPhysics": {
    "prefix": "duplicator.DoGenericPhysics",
    "body": "duplicator.DoGenericPhysics(${1:Entity ent}, ${2:Player ply=nil}, ${3:table data})$0",
    "description": "(Server) Function: duplicator.DoGenericPhysics\n\n\"Applies bone data, generically.\""
  },
  "duplicator.FindEntityClass": {
    "prefix": "duplicator.FindEntityClass",
    "body": "duplicator.FindEntityClass(${1:string name})$0",
    "description": "(Shared) Function: duplicator.FindEntityClass\n\nReturns the entity class factory registered with duplicator.RegisterEntityClass."
  },
  "duplicator.GenericDuplicatorFunction": {
    "prefix": "duplicator.GenericDuplicatorFunction",
    "body": "duplicator.GenericDuplicatorFunction(${1:Player ply}, ${2:table data})$0",
    "description": "(Server) Function: duplicator.GenericDuplicatorFunction\n\n\"Generic function for duplicating stuff\" "
  },
  "duplicator.GetAllConstrainedEntitiesAndConstraints": {
    "prefix": "duplicator.GetAllConstrainedEntitiesAndConstraints",
    "body": "duplicator.GetAllConstrainedEntitiesAndConstraints(${1:Entity ent}, ${2:table entStorageTable}, ${3:table constraintStorageTable})$0",
    "description": "(Server) Function: duplicator.GetAllConstrainedEntitiesAndConstraints\n\n[Internal]  Fills entStorageTable with all of the entities in a group connected with constraints. Fills constraintStorageTable with all of the constrains constraining the group."
  },
  "duplicator.IsAllowed": {
    "prefix": "duplicator.IsAllowed",
    "body": "duplicator.IsAllowed(${1:string classname})$0",
    "description": "(Shared) Function: duplicator.IsAllowed\n\nReturns whether the entity can be duplicated or not"
  },
  "duplicator.Paste": {
    "prefix": "duplicator.Paste",
    "body": "duplicator.Paste(${1:Player Player}, ${2:table EntityList}, ${3:table ConstraintList})$0",
    "description": "(Server) Function: duplicator.Paste\n\n\"Given entity list and constraint list, create all entities and return their tables\""
  },
  "duplicator.RegisterBoneModifier": {
    "prefix": "duplicator.RegisterBoneModifier",
    "body": "duplicator.RegisterBoneModifier(${1:any key}, ${2:function boneModifier})$0",
    "description": "(Shared) Function: duplicator.RegisterBoneModifier\n\nRegisters a function to be called on each of an entity's bones when duplicator.ApplyBoneModifiers is called."
  },
  "duplicator.RegisterConstraint": {
    "prefix": "duplicator.RegisterConstraint",
    "body": "duplicator.RegisterConstraint(${1:string name}, ${2:function callback}, ${3:any ...})$0",
    "description": "(Shared) Function: duplicator.RegisterConstraint\n\nRegister a function used for creating a duplicated constraint."
  },
  "duplicator.RegisterEntityClass": {
    "prefix": "duplicator.RegisterEntityClass",
    "body": "duplicator.RegisterEntityClass(${1:string name}, ${2:function function}, ${3:vararg args})$0",
    "description": "(Shared) Function: duplicator.RegisterEntityClass\n\nThis allows you to specify a specific function to be run when your SENT is pasted with the duplicator, instead of relying on the generic automatic functions."
  },
  "duplicator.RegisterEntityModifier": {
    "prefix": "duplicator.RegisterEntityModifier",
    "body": "duplicator.RegisterEntityModifier(${1:string name}, ${2:function func})$0",
    "description": "(Shared) Function: duplicator.RegisterEntityModifier\n\n"
  },
  "duplicator.RemoveMapCreatedEntities": {
    "prefix": "duplicator.RemoveMapCreatedEntities",
    "body": "duplicator.RemoveMapCreatedEntities()$0",
    "description": "(Server) Function: duplicator.RemoveMapCreatedEntities\n\nHelp to remove certain map created entities before creating the saved entities"
  },
  "duplicator.SetLocalAng": {
    "prefix": "duplicator.SetLocalAng",
    "body": "duplicator.SetLocalAng(${1:Angle v})$0",
    "description": "(Shared) Function: duplicator.SetLocalAng\n\n\"When a copy is copied it will be translated according to these."
  },
  "duplicator.SetLocalPos": {
    "prefix": "duplicator.SetLocalPos",
    "body": "duplicator.SetLocalPos(${1:Vector v})$0",
    "description": "(Shared) Function: duplicator.SetLocalPos\n\n\"When a copy is copied it will be translated according to these."
  },
  "duplicator.StoreBoneModifier": {
    "prefix": "duplicator.StoreBoneModifier",
    "body": "duplicator.StoreBoneModifier(${1:Entity ent}, ${2:number boneID}, ${3:any key}, ${4:table data})$0",
    "description": "(Server) Function: duplicator.StoreBoneModifier\n\nStores bone mod data for a registered bone modification function"
  },
  "duplicator.StoreEntityModifier": {
    "prefix": "duplicator.StoreEntityModifier",
    "body": "duplicator.StoreEntityModifier(${1:Entity entity}, ${2:string name}, ${3:table data})$0",
    "description": "(Server) Function: duplicator.StoreEntityModifier\n\nStores an entity modifier into an entity for saving"
  },
  "duplicator.WorkoutSize": {
    "prefix": "duplicator.WorkoutSize",
    "body": "duplicator.WorkoutSize(${1:table Ents})$0",
    "description": "(Server) Function: duplicator.WorkoutSize\n\n\"Work out the AABB size\""
  },
  "duplicator": [],
  "effects.Create": {
    "prefix": "effects.Create",
    "body": "effects.Create(${1:string name})$0",
    "description": "(Client) Function: effects.Create\n\n[Internal] .You are looking for util.Effect.Returns the table of the effect specified."
  },
  "effects.Register": {
    "prefix": "effects.Register",
    "body": "effects.Register(${1:table effect_table}, ${2:string name})$0",
    "description": "(Client) Function: effects.Register\n\n[Internal] Registers a new effect."
  },
  "effects": [],
  "engine.ActiveGamemode": {
    "prefix": "engine.ActiveGamemode",
    "body": "engine.ActiveGamemode()$0",
    "description": "(All) Function: engine.ActiveGamemode\n\nReturns the name of the currently running gamemode."
  },
  "engine.CloseServer": {
    "prefix": "engine.CloseServer",
    "body": "engine.CloseServer()$0",
    "description": "(Server) Function: engine.CloseServer\n\nCloses the server and completely exits."
  },
  "engine.GetAddons": {
    "prefix": "engine.GetAddons",
    "body": "engine.GetAddons()$0",
    "description": "(All) Function: engine.GetAddons\n\nGets the addons you have downloaded from the workshop."
  },
  "engine.GetDemoPlaybackStartTick": {
    "prefix": "engine.GetDemoPlaybackStartTick",
    "body": "engine.GetDemoPlaybackStartTick()$0",
    "description": "(Client and Menu) Function: engine.GetDemoPlaybackStartTick\n\nWhen starting playing a demo, engine.GetDemoPlaybackTick will be reset and its old value will be added to this functions return value."
  },
  "engine.GetDemoPlaybackTick": {
    "prefix": "engine.GetDemoPlaybackTick",
    "body": "engine.GetDemoPlaybackTick()$0",
    "description": "(Client and Menu) Function: engine.GetDemoPlaybackTick\n\nCurrent tick of currently loaded demo."
  },
  "engine.GetDemoPlaybackTimeScale": {
    "prefix": "engine.GetDemoPlaybackTimeScale",
    "body": "engine.GetDemoPlaybackTimeScale()$0",
    "description": "(Client and Menu) Function: engine.GetDemoPlaybackTimeScale\n\nReturns time scale of demo playback."
  },
  "engine.GetDemoPlaybackTotalTicks": {
    "prefix": "engine.GetDemoPlaybackTotalTicks",
    "body": "engine.GetDemoPlaybackTotalTicks()$0",
    "description": "(Client and Menu) Function: engine.GetDemoPlaybackTotalTicks\n\nReturns total amount of ticks of currently loaded demo."
  },
  "engine.GetGamemodes": {
    "prefix": "engine.GetGamemodes",
    "body": "engine.GetGamemodes()$0",
    "description": "(All) Function: engine.GetGamemodes\n\nReturns a table containing info for all installed gamemodes"
  },
  "engine.GetGames": {
    "prefix": "engine.GetGames",
    "body": "engine.GetGames()$0",
    "description": "(All) Function: engine.GetGames\n\nReturns an array of tables corresponding to all games from which Garry's Mod supports mounting content."
  },
  "engine.IsPlayingDemo": {
    "prefix": "engine.IsPlayingDemo",
    "body": "engine.IsPlayingDemo()$0",
    "description": "(Client and Menu) Function: engine.IsPlayingDemo\n\nReturns true if we're currently playing a demo."
  },
  "engine.IsRecordingDemo": {
    "prefix": "engine.IsRecordingDemo",
    "body": "engine.IsRecordingDemo()$0",
    "description": "(Client and Menu) Function: engine.IsRecordingDemo\n\nReturns true if the game is currently recording a demo file (.dem) using gm_demo"
  },
  "engine.LightStyle": {
    "prefix": "engine.LightStyle",
    "body": "engine.LightStyle(${1:number lightstyle}, ${2:string pattern})$0",
    "description": "(Server) Function: engine.LightStyle\n\nThis is a direct binding to the function engine->LightStyle. This function allows you to change the default light style of the map - so you can make lighting lighter or darker. Youll need to call render.RedownloadAllLightmaps clientside to refresh the lightmaps to this new color."
  },
  "engine.OpenDupe": {
    "prefix": "engine.OpenDupe",
    "body": "engine.OpenDupe(${1:string dupeName})$0",
    "description": "(Client) Function: engine.OpenDupe\n\nLoads a duplication from the local filesystem."
  },
  "engine.SetMounted": {
    "prefix": "engine.SetMounted",
    "body": "engine.SetMounted(${1:string depotID}, ${2:boolean doMount})$0",
    "description": "(Menu) Function: engine.SetMounted\n\nSets the mounting options for mountable content."
  },
  "engine.TickInterval": {
    "prefix": "engine.TickInterval",
    "body": "engine.TickInterval()$0",
    "description": "(All) Function: engine.TickInterval\n\nReturns the number of seconds between each gametick."
  },
  "engine.VideoSettings": {
    "prefix": "engine.VideoSettings",
    "body": "engine.VideoSettings()$0",
    "description": "(Client) Function: engine.VideoSettings\n\nReturns video recording settings set by video.Record. Used by Demo-To-Video feature."
  },
  "engine.WriteDupe": {
    "prefix": "engine.WriteDupe",
    "body": "engine.WriteDupe(${1:string dupe}, ${2:string jpeg})$0",
    "description": "(Client) Function: engine.WriteDupe\n\nSaves a duplication as a file."
  },
  "engine.WriteSave": {
    "prefix": "engine.WriteSave",
    "body": "engine.WriteSave(${1:string saveData}, ${2:string name}, ${3:number time}, ${4:string map})$0",
    "description": "(Client) Function: engine.WriteSave\n\nStores savedata into the game (can be loaded using the LoadGame menu)"
  },
  "engine": [],
  "ents.Create": {
    "prefix": "ents.Create",
    "body": "ents.Create(${1:string class})$0",
    "description": "(Server) Function: ents.Create\n\nCreates an entity. This function will fail and return NULL if the soft-edict limit is hit (8172), or the provided entity class doesn't exist."
  },
  "ents.CreateClientProp": {
    "prefix": "ents.CreateClientProp",
    "body": "ents.CreateClientProp(${1:string model=\"models/error.mdl\"})$0",
    "description": "(Client) Function: ents.CreateClientProp\n\nCreates a clientside only prop. See also _G.ClientsideModel."
  },
  "ents.FindByClass": {
    "prefix": "ents.FindByClass",
    "body": "ents.FindByClass(${1:string class})$0",
    "description": "(Shared) Function: ents.FindByClass\n\nGets all entities with the given class, supports wildcards. This works internally by iterating over ents.GetAll."
  },
  "ents.FindByClassAndParent": {
    "prefix": "ents.FindByClassAndParent",
    "body": "ents.FindByClassAndParent(${1:string class}, ${2:Entity parent})$0",
    "description": "(Shared) Function: ents.FindByClassAndParent\n\nFinds all entities that are of given class and are children of given entity. This works internally by iterating over ents.GetAll."
  },
  "ents.FindByModel": {
    "prefix": "ents.FindByModel",
    "body": "ents.FindByModel(${1:string model})$0",
    "description": "(Shared) Function: ents.FindByModel\n\nGets all entities with the given model, supports wildcards. This works internally by iterating over ents.GetAll."
  },
  "ents.FindByName": {
    "prefix": "ents.FindByName",
    "body": "ents.FindByName(${1:string name})$0",
    "description": "(Shared) Function: ents.FindByName\n\nGets all entities with the given hammer targetname. This works internally by iterating over ents.GetAll."
  },
  "ents.FindInBox": {
    "prefix": "ents.FindInBox",
    "body": "ents.FindInBox(${1:Vector boxMins}, ${2:Vector boxMaxs})$0",
    "description": "(Shared) Function: ents.FindInBox\n\nGets all entities within the specified box."
  },
  "ents.FindInCone": {
    "prefix": "ents.FindInCone",
    "body": "ents.FindInCone(${1:Vector origin}, ${2:Vector normal}, ${3:number radius}, ${4:number angle})$0",
    "description": "(Shared) Function: ents.FindInCone\n\nPerforms a ents.FindInBox and returns all entities within the specified cone."
  },
  "ents.FindInPVS": {
    "prefix": "ents.FindInPVS",
    "body": "ents.FindInPVS(${1:any viewPoint})$0",
    "description": "(Server) Function: ents.FindInPVS\n\nFinds all entities that lie within a [https://developer.valvesoftware.com/wiki/PVS PVS]."
  },
  "ents.FindInSphere": {
    "prefix": "ents.FindInSphere",
    "body": "ents.FindInSphere(${1:Vector origin}, ${2:number radius})$0",
    "description": "(Shared) Function: ents.FindInSphere\n\nGets all entities within the specified sphere."
  },
  "ents.FireTargets": {
    "prefix": "ents.FireTargets",
    "body": "ents.FireTargets(${1:string target}, ${2:Entity activator}, ${3:Entity caller}, ${4:number usetype}, ${5:number value})$0",
    "description": "(Server) Function: ents.FireTargets\n\nFires a use event."
  },
  "ents.GetAll": {
    "prefix": "ents.GetAll",
    "body": "ents.GetAll()$0",
    "description": "(Shared) Function: ents.GetAll\n\nReturns a table of all existing entities."
  },
  "ents.GetByIndex": {
    "prefix": "ents.GetByIndex",
    "body": "ents.GetByIndex(${1:number entIdx})$0",
    "description": "(Shared) Function: ents.GetByIndex\n\nReturns an entity by its index. Same as _G.Entity."
  },
  "ents.GetCount": {
    "prefix": "ents.GetCount",
    "body": "ents.GetCount(${1:boolean IncludeKillMe=false})$0",
    "description": "(Shared) Function: ents.GetCount\n\nGives you the amount of currently existing entities."
  },
  "ents.GetEdictCount": {
    "prefix": "ents.GetEdictCount",
    "body": "ents.GetEdictCount()$0",
    "description": "(Server) Function: ents.GetEdictCount\n\nReturns the amount of networked entities, which is limited to 8192. ents.Create will fail at 8176."
  },
  "ents.GetMapCreatedEntity": {
    "prefix": "ents.GetMapCreatedEntity",
    "body": "ents.GetMapCreatedEntity(${1:number id})$0",
    "description": "(Server) Function: ents.GetMapCreatedEntity\n\nReturns entity that has given Entity.MapCreationID."
  },
  "ents": [],
  "file.Append": {
    "prefix": "file.Append",
    "body": "file.Append(${1:string name}, ${2:string content})$0",
    "description": "(All) Function: file.Append\n\nAppends a file relative to the ''data'' folder."
  },
  "file.CreateDir": {
    "prefix": "file.CreateDir",
    "body": "file.CreateDir(${1:string name})$0",
    "description": "(All) Function: file.CreateDir\n\nCreates a directory that is relative to the ''data'' folder."
  },
  "file.Delete": {
    "prefix": "file.Delete",
    "body": "file.Delete(${1:string name})$0",
    "description": "(All) Function: file.Delete\n\nDeletes a file or ''empty'' folder that is relative to the '''data''' folder."
  },
  "file.Exists": {
    "prefix": "file.Exists",
    "body": "file.Exists(${1:string name}, ${2:string path})$0",
    "description": "(All) Function: file.Exists\n\nReturns a boolean of whether the file or directory exists or not."
  },
  "file.Find": {
    "prefix": "file.Find",
    "body": "file.Find(${1:string name}, ${2:string path}, ${3:string sorting=\"nameasc\"})$0",
    "description": "(All) Function: file.Find\n\nReturns a list of files and directories inside a single folder."
  },
  "file.IsDir": {
    "prefix": "file.IsDir",
    "body": "file.IsDir(${1:string fileName}, ${2:string path})$0",
    "description": "(All) Function: file.IsDir\n\nReturns if the given file is a directory."
  },
  "file.Open": {
    "prefix": "file.Open",
    "body": "file.Open(${1:string fileName}, ${2:string fileMode}, ${3:string path})$0",
    "description": "(All) Function: file.Open\n\nAttempts to open a file with the given mode."
  },
  "file.Read": {
    "prefix": "file.Read",
    "body": "file.Read(${1:string fileName}, ${2:string path=\"DATA\"})$0",
    "description": "(All) Function: file.Read\n\nReturns the content of a file."
  },
  "file.Size": {
    "prefix": "file.Size",
    "body": "file.Size(${1:string fileName}, ${2:string path})$0",
    "description": "(All) Function: file.Size\n\nReturns the file's size in bytes. If the file is not found, returns -1."
  },
  "file.Time": {
    "prefix": "file.Time",
    "body": "file.Time(${1:string path}, ${2:string gamePath})$0",
    "description": "(All) Function: file.Time\n\nReturns when the file or folder was lasted modified in Unix time."
  },
  "file.Write": {
    "prefix": "file.Write",
    "body": "file.Write(${1:string fileName}, ${2:string content})$0",
    "description": "(All) Function: file.Write\n\nWrites the given string to a file. Erases all previous data in the file. To add data without deleting previous data, use file.Append."
  },
  "file": [],
  "frame_blend.AddFrame": {
    "prefix": "frame_blend.AddFrame",
    "body": "frame_blend.AddFrame()$0",
    "description": "(Client) Function: frame_blend.AddFrame\n\n[Internal] "
  },
  "frame_blend.BlendFrame": {
    "prefix": "frame_blend.BlendFrame",
    "body": "frame_blend.BlendFrame()$0",
    "description": "(Client) Function: frame_blend.BlendFrame\n\n[Internal] "
  },
  "frame_blend.CompleteFrame": {
    "prefix": "frame_blend.CompleteFrame",
    "body": "frame_blend.CompleteFrame()$0",
    "description": "(Client) Function: frame_blend.CompleteFrame\n\n[Internal] "
  },
  "frame_blend.DrawPreview": {
    "prefix": "frame_blend.DrawPreview",
    "body": "frame_blend.DrawPreview()$0",
    "description": "(Client) Function: frame_blend.DrawPreview\n\n[Internal] "
  },
  "frame_blend.IsActive": {
    "prefix": "frame_blend.IsActive",
    "body": "frame_blend.IsActive()$0",
    "description": "(Client) Function: frame_blend.IsActive\n\nReturns whether frame blend post processing effect is enabled or not."
  },
  "frame_blend.IsLastFrame": {
    "prefix": "frame_blend.IsLastFrame",
    "body": "frame_blend.IsLastFrame()$0",
    "description": "(Client) Function: frame_blend.IsLastFrame\n\n[Internal] "
  },
  "frame_blend.RenderableFrames": {
    "prefix": "frame_blend.RenderableFrames",
    "body": "frame_blend.RenderableFrames()$0",
    "description": "(Client) Function: frame_blend.RenderableFrames\n\n[Internal] "
  },
  "frame_blend.ShouldSkipFrame": {
    "prefix": "frame_blend.ShouldSkipFrame",
    "body": "frame_blend.ShouldSkipFrame()$0",
    "description": "(Client) Function: frame_blend.ShouldSkipFrame\n\nReturns whether we should skip frame or not"
  },
  "frame_blend": [],
  "game.AddAmmoType": {
    "prefix": "game.AddAmmoType",
    "body": "game.AddAmmoType(${1:table ammoData})$0",
    "description": "(Shared) Function: game.AddAmmoType\n\nAdds a new ammo type to the game."
  },
  "game.AddDecal": {
    "prefix": "game.AddDecal",
    "body": "game.AddDecal(${1:string decalName}, ${2:string materialName})$0",
    "description": "(Shared) Function: game.AddDecal\n\nRegisters a new decal."
  },
  "game.AddParticles": {
    "prefix": "game.AddParticles",
    "body": "game.AddParticles(${1:string particleFileName})$0",
    "description": "(Shared) Function: game.AddParticles\n\nLoads a particle file."
  },
  "game.BuildAmmoTypes": {
    "prefix": "game.BuildAmmoTypes",
    "body": "game.BuildAmmoTypes()$0",
    "description": "(Shared) Function: game.BuildAmmoTypes\n\n[Internal] "
  },
  "game.CleanUpMap": {
    "prefix": "game.CleanUpMap",
    "body": "game.CleanUpMap(${1:boolean dontSendToClients=false}, ${2:table ExtraFilters={}})$0",
    "description": "(Shared) Function: game.CleanUpMap\n\nIf called serverside it will remove ALL entities which were not created by the map(not players or weapons held by players)."
  },
  "game.ConsoleCommand": {
    "prefix": "game.ConsoleCommand",
    "body": "game.ConsoleCommand(${1:string stringCommand})$0",
    "description": "(Server) Function: game.ConsoleCommand\n\nRuns a console command."
  },
  "game.GetAmmoID": {
    "prefix": "game.GetAmmoID",
    "body": "game.GetAmmoID(${1:string name})$0",
    "description": "(Shared) Function: game.GetAmmoID\n\nReturns the ammo type ID for given ammo type name."
  },
  "game.GetAmmoMax": {
    "prefix": "game.GetAmmoMax",
    "body": "game.GetAmmoMax(${1:number id})$0",
    "description": "(Shared) Function: game.GetAmmoMax\n\nReturns the real maximum amount of ammo of given ammo ID."
  },
  "game.GetAmmoName": {
    "prefix": "game.GetAmmoName",
    "body": "game.GetAmmoName(${1:number id})$0",
    "description": "(Shared) Function: game.GetAmmoName\n\nReturns the ammo name for given ammo type ID."
  },
  "game.GetGlobalCounter": {
    "prefix": "game.GetGlobalCounter",
    "body": "game.GetGlobalCounter(${1:string name})$0",
    "description": "(Server) Function: game.GetGlobalCounter\n\nReturns the counter of a Global State."
  },
  "game.GetGlobalState": {
    "prefix": "game.GetGlobalState",
    "body": "game.GetGlobalState(${1:string name})$0",
    "description": "(Server) Function: game.GetGlobalState\n\nReturns whether a Global State is off, active or dead ( inactive )"
  },
  "game.GetIPAddress": {
    "prefix": "game.GetIPAddress",
    "body": "game.GetIPAddress()$0",
    "description": "(Shared) Function: game.GetIPAddress\n\nReturns the public IP address and port of the current server. This will return the IP/port that you are connecting through when ran clientside."
  },
  "game.GetMap": {
    "prefix": "game.GetMap",
    "body": "game.GetMap()$0",
    "description": "(All) Function: game.GetMap\n\nReturns the name of the current map, without a file extension."
  },
  "game.GetMapNext": {
    "prefix": "game.GetMapNext",
    "body": "game.GetMapNext()$0",
    "description": "(Server) Function: game.GetMapNext\n\nReturns the next map that would be loaded according to the file that is set by the mapcyclefile convar."
  },
  "game.GetMapVersion": {
    "prefix": "game.GetMapVersion",
    "body": "game.GetMapVersion()$0",
    "description": "(Shared) Function: game.GetMapVersion\n\nReturns the VBSP version of the current map."
  },
  "game.GetSkillLevel": {
    "prefix": "game.GetSkillLevel",
    "body": "game.GetSkillLevel()$0",
    "description": "(Shared) Function: game.GetSkillLevel\n\nReturns the difficulty level of the game."
  },
  "game.GetTimeScale": {
    "prefix": "game.GetTimeScale",
    "body": "game.GetTimeScale()$0",
    "description": "(Shared) Function: game.GetTimeScale\n\nReturns the time scale of the game"
  },
  "game.GetWorld": {
    "prefix": "game.GetWorld",
    "body": "game.GetWorld()$0",
    "description": "(Shared) Function: game.GetWorld\n\nReturns the worldspawn entity."
  },
  "game.IsDedicated": {
    "prefix": "game.IsDedicated",
    "body": "game.IsDedicated()$0",
    "description": "(Shared) Function: game.IsDedicated\n\nReturns true if the server is a dedicated server, false if it is a [[wikipedia:Listen server.Listen server]] or a singleplayer game."
  },
  "game.KickID": {
    "prefix": "game.KickID",
    "body": "game.KickID(${1:string id}, ${2:string reason=\"No reason given\"})$0",
    "description": "(Server) Function: game.KickID\n\nKicks a player from the server. This can be ran before the player has spawned."
  },
  "game.LoadNextMap": {
    "prefix": "game.LoadNextMap",
    "body": "game.LoadNextMap()$0",
    "description": "(Server) Function: game.LoadNextMap\n\nLoads the next map according to the nextlevel convar, or from the current mapcycle file set by the respective convar."
  },
  "game.MapLoadType": {
    "prefix": "game.MapLoadType",
    "body": "game.MapLoadType()$0",
    "description": "(Server) Function: game.MapLoadType\n\nReturns the map load type of the current map."
  },
  "game.MaxPlayers": {
    "prefix": "game.MaxPlayers",
    "body": "game.MaxPlayers()$0",
    "description": "(Shared) Function: game.MaxPlayers\n\nReturns the maximum amount of players (including bots) that the server can have."
  },
  "game.MountGMA": {
    "prefix": "game.MountGMA",
    "body": "game.MountGMA(${1:string path})$0",
    "description": "(Shared) Function: game.MountGMA\n\nMounts a GMA addon from the disk. Any error models currently loaded that the mounted addon provides will be reloaded."
  },
  "game.RemoveRagdolls": {
    "prefix": "game.RemoveRagdolls",
    "body": "game.RemoveRagdolls()$0",
    "description": "(Shared) Function: game.RemoveRagdolls\n\nRemoves all the clientside ragdolls."
  },
  "game.SetGlobalCounter": {
    "prefix": "game.SetGlobalCounter",
    "body": "game.SetGlobalCounter(${1:string name}, ${2:number count})$0",
    "description": "(Server) Function: game.SetGlobalCounter\n\nSets the counter of a Global State."
  },
  "game.SetGlobalState": {
    "prefix": "game.SetGlobalState",
    "body": "game.SetGlobalState(${1:string name}, ${2:number state})$0",
    "description": "(Server) Function: game.SetGlobalState\n\nSets whether a Global State is off, active or dead ( inactive )"
  },
  "game.SetSkillLevel": {
    "prefix": "game.SetSkillLevel",
    "body": "game.SetSkillLevel(${1:number level})$0",
    "description": "(Server) Function: game.SetSkillLevel\n\nSets the difficulty level of the game, can be retrieved with game.GetSkillLevel."
  },
  "game.SetTimeScale": {
    "prefix": "game.SetTimeScale",
    "body": "game.SetTimeScale(${1:number timeScale})$0",
    "description": "(Server) Function: game.SetTimeScale\n\nSets the time scale of the game."
  },
  "game.SinglePlayer": {
    "prefix": "game.SinglePlayer",
    "body": "game.SinglePlayer()$0",
    "description": "(Shared) Function: game.SinglePlayer\n\nReturns whenever the current session is a single player game."
  },
  "game.StartSpot": {
    "prefix": "game.StartSpot",
    "body": "game.StartSpot()$0",
    "description": "(Shared) Function: game.StartSpot\n\nReturns position the player should start from, this is not the same thing as spawn points, it is used to properly transit the player between maps."
  },
  "game": [],
  "gameevent.Listen": {
    "prefix": "gameevent.Listen",
    "body": "gameevent.Listen(${1:string eventName})$0",
    "description": "(Shared) Function: gameevent.Listen\n\nAdd a game event listener."
  },
  "gameevent": [],
  "gamemode.Call": {
    "prefix": "gamemode.Call",
    "body": "gamemode.Call(${1:string name}, ${2:vararg args})$0",
    "description": "(Shared) Function: gamemode.Call\n\nCalled by the engine to call a hook within the loaded gamemode."
  },
  "gamemode.Get": {
    "prefix": "gamemode.Get",
    "body": "gamemode.Get(${1:string name})$0",
    "description": "(Shared) Function: gamemode.Get\n\n[Internal]  This returns the internally stored gamemode table."
  },
  "gamemode.Register": {
    "prefix": "gamemode.Register",
    "body": "gamemode.Register(${1:table gm}, ${2:string name}, ${3:string derived})$0",
    "description": "(Shared) Function: gamemode.Register\n\n[Internal] Called by the engine when a gamemode is being loaded."
  },
  "gamemode": [],
  "gmod.GetGamemode": {
    "prefix": "gmod.GetGamemode",
    "body": "gmod.GetGamemode()$0",
    "description": "(Shared) Function: gmod.GetGamemode\n\nReturns GlobalVar.GAMEMODE."
  },
  "gmod": [],
  "gmsave.LoadMap": {
    "prefix": "gmsave.LoadMap",
    "body": "gmsave.LoadMap(${1:string mapData}, ${2:Player ply})$0",
    "description": "(Server) Function: gmsave.LoadMap\n\nLoads a saved map."
  },
  "gmsave.PlayerLoad": {
    "prefix": "gmsave.PlayerLoad",
    "body": "gmsave.PlayerLoad(${1:Player ply}, ${2:table data})$0",
    "description": "(Server) Function: gmsave.PlayerLoad\n\nSets player position and angles from supplied table"
  },
  "gmsave.PlayerSave": {
    "prefix": "gmsave.PlayerSave",
    "body": "gmsave.PlayerSave(${1:Player ply})$0",
    "description": "(Server) Function: gmsave.PlayerSave\n\nReturns a table containing player position and angles. Used by gmsave.SaveMap."
  },
  "gmsave.SaveMap": {
    "prefix": "gmsave.SaveMap",
    "body": "gmsave.SaveMap(${1:Player ply})$0",
    "description": "(Server) Function: gmsave.SaveMap\n\nSaves the map"
  },
  "gmsave.ShouldSaveEntity": {
    "prefix": "gmsave.ShouldSaveEntity",
    "body": "gmsave.ShouldSaveEntity(${1:Entity ent}, ${2:table t})$0",
    "description": "(Server) Function: gmsave.ShouldSaveEntity\n\nReturns if we should save this entity in a duplication or a map save or not."
  },
  "gmsave": [],
  "gui.ActivateGameUI": {
    "prefix": "gui.ActivateGameUI",
    "body": "gui.ActivateGameUI()$0",
    "description": "(Client and Menu) Function: gui.ActivateGameUI\n\nOpens the game menu overlay."
  },
  "gui.EnableScreenClicker": {
    "prefix": "gui.EnableScreenClicker",
    "body": "gui.EnableScreenClicker(${1:boolean enabled})$0",
    "description": "(Client) Function: gui.EnableScreenClicker\n\nEnables the mouse cursor without restricting player movement, like using Sandbox's Context Menu"
  },
  "gui.HideGameUI": {
    "prefix": "gui.HideGameUI",
    "body": "gui.HideGameUI()$0",
    "description": "(Client and Menu) Function: gui.HideGameUI\n\nHides the game menu overlay."
  },
  "gui.InternalCursorMoved": {
    "prefix": "gui.InternalCursorMoved",
    "body": "gui.InternalCursorMoved(${1:number deltaX}, ${2:number deltaY})$0",
    "description": "(Client and Menu) Function: gui.InternalCursorMoved\n\nSimulates a mouse move with the given deltas."
  },
  "gui.InternalKeyCodePressed": {
    "prefix": "gui.InternalKeyCodePressed",
    "body": "gui.InternalKeyCodePressed(${1:number key})$0",
    "description": "(Client and Menu) Function: gui.InternalKeyCodePressed\n\nSimulates a key press for the given key."
  },
  "gui.InternalKeyCodeReleased": {
    "prefix": "gui.InternalKeyCodeReleased",
    "body": "gui.InternalKeyCodeReleased(${1:number key})$0",
    "description": "(Client and Menu) Function: gui.InternalKeyCodeReleased\n\nSimulates a key release for the given key."
  },
  "gui.InternalKeyCodeTyped": {
    "prefix": "gui.InternalKeyCodeTyped",
    "body": "gui.InternalKeyCodeTyped(${1:number key})$0",
    "description": "(Client and Menu) Function: gui.InternalKeyCodeTyped\n\nSimulates a key type typing to the specified key."
  },
  "gui.InternalKeyTyped": {
    "prefix": "gui.InternalKeyTyped",
    "body": "gui.InternalKeyTyped(${1:number code})$0",
    "description": "(Client and Menu) Function: gui.InternalKeyTyped\n\nSimulates an ASCII symbol writing."
  },
  "gui.InternalMouseDoublePressed": {
    "prefix": "gui.InternalMouseDoublePressed",
    "body": "gui.InternalMouseDoublePressed(${1:number key})$0",
    "description": "(Client and Menu) Function: gui.InternalMouseDoublePressed\n\nSimulates a double mouse key press for the given mouse key."
  },
  "gui.InternalMousePressed": {
    "prefix": "gui.InternalMousePressed",
    "body": "gui.InternalMousePressed(${1:number key})$0",
    "description": "(Client and Menu) Function: gui.InternalMousePressed\n\nSimulates a mouse key press for the given mouse key."
  },
  "gui.InternalMouseReleased": {
    "prefix": "gui.InternalMouseReleased",
    "body": "gui.InternalMouseReleased(${1:number key})$0",
    "description": "(Client and Menu) Function: gui.InternalMouseReleased\n\nSimulates a mouse key release for the given mouse key."
  },
  "gui.InternalMouseWheeled": {
    "prefix": "gui.InternalMouseWheeled",
    "body": "gui.InternalMouseWheeled(${1:number delta})$0",
    "description": "(Client and Menu) Function: gui.InternalMouseWheeled\n\nSimulates a mouse wheel scroll with the given delta."
  },
  "gui.IsConsoleVisible": {
    "prefix": "gui.IsConsoleVisible",
    "body": "gui.IsConsoleVisible()$0",
    "description": "(Client and Menu) Function: gui.IsConsoleVisible\n\nReturns whether the console is visible or not."
  },
  "gui.IsGameUIVisible": {
    "prefix": "gui.IsGameUIVisible",
    "body": "gui.IsGameUIVisible()$0",
    "description": "(Client and Menu) Function: gui.IsGameUIVisible\n\nReturns whenever the game menu overlay ( main menu ) is open or not."
  },
  "gui.MousePos": {
    "prefix": "gui.MousePos",
    "body": "gui.MousePos()$0",
    "description": "(Client and Menu) Function: gui.MousePos\n\nReturns the cursor's position on the screen"
  },
  "gui.MouseX": {
    "prefix": "gui.MouseX",
    "body": "gui.MouseX()$0",
    "description": "(Client and Menu) Function: gui.MouseX\n\nReturns x component of the mouse position."
  },
  "gui.MouseY": {
    "prefix": "gui.MouseY",
    "body": "gui.MouseY()$0",
    "description": "(Client and Menu) Function: gui.MouseY\n\nReturns y component of the mouse position."
  },
  "gui.OpenURL": {
    "prefix": "gui.OpenURL",
    "body": "gui.OpenURL(${1:string url})$0",
    "description": "(Client and Menu) Function: gui.OpenURL\n\nOpens specified URL in the steam overlay browser. The URL has to start with either http:// or https://"
  },
  "gui.ScreenToVector": {
    "prefix": "gui.ScreenToVector",
    "body": "gui.ScreenToVector(${1:number x}, ${2:number y})$0",
    "description": "(Client) Function: gui.ScreenToVector\n\nConverts the specified screen position to a '''direction''' vector local to the player's view. A related function is Vector.ToScreen, which translates a 3D position to a screen coordinate."
  },
  "gui.SetMousePos": {
    "prefix": "gui.SetMousePos",
    "body": "gui.SetMousePos(${1:number mouseX}, ${2:number mouseY})$0",
    "description": "(Client and Menu) Function: gui.SetMousePos\n\n[Deprecated] .Use input.SetCursorPos instead."
  },
  "gui.ShowConsole": {
    "prefix": "gui.ShowConsole",
    "body": "gui.ShowConsole()$0",
    "description": "(Menu) Function: gui.ShowConsole\n\nShows console in the game UI."
  },
  "gui": [],
  "GWEN.CreateTextureBorder": {
    "prefix": "GWEN.CreateTextureBorder",
    "body": "GWEN.CreateTextureBorder(${1:number x}, ${2:number y}, ${3:number w}, ${4:number h}, ${5:number left}, ${6:number top}, ${7:number right}, ${8:number bottom})$0",
    "description": "(Client and Menu) Function: GWEN.CreateTextureBorder\n\nUsed in derma skins to create a bordered rectangle drawing function from an image. The texture is taken from SKIN.GwenTexture"
  },
  "GWEN.CreateTextureCentered": {
    "prefix": "GWEN.CreateTextureCentered",
    "body": "GWEN.CreateTextureCentered(${1:number x}, ${2:number y}, ${3:number w}, ${4:number h})$0",
    "description": "(Client and Menu) Function: GWEN.CreateTextureCentered\n\nUsed in derma skins to create a rectangle drawing function from an image. The rectangle will not be scaled, but instead it will be drawn in the center of the box. The texture is taken from SKIN.GwenTexture"
  },
  "GWEN.CreateTextureNormal": {
    "prefix": "GWEN.CreateTextureNormal",
    "body": "GWEN.CreateTextureNormal(${1:number x}, ${2:number y}, ${3:number w}, ${4:number h})$0",
    "description": "(Client and Menu) Function: GWEN.CreateTextureNormal\n\nUsed in derma skins to create a rectangle drawing function from an image. The texture of the rectangle will be scaled. The texture is taken from SKIN.GwenTexture"
  },
  "GWEN.TextureColor": {
    "prefix": "GWEN.TextureColor",
    "body": "GWEN.TextureColor(${1:number x}, ${2:number y})$0",
    "description": "(Client and Menu) Function: GWEN.TextureColor\n\nWhen used in a material skin, it returns a color value from a point in the skin image."
  },
  "GWEN": [],
  "halo.Add": {
    "prefix": "halo.Add",
    "body": "halo.Add(${1:table entities}, ${2:table color}, ${3:number blurX=2}, ${4:number blurY=2}, ${5:number passes=1}, ${6:boolean additive=true}, ${7:boolean ignoreZ=false})$0",
    "description": "(Client) Function: halo.Add\n\nApplies a \"halo\" glow effect to one or multiple entities."
  },
  "halo.Render": {
    "prefix": "halo.Render",
    "body": "halo.Render(${1:table entry})$0",
    "description": "(Client) Function: halo.Render\n\n[Internal] Renders a halo according to the specified table, only used internally, called from a PostDrawEffects hook added by the halo library"
  },
  "halo.RenderedEntity": {
    "prefix": "halo.RenderedEntity",
    "body": "halo.RenderedEntity()$0",
    "description": "(Client) Function: halo.RenderedEntity\n\nReturns the entity the halo library is currently rendering the halo for."
  },
  "halo": [],
  "hammer.SendCommand": {
    "prefix": "hammer.SendCommand",
    "body": "hammer.SendCommand(${1:string cmd})$0",
    "description": "(Server) Function: hammer.SendCommand\n\nSends command to Hammer, if Hammer is running with the current map loaded."
  },
  "hammer": [],
  "hook.Add": {
    "prefix": "hook.Add",
    "body": "hook.Add(${1:string eventName}, ${2:any identifier}, ${3:function func})$0",
    "description": "(All) Function: hook.Add\n\nAdd a hook to be called upon the given event occurring."
  },
  "hook.Call": {
    "prefix": "hook.Call",
    "body": "hook.Call(${1:string eventName}, ${2:table gamemodeTable}, ${3:vararg args})$0",
    "description": "(All) Function: hook.Call\n\nCalls all hooks associated with the given event until one returns something other than nil, and then returns that data."
  },
  "hook.GetTable": {
    "prefix": "hook.GetTable",
    "body": "hook.GetTable()$0",
    "description": "(All) Function: hook.GetTable\n\nReturns a list of all the hooks registered with hook.Add."
  },
  "hook.Remove": {
    "prefix": "hook.Remove",
    "body": "hook.Remove(${1:string eventName}, ${2:any identifier})$0",
    "description": "(All) Function: hook.Remove\n\nRemoves the hook with the supplied identifier from the given event."
  },
  "hook.Run": {
    "prefix": "hook.Run",
    "body": "hook.Run(${1:string eventName}, ${2:vararg args})$0",
    "description": "(All) Function: hook.Run\n\nCalls hooks associated with the given event."
  },
  "hook": [],
  "http.Fetch": {
    "prefix": "http.Fetch",
    "body": "http.Fetch(${1:string url}, ${2:function onSuccess=nil}, ${3:function onFailure=nil}, ${4:table headers={}})$0",
    "description": "(All) Function: http.Fetch\n\nLaunches a GET request."
  },
  "http.Post": {
    "prefix": "http.Post",
    "body": "http.Post(${1:string url}, ${2:table parameters}, ${3:function onSuccess=nil}, ${4:function onFailure=nil}, ${5:table headers={}})$0",
    "description": "(All) Function: http.Post\n\nSends an asynchronous POST request to a HTTP server."
  },
  "http": [],
  "input.CheckKeyTrapping": {
    "prefix": "input.CheckKeyTrapping",
    "body": "input.CheckKeyTrapping()$0",
    "description": "(Client and Menu) Function: input.CheckKeyTrapping\n\nReturns the last key captured by key trapping."
  },
  "input.GetCursorPos": {
    "prefix": "input.GetCursorPos",
    "body": "input.GetCursorPos()$0",
    "description": "(Client and Menu) Function: input.GetCursorPos\n\nReturns the cursor's position on the screen"
  },
  "input.GetKeyName": {
    "prefix": "input.GetKeyName",
    "body": "input.GetKeyName(${1:number button})$0",
    "description": "(Client and Menu) Function: input.GetKeyName\n\nGets the button name from a numeric button code. The name needs to be translated with language.GetPhrase before being displayed."
  },
  "input.IsButtonDown": {
    "prefix": "input.IsButtonDown",
    "body": "input.IsButtonDown(${1:number button})$0",
    "description": "(Client and Menu) Function: input.IsButtonDown\n\nGets whether the specified button code is down."
  },
  "input.IsControlDown": {
    "prefix": "input.IsControlDown",
    "body": "input.IsControlDown()$0",
    "description": "(Client and Menu) Function: input.IsControlDown\n\nReturns whether a control key is being pressed"
  },
  "input.IsKeyDown": {
    "prefix": "input.IsKeyDown",
    "body": "input.IsKeyDown(${1:number key})$0",
    "description": "(Client and Menu) Function: input.IsKeyDown\n\nGets whether a key is down"
  },
  "input.IsKeyTrapping": {
    "prefix": "input.IsKeyTrapping",
    "body": "input.IsKeyTrapping()$0",
    "description": "(Client and Menu) Function: input.IsKeyTrapping\n\nReturns whether key trapping is activate and the next key press will be captured."
  },
  "input.IsMouseDown": {
    "prefix": "input.IsMouseDown",
    "body": "input.IsMouseDown(${1:number mouseKey})$0",
    "description": "(Client and Menu) Function: input.IsMouseDown\n\nGets whether a mouse button is down"
  },
  "input.IsShiftDown": {
    "prefix": "input.IsShiftDown",
    "body": "input.IsShiftDown()$0",
    "description": "(Client and Menu) Function: input.IsShiftDown\n\nGets whether a shift key is being pressed"
  },
  "input.LookupBinding": {
    "prefix": "input.LookupBinding",
    "body": "input.LookupBinding(${1:string binding}, ${2:boolean exact=false})$0",
    "description": "(Client and Menu) Function: input.LookupBinding\n\nGets the match uppercase key for the specified binding."
  },
  "input.LookupKeyBinding": {
    "prefix": "input.LookupKeyBinding",
    "body": "input.LookupKeyBinding(${1:number key})$0",
    "description": "(Client and Menu) Function: input.LookupKeyBinding\n\nReturns the bind string that the given key is bound to."
  },
  "input.SelectWeapon": {
    "prefix": "input.SelectWeapon",
    "body": "input.SelectWeapon(${1:Weapon weapon})$0",
    "description": "(Client) Function: input.SelectWeapon\n\nNextUpdateSwitches to the provided weapon on the next CUserCmd generation/CreateMove call. Direct binding to [https://github.com/LestaD/SourceEngine2007/blob/43a5c90a5ada1e69ca044595383be67f40b33c61/se2007/game/client/in_main.cpp#L929-L932 CInput::MakeWeaponSelection]."
  },
  "input.SetCursorPos": {
    "prefix": "input.SetCursorPos",
    "body": "input.SetCursorPos(${1:number mouseX}, ${2:number mouseY})$0",
    "description": "(Client and Menu) Function: input.SetCursorPos\n\nSets the cursor's position on the screen, relative to the topleft corner of the window"
  },
  "input.StartKeyTrapping": {
    "prefix": "input.StartKeyTrapping",
    "body": "input.StartKeyTrapping()$0",
    "description": "(Client and Menu) Function: input.StartKeyTrapping\n\nBegins waiting for a key to be pressed so we can save it for input.CheckKeyTrapping. Used by the DBinder."
  },
  "input.WasKeyPressed": {
    "prefix": "input.WasKeyPressed",
    "body": "input.WasKeyPressed(${1:number key})$0",
    "description": "(Client and Menu) Function: input.WasKeyPressed\n\nReturns whether a key was initially pressed in the same frame this function was called."
  },
  "input.WasKeyReleased": {
    "prefix": "input.WasKeyReleased",
    "body": "input.WasKeyReleased(${1:number key})$0",
    "description": "(Client and Menu) Function: input.WasKeyReleased\n\nReturns whether a key was released in the same frame this function was called."
  },
  "input.WasKeyTyped": {
    "prefix": "input.WasKeyTyped",
    "body": "input.WasKeyTyped(${1:number key})$0",
    "description": "(Client and Menu) Function: input.WasKeyTyped\n\nReturns whether the key is being held down or not."
  },
  "input.WasMouseDoublePressed": {
    "prefix": "input.WasMouseDoublePressed",
    "body": "input.WasMouseDoublePressed(${1:number button})$0",
    "description": "(Client and Menu) Function: input.WasMouseDoublePressed\n\nReturns whether a mouse key was double pressed in the same frame this function was called."
  },
  "input.WasMousePressed": {
    "prefix": "input.WasMousePressed",
    "body": "input.WasMousePressed(${1:number key})$0",
    "description": "(Client and Menu) Function: input.WasMousePressed\n\nReturns whether a mouse key was initially pressed in the same frame this function was called."
  },
  "input": [],
  "jit.attach": {
    "prefix": "jit.attach",
    "body": "jit.attach(${1:function callback}, ${2:string event})$0",
    "description": "(All) Function: jit.attach\n\nYou can attach callbacks to a number of compiler events with jit.attach. The callback can be called:"
  },
  "jit.flush": {
    "prefix": "jit.flush",
    "body": "jit.flush()$0",
    "description": "(All) Function: jit.flush\n\nFlushes the whole cache of compiled code."
  },
  "jit.off": {
    "prefix": "jit.off",
    "body": "jit.off()$0",
    "description": "(All) Function: jit.off\n\nDisables LuaJIT Lua compilation."
  },
  "jit.on": {
    "prefix": "jit.on",
    "body": "jit.on()$0",
    "description": "(All) Function: jit.on\n\nEnables LuaJIT Lua compilation."
  },
  "jit.status": {
    "prefix": "jit.status",
    "body": "jit.status()$0",
    "description": "(All) Function: jit.status\n\nReturns the status of the JIT compiler and the current optimizations enabled."
  },
  "jit": [],
  "killicon.Add": {
    "prefix": "killicon.Add",
    "body": "killicon.Add(${1:string class}, ${2:string texture}, ${3:table color})$0",
    "description": "(Client) Function: killicon.Add\n\nCreates new kill icon using a texture."
  },
  "killicon.AddAlias": {
    "prefix": "killicon.AddAlias",
    "body": "killicon.AddAlias(${1:string new_class}, ${2:string existing_class})$0",
    "description": "(Client) Function: killicon.AddAlias\n\nCreates kill icon from existing one."
  },
  "killicon.AddFont": {
    "prefix": "killicon.AddFont",
    "body": "killicon.AddFont(${1:string class}, ${2:string font}, ${3:string symbol}, ${4:table color})$0",
    "description": "(Client) Function: killicon.AddFont\n\nAdds kill icon for given weapon/entity class using special font."
  },
  "killicon.Draw": {
    "prefix": "killicon.Draw",
    "body": "killicon.Draw(${1:number x}, ${2:number y}, ${3:string name}, ${4:number alpha})$0",
    "description": "(Client) Function: killicon.Draw\n\nDraws a kill icon."
  },
  "killicon.Exists": {
    "prefix": "killicon.Exists",
    "body": "killicon.Exists(${1:string class})$0",
    "description": "(Client) Function: killicon.Exists\n\nChecks if kill icon exists for given class."
  },
  "killicon.GetSize": {
    "prefix": "killicon.GetSize",
    "body": "killicon.GetSize(${1:string name})$0",
    "description": "(Client) Function: killicon.GetSize\n\nReturns the size of a kill icon."
  },
  "killicon": [],
  "language.Add": {
    "prefix": "language.Add",
    "body": "language.Add(${1:string placeholder}, ${2:string fulltext})$0",
    "description": "(Client and Menu) Function: language.Add\n\nAdds a language item. Language placeholders preceded with \"#\" are replaced with full text in Garry's Mod once registered with this function."
  },
  "language.GetPhrase": {
    "prefix": "language.GetPhrase",
    "body": "language.GetPhrase(${1:string phrase})$0",
    "description": "(Client and Menu) Function: language.GetPhrase\n\nRetrieves the translated version of inputted string. Useful for concentrating multiple translated strings."
  },
  "language": [],
  "list.Add": {
    "prefix": "list.Add",
    "body": "list.Add(${1:string identifier}, ${2:any item})$0",
    "description": "(All) Function: list.Add\n\nAdds an item to a named list"
  },
  "list.Contains": {
    "prefix": "list.Contains",
    "body": "list.Contains(${1:string list}, ${2:any value})$0",
    "description": "(All) Function: list.Contains\n\nReturns true if the list contains the value. (as a value - not a key)"
  },
  "list.Get": {
    "prefix": "list.Get",
    "body": "list.Get(${1:string identifier})$0",
    "description": "(All) Function: list.Get\n\nReturns a copy of the list stored at identifier"
  },
  "list.GetForEdit": {
    "prefix": "list.GetForEdit",
    "body": "list.GetForEdit(${1:string identifier})$0",
    "description": "(All) Function: list.GetForEdit\n\nReturns the actual table of the list stored at identifier. Modifying this will affect the stored list"
  },
  "list.Set": {
    "prefix": "list.Set",
    "body": "list.Set(${1:string identifier}, ${2:any key}, ${3:any item})$0",
    "description": "(All) Function: list.Set\n\nSets a specific position in the named list to a value."
  },
  "list": [],
  "markup.Parse": {
    "prefix": "markup.Parse",
    "body": "markup.Parse(${1:string markup}, ${2:number maxwidth})$0",
    "description": "(Client) Function: markup.Parse\n\nParses markup into a  MarkupObject."
  },
  "markup": [],
  "math.abs": {
    "prefix": "math.abs",
    "body": "math.abs(${1:number x})$0",
    "description": "(All) Function: math.abs\n\nCalculates the absolute value of a number (effectively removes any negative sign)."
  },
  "math.acos": {
    "prefix": "math.acos",
    "body": "math.acos(${1:number normal})$0",
    "description": "(All) Function: math.acos\n\nReturns the arc cosine of the given number."
  },
  "math.AngleDifference": {
    "prefix": "math.AngleDifference",
    "body": "math.AngleDifference(${1:number a}, ${2:number b})$0",
    "description": "(All) Function: math.AngleDifference\n\nCalculates the difference between two angles."
  },
  "math.Approach": {
    "prefix": "math.Approach",
    "body": "math.Approach(${1:number current}, ${2:number target}, ${3:number change})$0",
    "description": "(All) Function: math.Approach\n\nGradually approaches the target value by the specified amount."
  },
  "math.ApproachAngle": {
    "prefix": "math.ApproachAngle",
    "body": "math.ApproachAngle(${1:number currentAngle}, ${2:number targetAngle}, ${3:number rate})$0",
    "description": "(All) Function: math.ApproachAngle\n\nIncrements an angle towards another by specified rate."
  },
  "math.asin": {
    "prefix": "math.asin",
    "body": "math.asin(${1:number normal})$0",
    "description": "(All) Function: math.asin\n\nReturns the arc sine of the given number."
  },
  "math.atan": {
    "prefix": "math.atan",
    "body": "math.atan(${1:number normal})$0",
    "description": "(All) Function: math.atan\n\nReturns the arc tangents of the given number."
  },
  "math.atan2": {
    "prefix": "math.atan2",
    "body": "math.atan2(${1:number y}, ${2:number x})$0",
    "description": "(All) Function: math.atan2\n\nReturns math.atan(y / x) in radians. The result is between -math.pi and math.pi."
  },
  "math.BinToInt": {
    "prefix": "math.BinToInt",
    "body": "math.BinToInt(${1:string string})$0",
    "description": "(All) Function: math.BinToInt\n\nConverts a binary string into a number."
  },
  "math.BSplinePoint": {
    "prefix": "math.BSplinePoint",
    "body": "math.BSplinePoint(${1:number tDiff}, ${2:table tPoints}, ${3:number tMax})$0",
    "description": "(All) Function: math.BSplinePoint\n\nBasic code for [[wikipedia:Bzier curve.Bzier-Spline]] algorithm."
  },
  "math.calcBSplineN": {
    "prefix": "math.calcBSplineN",
    "body": "math.calcBSplineN(${1:number i}, ${2:number k}, ${3:number t}, ${4:number tinc})$0",
    "description": "(All) Function: math.calcBSplineN\n\nBasic code for Bezier-Spline algorithm."
  },
  "math.ceil": {
    "prefix": "math.ceil",
    "body": "math.ceil(${1:number number})$0",
    "description": "(All) Function: math.ceil\n\nCeils or rounds a number up."
  },
  "math.Clamp": {
    "prefix": "math.Clamp",
    "body": "math.Clamp(${1:number input}, ${2:number min}, ${3:number max})$0",
    "description": "(All) Function: math.Clamp\n\nClamps a number between a minimum and maximum value"
  },
  "math.cos": {
    "prefix": "math.cos",
    "body": "math.cos(${1:number number})$0",
    "description": "(All) Function: math.cos\n\nReturns cosine of given angle."
  },
  "math.cosh": {
    "prefix": "math.cosh",
    "body": "math.cosh(${1:number number})$0",
    "description": "(All) Function: math.cosh\n\nReturns hyperbolic cosine of the given number."
  },
  "math.deg": {
    "prefix": "math.deg",
    "body": "math.deg(${1:number radians})$0",
    "description": "(All) Function: math.deg\n\nConverts radians to degrees."
  },
  "math.Dist": {
    "prefix": "math.Dist",
    "body": "math.Dist(${1:number x1}, ${2:number y1}, ${3:number x2}, ${4:number y2})$0",
    "description": "(All) Function: math.Dist\n\n[Deprecated] .You should use math.Distance instead"
  },
  "math.Distance": {
    "prefix": "math.Distance",
    "body": "math.Distance(${1:number x1}, ${2:number y1}, ${3:number x2}, ${4:number y2})$0",
    "description": "(All) Function: math.Distance\n\nReturns the difference between two points in 2D space."
  },
  "math.EaseInOut": {
    "prefix": "math.EaseInOut",
    "body": "math.EaseInOut(${1:number progress}, ${2:number easeIn}, ${3:number easeOut})$0",
    "description": "(All) Function: math.EaseInOut\n\nCalculates the progress of a value fraction, taking in to account given easing fractions"
  },
  "math.exp": {
    "prefix": "math.exp",
    "body": "math.exp(${1:number exponent})$0",
    "description": "(All) Function: math.exp\n\nReturns the x power of the euler constant."
  },
  "math.floor": {
    "prefix": "math.floor",
    "body": "math.floor(${1:number number})$0",
    "description": "(All) Function: math.floor\n\nFloors or rounds a number down."
  },
  "math.fmod": {
    "prefix": "math.fmod",
    "body": "math.fmod(${1:number base}, ${2:number modulator})$0",
    "description": "(All) Function: math.fmod\n\nReturns the modulus of the specified values."
  },
  "math.frexp": {
    "prefix": "math.frexp",
    "body": "math.frexp(${1:number inputValue})$0",
    "description": "(All) Function: math.frexp\n\nused to split the number value into a normalized fraction and an exponent. Two values are returned: the first is a value always in the range 1/2 (inclusive) to 1 (exclusive) and the second is an exponent."
  },
  "math.IntToBin": {
    "prefix": "math.IntToBin",
    "body": "math.IntToBin(${1:number int})$0",
    "description": "(All) Function: math.IntToBin\n\nConverts an integer to a binary (base-2) string."
  },
  "math.ldexp": {
    "prefix": "math.ldexp",
    "body": "math.ldexp(${1:number normalizedFraction}, ${2:number exponent})$0",
    "description": "(All) Function: math.ldexp\n\nTakes a normalised number and returns the floating point representation."
  },
  "math.log": {
    "prefix": "math.log",
    "body": "math.log(${1:number x}, ${2:number base=math.exp(1)})$0",
    "description": "(All) Function: math.log\n\nWith one argument, return the natural logarithm of x (to base e)."
  },
  "math.log10": {
    "prefix": "math.log10",
    "body": "math.log10(${1:number x})$0",
    "description": "(All) Function: math.log10\n\nReturns the base-10 logarithm of x. This is usually more accurate than math.log(x, 10)."
  },
  "math.max": {
    "prefix": "math.max",
    "body": "math.max(${1:vararg numbers})$0",
    "description": "(All) Function: math.max\n\nReturns the largest value of all arguments."
  },
  "math.min": {
    "prefix": "math.min",
    "body": "math.min(${1:vararg numbers})$0",
    "description": "(All) Function: math.min\n\nReturns the smallest value of all arguments."
  },
  "math.mod": {
    "prefix": "math.mod",
    "body": "math.mod(${1:number base}, ${2:number modulator})$0",
    "description": "(All) Function: math.mod\n\n[Deprecated] .This is removed in Lua versions later than what GMod is currently using. You should use the % operator or math.fmod instead."
  },
  "math.modf": {
    "prefix": "math.modf",
    "body": "math.modf(${1:number base})$0",
    "description": "(All) Function: math.modf\n\nReturns the integral and fractional component of the modulo operation."
  },
  "math.NormalizeAngle": {
    "prefix": "math.NormalizeAngle",
    "body": "math.NormalizeAngle(${1:number angle})$0",
    "description": "(All) Function: math.NormalizeAngle\n\nNormalizes angle, so it returns value between -180 and 180."
  },
  "math.pow": {
    "prefix": "math.pow",
    "body": "math.pow(${1:number x}, ${2:number y})$0",
    "description": "(All) Function: math.pow\n\nReturns x raised to the power y."
  },
  "math.rad": {
    "prefix": "math.rad",
    "body": "math.rad(${1:number degrees})$0",
    "description": "(All) Function: math.rad\n\nConverts an angle in degrees to it's equivalent in radians."
  },
  "math.Rand": {
    "prefix": "math.Rand",
    "body": "math.Rand(${1:number min}, ${2:number max})$0",
    "description": "(All) Function: math.Rand\n\nReturns a random float between min and max."
  },
  "math.random": {
    "prefix": "math.random",
    "body": "math.random(${1:number m}, ${2:number n})$0",
    "description": "(All) Function: math.random\n\nWhen called without arguments, returns a uniform pseudo-random real number in the range 0 to 1 which includes 0 but excludes 1."
  },
  "math.randomseed": {
    "prefix": "math.randomseed",
    "body": "math.randomseed(${1:number seed})$0",
    "description": "(All) Function: math.randomseed\n\nSeeds the random number generator. The same seed will guarantee the same sequence of numbers each time with math.random."
  },
  "math.Remap": {
    "prefix": "math.Remap",
    "body": "math.Remap(${1:number value}, ${2:number inMin}, ${3:number inMax}, ${4:number outMin}, ${5:number outMax})$0",
    "description": "(All) Function: math.Remap\n\nRemaps the value from one range to another"
  },
  "math.Round": {
    "prefix": "math.Round",
    "body": "math.Round(${1:number value}, ${2:number decimals=0})$0",
    "description": "(All) Function: math.Round\n\nRounds the given value to the nearest whole number or to the given decimal places."
  },
  "math.sin": {
    "prefix": "math.sin",
    "body": "math.sin(${1:number number})$0",
    "description": "(All) Function: math.sin\n\nReturns sine of given angle."
  },
  "math.sinh": {
    "prefix": "math.sinh",
    "body": "math.sinh(${1:number number})$0",
    "description": "(All) Function: math.sinh\n\nReturns hyperbolic sine of the given number."
  },
  "math.sqrt": {
    "prefix": "math.sqrt",
    "body": "math.sqrt(${1:number value})$0",
    "description": "(All) Function: math.sqrt\n\nReturns the square root of the number."
  },
  "math.tan": {
    "prefix": "math.tan",
    "body": "math.tan(${1:number value})$0",
    "description": "(All) Function: math.tan\n\nReturns tangents of given angle."
  },
  "math.tanh": {
    "prefix": "math.tanh",
    "body": "math.tanh(${1:number number})$0",
    "description": "(All) Function: math.tanh\n\nReturns hyperbolic tangents of the given number."
  },
  "math.TimeFraction": {
    "prefix": "math.TimeFraction",
    "body": "math.TimeFraction(${1:number start}, ${2:number end}, ${3:number current})$0",
    "description": "(All) Function: math.TimeFraction\n\nReturns the fraction of where the current time is relative to the start and end times"
  },
  "math.Truncate": {
    "prefix": "math.Truncate",
    "body": "math.Truncate(${1:number num}, ${2:number digits})$0",
    "description": "(All) Function: math.Truncate\n\nRounds towards zero."
  },
  "math": [],
  "matproxy.Add": {
    "prefix": "matproxy.Add",
    "body": "matproxy.Add(${1:table MatProxyData})$0",
    "description": "(Client) Function: matproxy.Add\n\nAdds a material proxy."
  },
  "matproxy.Call": {
    "prefix": "matproxy.Call",
    "body": "matproxy.Call(${1:string uname}, ${2:IMaterial mat}, ${3:Entity ent})$0",
    "description": "(Client) Function: matproxy.Call\n\nCalled by the engine from OnBind"
  },
  "matproxy.Init": {
    "prefix": "matproxy.Init",
    "body": "matproxy.Init(${1:string name}, ${2:string uname}, ${3:IMaterial mat}, ${4:table values})$0",
    "description": "(Client) Function: matproxy.Init\n\nCalled by the engine from OnBind"
  },
  "matproxy.ShouldOverrideProxy": {
    "prefix": "matproxy.ShouldOverrideProxy",
    "body": "matproxy.ShouldOverrideProxy(${1:string name})$0",
    "description": "(Client) Function: matproxy.ShouldOverrideProxy\n\nCalled by engine, returns true if we're overriding a proxy"
  },
  "matproxy": [],
  "menu.RecordFrame": {
    "prefix": "menu.RecordFrame",
    "body": "menu.RecordFrame()$0",
    "description": "(Client) Function: menu.RecordFrame\n\nUsed by \"Demo to Video\" to record the frame."
  },
  "menu": [],
  "menubar.Init": {
    "prefix": "menubar.Init",
    "body": "menubar.Init()$0",
    "description": "(Client) Function: menubar.Init\n\nCreates the menu bar ( The bar at the top of the screen when holding C or Q in sandbox ) and docks it to the top of the screen. It will not appear."
  },
  "menubar.IsParent": {
    "prefix": "menubar.IsParent",
    "body": "menubar.IsParent(${1:Panel pnl})$0",
    "description": "(Client) Function: menubar.IsParent\n\nChecks if the supplied panel is parent to the menubar"
  },
  "menubar.ParentTo": {
    "prefix": "menubar.ParentTo",
    "body": "menubar.ParentTo(${1:Panel pnl})$0",
    "description": "(Client) Function: menubar.ParentTo\n\nParents the menubar to the panel and displays the menubar."
  },
  "menubar": [],
  "mesh.AdvanceVertex": {
    "prefix": "mesh.AdvanceVertex",
    "body": "mesh.AdvanceVertex()$0",
    "description": "(Client) Function: mesh.AdvanceVertex\n\nPushes the new vertex data onto the render stack."
  },
  "mesh.Begin": {
    "prefix": "mesh.Begin",
    "body": "mesh.Begin(${1:IMesh mesh=nil}, ${2:number primitiveType}, ${3:number primiteCount})$0",
    "description": "(Client) Function: mesh.Begin\n\nStarts a new dynamic mesh. If an IMesh is passed, it will use that mesh instead."
  },
  "mesh.Color": {
    "prefix": "mesh.Color",
    "body": "mesh.Color(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a})$0",
    "description": "(Client) Function: mesh.Color\n\nSets the color to be used for the next vertex."
  },
  "mesh.End": {
    "prefix": "mesh.End",
    "body": "mesh.End()$0",
    "description": "(Client) Function: mesh.End\n\nEnds the mesh and renders it."
  },
  "mesh.Normal": {
    "prefix": "mesh.Normal",
    "body": "mesh.Normal(${1:Vector normal})$0",
    "description": "(Client) Function: mesh.Normal\n\nSets the normal to be used for the next vertex."
  },
  "mesh.Position": {
    "prefix": "mesh.Position",
    "body": "mesh.Position(${1:Vector position})$0",
    "description": "(Client) Function: mesh.Position\n\nSets the position to be used for the next vertex."
  },
  "mesh.Quad": {
    "prefix": "mesh.Quad",
    "body": "mesh.Quad(${1:Vector vertex1}, ${2:Vector vertex2}, ${3:Vector vertex3}, ${4:Vector vertex4})$0",
    "description": "(Client) Function: mesh.Quad\n\nDraws a quad using 4 vertices."
  },
  "mesh.QuadEasy": {
    "prefix": "mesh.QuadEasy",
    "body": "mesh.QuadEasy(${1:Vector position}, ${2:Vector normal}, ${3:number sizeX}, ${4:number sizeY})$0",
    "description": "(Client) Function: mesh.QuadEasy\n\nDraws a quad using a position, a normal and the size."
  },
  "mesh.Specular": {
    "prefix": "mesh.Specular",
    "body": "mesh.Specular(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a})$0",
    "description": "(Client) Function: mesh.Specular\n\nSets the specular map values."
  },
  "mesh.TangentS": {
    "prefix": "mesh.TangentS",
    "body": "mesh.TangentS(${1:Vector sTanger})$0",
    "description": "(Client) Function: mesh.TangentS\n\nSets the s tangent to be used."
  },
  "mesh.TangentT": {
    "prefix": "mesh.TangentT",
    "body": "mesh.TangentT(${1:Vector tTanger})$0",
    "description": "(Client) Function: mesh.TangentT\n\nSets the T tangent to be used."
  },
  "mesh.TexCoord": {
    "prefix": "mesh.TexCoord",
    "body": "mesh.TexCoord(${1:number stage}, ${2:number u}, ${3:number v})$0",
    "description": "(Client) Function: mesh.TexCoord\n\nSets the texture coordinates for the next vertex."
  },
  "mesh.VertexCount": {
    "prefix": "mesh.VertexCount",
    "body": "mesh.VertexCount()$0",
    "description": "(Client) Function: mesh.VertexCount\n\nReturns the amount of vertex that have yet been pushed."
  },
  "mesh": [],
  "motionsensor.BuildSkeleton": {
    "prefix": "motionsensor.BuildSkeleton",
    "body": "motionsensor.BuildSkeleton(${1:table translator}, ${2:Player player}, ${3:Angle rotation})$0",
    "description": "(Shared) Function: motionsensor.BuildSkeleton\n\n"
  },
  "motionsensor.ChooseBuilderFromEntity": {
    "prefix": "motionsensor.ChooseBuilderFromEntity",
    "body": "motionsensor.ChooseBuilderFromEntity(${1:Entity ent})$0",
    "description": "(Shared) Function: motionsensor.ChooseBuilderFromEntity\n\n"
  },
  "motionsensor.GetColourMaterial": {
    "prefix": "motionsensor.GetColourMaterial",
    "body": "motionsensor.GetColourMaterial()$0",
    "description": "(Client and Menu) Function: motionsensor.GetColourMaterial\n\nReturns the depth map material."
  },
  "motionsensor.GetSkeleton": {
    "prefix": "motionsensor.GetSkeleton",
    "body": "motionsensor.GetSkeleton()$0",
    "description": "(Client) Function: motionsensor.GetSkeleton\n\n"
  },
  "motionsensor.IsActive": {
    "prefix": "motionsensor.IsActive",
    "body": "motionsensor.IsActive()$0",
    "description": "(Client) Function: motionsensor.IsActive\n\nReturn whether a kinect is connected - and active (ie - Start has been called)."
  },
  "motionsensor.IsAvailable": {
    "prefix": "motionsensor.IsAvailable",
    "body": "motionsensor.IsAvailable()$0",
    "description": "(Client and Menu) Function: motionsensor.IsAvailable\n\nReturns true if we have detected that there's a kinect connected to the PC"
  },
  "motionsensor.ProcessAngle": {
    "prefix": "motionsensor.ProcessAngle",
    "body": "motionsensor.ProcessAngle(${1:table translator}, ${2:table sensor}, ${3:Vector pos}, ${4:Angle ang}, ${5:table special_vectors}, ${6:number boneid}, ${7:table v})$0",
    "description": "(Shared) Function: motionsensor.ProcessAngle\n\n"
  },
  "motionsensor.ProcessAnglesTable": {
    "prefix": "motionsensor.ProcessAnglesTable",
    "body": "motionsensor.ProcessAnglesTable(${1:table translator}, ${2:table sensor}, ${3:Vector pos}, ${4:Angle rotation})$0",
    "description": "(Shared) Function: motionsensor.ProcessAnglesTable\n\n"
  },
  "motionsensor.ProcessPositionTable": {
    "prefix": "motionsensor.ProcessPositionTable",
    "body": "motionsensor.ProcessPositionTable(${1:table translator}, ${2:table sensor})$0",
    "description": "(Shared) Function: motionsensor.ProcessPositionTable\n\n"
  },
  "motionsensor.Start": {
    "prefix": "motionsensor.Start",
    "body": "motionsensor.Start()$0",
    "description": "(Client and Menu) Function: motionsensor.Start\n\nThis starts access to the kinect sensor. Note that this usually freezes the game for a couple of seconds."
  },
  "motionsensor.Stop": {
    "prefix": "motionsensor.Stop",
    "body": "motionsensor.Stop()$0",
    "description": "(Client) Function: motionsensor.Stop\n\nStops the motion capture."
  },
  "motionsensor": [],
  "navmesh.AddWalkableSeed": {
    "prefix": "navmesh.AddWalkableSeed",
    "body": "navmesh.AddWalkableSeed(${1:Vector pos}, ${2:Vector dir})$0",
    "description": "(Server) Function: navmesh.AddWalkableSeed\n\nAdd this position and normal to the list of walkable positions, used before map generation with navmesh.BeginGeneration"
  },
  "navmesh.BeginGeneration": {
    "prefix": "navmesh.BeginGeneration",
    "body": "navmesh.BeginGeneration()$0",
    "description": "(Server) Function: navmesh.BeginGeneration\n\nStarts the generation of a new navmesh."
  },
  "navmesh.ClearWalkableSeeds": {
    "prefix": "navmesh.ClearWalkableSeeds",
    "body": "navmesh.ClearWalkableSeeds()$0",
    "description": "(Server) Function: navmesh.ClearWalkableSeeds\n\nClears all the walkable positions, used before calling navmesh.BeginGeneration."
  },
  "navmesh.Find": {
    "prefix": "navmesh.Find",
    "body": "navmesh.Find(${1:Vector pos}, ${2:number radius}, ${3:number stepdown}, ${4:number stepup})$0",
    "description": "(Server) Function: navmesh.Find\n\nReturns a bunch of areas within distance, used to find hiding spots by NextBots for example."
  },
  "navmesh.GetAllNavAreas": {
    "prefix": "navmesh.GetAllNavAreas",
    "body": "navmesh.GetAllNavAreas()$0",
    "description": "(Server) Function: navmesh.GetAllNavAreas\n\nReturns an integer indexed table of all CNavAreas on the current map. If the map doesn't have a navmesh generated then this will return an empty table."
  },
  "navmesh.GetEditCursorPosition": {
    "prefix": "navmesh.GetEditCursorPosition",
    "body": "navmesh.GetEditCursorPosition()$0",
    "description": "(Server) Function: navmesh.GetEditCursorPosition\n\nReturns the position of the edit cursor when nav_edit is set to 1."
  },
  "navmesh.GetMarkedArea": {
    "prefix": "navmesh.GetMarkedArea",
    "body": "navmesh.GetMarkedArea()$0",
    "description": "(Server) Function: navmesh.GetMarkedArea\n\nReturns the currently marked CNavArea, for use with editing console commands."
  },
  "navmesh.GetMarkedLadder": {
    "prefix": "navmesh.GetMarkedLadder",
    "body": "navmesh.GetMarkedLadder()$0",
    "description": "(Server) Function: navmesh.GetMarkedLadder\n\nReturns the currently marked CNavLadder, for use with editing console commands."
  },
  "navmesh.GetNavArea": {
    "prefix": "navmesh.GetNavArea",
    "body": "navmesh.GetNavArea(${1:Vector pos}, ${2:number beneathLimit})$0",
    "description": "(Server) Function: navmesh.GetNavArea\n\nReturns the Nav Area contained in this position that also satisfies the elevation limit."
  },
  "navmesh.GetNavAreaByID": {
    "prefix": "navmesh.GetNavAreaByID",
    "body": "navmesh.GetNavAreaByID(${1:number id})$0",
    "description": "(Server) Function: navmesh.GetNavAreaByID\n\nReturns a CNavArea by the given ID."
  },
  "navmesh.GetNavAreaCount": {
    "prefix": "navmesh.GetNavAreaCount",
    "body": "navmesh.GetNavAreaCount()$0",
    "description": "(Server) Function: navmesh.GetNavAreaCount\n\nReturns the highest ID of all nav areas on the map. While this can be used to get all nav areas, this number may not actually be the actual number of nav areas on the map."
  },
  "navmesh.GetNearestNavArea": {
    "prefix": "navmesh.GetNearestNavArea",
    "body": "navmesh.GetNearestNavArea(${1:Vector pos}, ${2:boolean anyZ=false}, ${3:number maxDist=10000}, ${4:boolean checkLOS=false}, ${5:boolean checkGround=true}, ${6:number team=TEAM_ANY=-2})$0",
    "description": "(Server) Function: navmesh.GetNearestNavArea\n\nReturns the closest CNavArea to given position at the same height, or beneath it."
  },
  "navmesh.GetPlayerSpawnName": {
    "prefix": "navmesh.GetPlayerSpawnName",
    "body": "navmesh.GetPlayerSpawnName()$0",
    "description": "(Server) Function: navmesh.GetPlayerSpawnName\n\nReturns the classname of the player spawn entity."
  },
  "navmesh.IsGenerating": {
    "prefix": "navmesh.IsGenerating",
    "body": "navmesh.IsGenerating()$0",
    "description": "(Server) Function: navmesh.IsGenerating\n\nWhether we're currently generating a new navmesh with navmesh.BeginGeneration."
  },
  "navmesh.IsLoaded": {
    "prefix": "navmesh.IsLoaded",
    "body": "navmesh.IsLoaded()$0",
    "description": "(Server) Function: navmesh.IsLoaded\n\nReturns true if a navmesh has been loaded when loading the map."
  },
  "navmesh.Load": {
    "prefix": "navmesh.Load",
    "body": "navmesh.Load()$0",
    "description": "(Server) Function: navmesh.Load\n\nLoads a new navmesh from the .nav file for current map discarding any changes made to the navmesh previously."
  },
  "navmesh.Reset": {
    "prefix": "navmesh.Reset",
    "body": "navmesh.Reset()$0",
    "description": "(Server) Function: navmesh.Reset\n\nDeletes every CNavArea and Type.CNavLadder on the map '''without saving the changes'''."
  },
  "navmesh.Save": {
    "prefix": "navmesh.Save",
    "body": "navmesh.Save()$0",
    "description": "(Server) Function: navmesh.Save\n\nSaves any changes made to navmesh to the .nav file."
  },
  "navmesh.SetMarkedArea": {
    "prefix": "navmesh.SetMarkedArea",
    "body": "navmesh.SetMarkedArea(${1:CNavArea area})$0",
    "description": "(Server) Function: navmesh.SetMarkedArea\n\nSets the CNavArea as marked, so it can be used with editing console commands."
  },
  "navmesh.SetMarkedLadder": {
    "prefix": "navmesh.SetMarkedLadder",
    "body": "navmesh.SetMarkedLadder(${1:CNavLadder area})$0",
    "description": "(Server) Function: navmesh.SetMarkedLadder\n\nSets the CNavLadder as marked, so it can be used with editing console commands."
  },
  "navmesh.SetPlayerSpawnName": {
    "prefix": "navmesh.SetPlayerSpawnName",
    "body": "navmesh.SetPlayerSpawnName(${1:string spawnPointClass})$0",
    "description": "(Server) Function: navmesh.SetPlayerSpawnName\n\nSets the classname of the default spawn point entity, used before generating a new navmesh with navmesh.BeginGeneration."
  },
  "navmesh": [],
  "net.Broadcast": {
    "prefix": "net.Broadcast",
    "body": "net.Broadcast()$0",
    "description": "(Server) Function: net.Broadcast\n\nSends the currently built net message to all connected players."
  },
  "net.BytesWritten": {
    "prefix": "net.BytesWritten",
    "body": "net.BytesWritten()$0",
    "description": "(Shared) Function: net.BytesWritten\n\nReturns the size of the current message in bytes."
  },
  "net.Incoming": {
    "prefix": "net.Incoming",
    "body": "net.Incoming(${1:number length}, ${2:Player client})$0",
    "description": "(Shared) Function: net.Incoming\n\n[Internal] .You may be looking for net.Receive."
  },
  "net.ReadAngle": {
    "prefix": "net.ReadAngle",
    "body": "net.ReadAngle()$0",
    "description": "(Shared) Function: net.ReadAngle\n\nReads an angle from the received net message."
  },
  "net.ReadBit": {
    "prefix": "net.ReadBit",
    "body": "net.ReadBit()$0",
    "description": "(Shared) Function: net.ReadBit\n\nReads a bit from the received net message."
  },
  "net.ReadBool": {
    "prefix": "net.ReadBool",
    "body": "net.ReadBool()$0",
    "description": "(Shared) Function: net.ReadBool\n\nReads a boolean from the received net message."
  },
  "net.ReadColor": {
    "prefix": "net.ReadColor",
    "body": "net.ReadColor()$0",
    "description": "(Shared) Function: net.ReadColor\n\nReads a Color from the current net message."
  },
  "net.ReadData": {
    "prefix": "net.ReadData",
    "body": "net.ReadData(${1:number length})$0",
    "description": "(Shared) Function: net.ReadData\n\nReads pure binary data from the message."
  },
  "net.ReadDouble": {
    "prefix": "net.ReadDouble",
    "body": "net.ReadDouble()$0",
    "description": "(Shared) Function: net.ReadDouble\n\nReads a double-precision number from the received net message."
  },
  "net.ReadEntity": {
    "prefix": "net.ReadEntity",
    "body": "net.ReadEntity()$0",
    "description": "(Shared) Function: net.ReadEntity\n\nReads an entity from the received net message. You should always check if the specified entity exists as it may have been removed and therefor NULL if it is outside of the players PVS or was already removed."
  },
  "net.ReadFloat": {
    "prefix": "net.ReadFloat",
    "body": "net.ReadFloat()$0",
    "description": "(Shared) Function: net.ReadFloat\n\nReads a floating point number from the received net message."
  },
  "net.ReadHeader": {
    "prefix": "net.ReadHeader",
    "body": "net.ReadHeader()$0",
    "description": "(Shared) Function: net.ReadHeader\n\nReturns the \"header\" of the message which contains a short which can be converted to the corresponding message name via util.NetworkIDToString."
  },
  "net.ReadInt": {
    "prefix": "net.ReadInt",
    "body": "net.ReadInt(${1:number bitCount})$0",
    "description": "(Shared) Function: net.ReadInt\n\nReads an integer from the received net message."
  },
  "net.ReadMatrix": {
    "prefix": "net.ReadMatrix",
    "body": "net.ReadMatrix()$0",
    "description": "(Shared) Function: net.ReadMatrix\n\nReads a VMatrix from the received net message."
  },
  "net.ReadNormal": {
    "prefix": "net.ReadNormal",
    "body": "net.ReadNormal()$0",
    "description": "(Shared) Function: net.ReadNormal\n\nReads a normal vector from the net message."
  },
  "net.ReadString": {
    "prefix": "net.ReadString",
    "body": "net.ReadString()$0",
    "description": "(Shared) Function: net.ReadString\n\nReads a null terminated string from the net stream. The size of the string is 8 bits plus 8 bits for every ASCII character in the string."
  },
  "net.ReadTable": {
    "prefix": "net.ReadTable",
    "body": "net.ReadTable()$0",
    "description": "(Shared) Function: net.ReadTable\n\nReads a table from the received net message."
  },
  "net.ReadType": {
    "prefix": "net.ReadType",
    "body": "net.ReadType(${1:number typeID=net.ReadUInt(8)})$0",
    "description": "(Shared) Function: net.ReadType\n\nReads a value from the net message with the specified type."
  },
  "net.ReadUInt": {
    "prefix": "net.ReadUInt",
    "body": "net.ReadUInt(${1:number numberOfBits})$0",
    "description": "(Shared) Function: net.ReadUInt\n\nReads an unsigned integer with the specified number of bits from the received net message."
  },
  "net.ReadVector": {
    "prefix": "net.ReadVector",
    "body": "net.ReadVector()$0",
    "description": "(Shared) Function: net.ReadVector\n\nReads a vector from the received net message.  Vectors sent by this function are compressed, which may result in precision loss. See net.WriteVector for more information."
  },
  "net.Receive": {
    "prefix": "net.Receive",
    "body": "net.Receive(${1:string messageName}, ${2:function callback})$0",
    "description": "(Shared) Function: net.Receive\n\nAdds a net message handler. Only one receiver can be used to receive the net message."
  },
  "net.Send": {
    "prefix": "net.Send",
    "body": "net.Send(${1:Player ply})$0",
    "description": "(Server) Function: net.Send\n\nSends the current message to the specified player, or to all players listed in the table."
  },
  "net.SendOmit": {
    "prefix": "net.SendOmit",
    "body": "net.SendOmit(${1:Player ply})$0",
    "description": "(Server) Function: net.SendOmit\n\nSends the current message to all except the specified, or to all except all players in the table."
  },
  "net.SendPAS": {
    "prefix": "net.SendPAS",
    "body": "net.SendPAS(${1:Vector position})$0",
    "description": "(Server) Function: net.SendPAS\n\nSends the message to all players that are in the same potentially audible set(PAS) as the position, or simply said, it adds all players that can potentially hear sounds from this position."
  },
  "net.SendPVS": {
    "prefix": "net.SendPVS",
    "body": "net.SendPVS(${1:Vector position})$0",
    "description": "(Server) Function: net.SendPVS\n\nSends the message to all players the position is in the PVS of or, more simply said, sends the message to players that can potentially see this position."
  },
  "net.SendToServer": {
    "prefix": "net.SendToServer",
    "body": "net.SendToServer()$0",
    "description": "(Client) Function: net.SendToServer\n\nSends the current message to the server."
  },
  "net.Start": {
    "prefix": "net.Start",
    "body": "net.Start(${1:string messageName}, ${2:boolean unreliable=false})$0",
    "description": "(Shared) Function: net.Start\n\nBegins a new net message."
  },
  "net.WriteAngle": {
    "prefix": "net.WriteAngle",
    "body": "net.WriteAngle(${1:Angle angle})$0",
    "description": "(Shared) Function: net.WriteAngle\n\nWrites an angle to the current net message."
  },
  "net.WriteBit": {
    "prefix": "net.WriteBit",
    "body": "net.WriteBit(${1:boolean boolean})$0",
    "description": "(Shared) Function: net.WriteBit\n\nAppends a boolean (as 1 or 0) to the current net message."
  },
  "net.WriteBool": {
    "prefix": "net.WriteBool",
    "body": "net.WriteBool(${1:boolean boolean})$0",
    "description": "(Shared) Function: net.WriteBool\n\nAppends a boolean to the current net message. Alias of net.WriteBit"
  },
  "net.WriteColor": {
    "prefix": "net.WriteColor",
    "body": "net.WriteColor(${1:table Color})$0",
    "description": "(Shared) Function: net.WriteColor\n\nAppends a Color to the current net message."
  },
  "net.WriteData": {
    "prefix": "net.WriteData",
    "body": "net.WriteData(${1:string binaryData}, ${2:number length})$0",
    "description": "(Shared) Function: net.WriteData\n\nWrites a chunk of binary data to the message."
  },
  "net.WriteDouble": {
    "prefix": "net.WriteDouble",
    "body": "net.WriteDouble(${1:number double})$0",
    "description": "(Shared) Function: net.WriteDouble\n\nAppends a double-precision number to the current net message."
  },
  "net.WriteEntity": {
    "prefix": "net.WriteEntity",
    "body": "net.WriteEntity(${1:Entity entity})$0",
    "description": "(Shared) Function: net.WriteEntity\n\nAppends an entity to the current net message."
  },
  "net.WriteFloat": {
    "prefix": "net.WriteFloat",
    "body": "net.WriteFloat(${1:number float})$0",
    "description": "(Shared) Function: net.WriteFloat\n\nAppends a float (number with decimals) to the current net message."
  },
  "net.WriteInt": {
    "prefix": "net.WriteInt",
    "body": "net.WriteInt(${1:number integer}, ${2:number bitCount})$0",
    "description": "(Shared) Function: net.WriteInt\n\nAppends an integer (number without decimals) to the current net message."
  },
  "net.WriteMatrix": {
    "prefix": "net.WriteMatrix",
    "body": "net.WriteMatrix(${1:VMatrix matrix})$0",
    "description": "(Shared) Function: net.WriteMatrix\n\nWrites a VMatrix to the current net message."
  },
  "net.WriteNormal": {
    "prefix": "net.WriteNormal",
    "body": "net.WriteNormal(${1:Vector normal})$0",
    "description": "(Shared) Function: net.WriteNormal\n\nWrites a normalized/direction vector ( Vector with length of 1 ) to the net message."
  },
  "net.WriteString": {
    "prefix": "net.WriteString",
    "body": "net.WriteString(${1:string string})$0",
    "description": "(Shared) Function: net.WriteString\n\nAppends a string to the current net message. The size of the string is 8 bits plus 8 bits for every ASCII character in the string. The maximum allowed length of a single written string is 65533 characters."
  },
  "net.WriteTable": {
    "prefix": "net.WriteTable",
    "body": "net.WriteTable(${1:table table})$0",
    "description": "(Shared) Function: net.WriteTable\n\nAppends a table to the current net message."
  },
  "net.WriteType": {
    "prefix": "net.WriteType",
    "body": "net.WriteType(${1:any Data})$0",
    "description": "(Shared) Function: net.WriteType\n\nAppends any type of value to the current net message."
  },
  "net.WriteUInt": {
    "prefix": "net.WriteUInt",
    "body": "net.WriteUInt(${1:number unsignedInteger}, ${2:number numberOfBits})$0",
    "description": "(Shared) Function: net.WriteUInt\n\nAppends an unsigned integer with the specified number of bits to the current net message."
  },
  "net.WriteVector": {
    "prefix": "net.WriteVector",
    "body": "net.WriteVector(${1:Vector vector})$0",
    "description": "(Shared) Function: net.WriteVector\n\nAppends a vector to the current net message."
  },
  "net": [],
  "notification.AddLegacy": {
    "prefix": "notification.AddLegacy",
    "body": "notification.AddLegacy(${1:string Text}, ${2:number Type}, ${3:number Length})$0",
    "description": "(Client and Menu) Function: notification.AddLegacy\n\nAdds a standard notification to your screen."
  },
  "notification.AddProgress": {
    "prefix": "notification.AddProgress",
    "body": "notification.AddProgress(${1:any id}, ${2:string strText})$0",
    "description": "(Client and Menu) Function: notification.AddProgress\n\nAdds a notification with an animated progress bar."
  },
  "notification.Kill": {
    "prefix": "notification.Kill",
    "body": "notification.Kill(${1:any uid})$0",
    "description": "(Client and Menu) Function: notification.Kill\n\nRemoves the notification after 0.8 seconds."
  },
  "notification": [],
  "numpad.Activate": {
    "prefix": "numpad.Activate",
    "body": "numpad.Activate(${1:Player ply}, ${2:number key}, ${3:boolean isButton})$0",
    "description": "(Server) Function: numpad.Activate\n\nActivates numpad key owned by the player"
  },
  "numpad.Deactivate": {
    "prefix": "numpad.Deactivate",
    "body": "numpad.Deactivate(${1:Player ply}, ${2:number key}, ${3:boolean isButton})$0",
    "description": "(Server) Function: numpad.Deactivate\n\nDeactivates numpad key owned by the player"
  },
  "numpad.FromButton": {
    "prefix": "numpad.FromButton",
    "body": "numpad.FromButton()$0",
    "description": "(Server) Function: numpad.FromButton\n\nReturns true during a function added with  numpad.Register when the third argument to numpad.Activate is true."
  },
  "numpad.OnDown": {
    "prefix": "numpad.OnDown",
    "body": "numpad.OnDown(${1:Player ply}, ${2:number key}, ${3:string name}, ${4:vararg ...})$0",
    "description": "(Server) Function: numpad.OnDown\n\nCalls a function registered with numpad.Register when a player presses specified key."
  },
  "numpad.OnUp": {
    "prefix": "numpad.OnUp",
    "body": "numpad.OnUp(${1:Player ply}, ${2:number key}, ${3:string name}, ${4:vararg ...})$0",
    "description": "(Server) Function: numpad.OnUp\n\nCalls a function registered with numpad.Register when a player releases specified key."
  },
  "numpad.Register": {
    "prefix": "numpad.Register",
    "body": "numpad.Register(${1:string id}, ${2:function func})$0",
    "description": "(Server) Function: numpad.Register\n\nRegisters a numpad library action for use with numpad.OnDown and numpad.OnUp"
  },
  "numpad.Remove": {
    "prefix": "numpad.Remove",
    "body": "numpad.Remove(${1:number ID})$0",
    "description": "(Server) Function: numpad.Remove\n\nRemoves a function added by either numpad.OnUp or numpad.OnDown"
  },
  "numpad.Toggle": {
    "prefix": "numpad.Toggle",
    "body": "numpad.Toggle(${1:Player ply}, ${2:number key})$0",
    "description": "(Server) Function: numpad.Toggle\n\nEither runs numpad.Activate or numpad.Deactivate depending on the key's current state"
  },
  "numpad": [],
  "os.clock": {
    "prefix": "os.clock",
    "body": "os.clock()$0",
    "description": "(All) Function: os.clock\n\nReturns the approximate cpu time the application ran."
  },
  "os.date": {
    "prefix": "os.date",
    "body": "os.date(${1:string format}, ${2:number time})$0",
    "description": "(All) Function: os.date\n\nReturns the date/time as a formatted string or in a table."
  },
  "os.difftime": {
    "prefix": "os.difftime",
    "body": "os.difftime(${1:number timeA}, ${2:number timeB})$0",
    "description": "(All) Function: os.difftime\n\nSubtracts the second of the first value and rounds the result."
  },
  "os.time": {
    "prefix": "os.time",
    "body": "os.time(${1:table dateData=nil})$0",
    "description": "(All) Function: os.time\n\nReturns the system time in seconds past the unix epoch. If a table is supplied, the function attempts to build a system time with the specified table members."
  },
  "os": [],
  "package.seeall": {
    "prefix": "package.seeall",
    "body": "package.seeall(${1:table module})$0",
    "description": "(All) Function: package.seeall\n\nSets a metatable for module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to _G.module."
  },
  "package": [],
  "physenv.AddSurfaceData": {
    "prefix": "physenv.AddSurfaceData",
    "body": "physenv.AddSurfaceData(${1:string properties})$0",
    "description": "(Shared) Function: physenv.AddSurfaceData\n\n[Deprecated] Loads the given surface properties as a string, follows the file format."
  },
  "physenv.GetAirDensity": {
    "prefix": "physenv.GetAirDensity",
    "body": "physenv.GetAirDensity()$0",
    "description": "(Shared) Function: physenv.GetAirDensity\n\nReturns the air density."
  },
  "physenv.GetGravity": {
    "prefix": "physenv.GetGravity",
    "body": "physenv.GetGravity()$0",
    "description": "(Shared) Function: physenv.GetGravity\n\nGets the global gravity."
  },
  "physenv.GetPerformanceSettings": {
    "prefix": "physenv.GetPerformanceSettings",
    "body": "physenv.GetPerformanceSettings()$0",
    "description": "(Shared) Function: physenv.GetPerformanceSettings\n\nGets the current performance settings in table form."
  },
  "physenv.SetAirDensity": {
    "prefix": "physenv.SetAirDensity",
    "body": "physenv.SetAirDensity(${1:number airDensity})$0",
    "description": "(Shared) Function: physenv.SetAirDensity\n\nSets the air density."
  },
  "physenv.SetGravity": {
    "prefix": "physenv.SetGravity",
    "body": "physenv.SetGravity(${1:Vector gravity})$0",
    "description": "(Shared) Function: physenv.SetGravity\n\nSets the directional gravity, does not work on players."
  },
  "physenv.SetPerformanceSettings": {
    "prefix": "physenv.SetPerformanceSettings",
    "body": "physenv.SetPerformanceSettings(${1:table performanceSettings})$0",
    "description": "(Shared) Function: physenv.SetPerformanceSettings\n\nSets the performance settings."
  },
  "physenv": [],
  "player_manager.AddValidHands": {
    "prefix": "player_manager.AddValidHands",
    "body": "player_manager.AddValidHands(${1:string name}, ${2:string model}, ${3:number skin}, ${4:string bodygroups})$0",
    "description": "(Shared) Function: player_manager.AddValidHands\n\nAssigns view model hands to player model."
  },
  "player_manager.AddValidModel": {
    "prefix": "player_manager.AddValidModel",
    "body": "player_manager.AddValidModel(${1:string name}, ${2:string model})$0",
    "description": "(Shared) Function: player_manager.AddValidModel\n\nAssociates a simplified name with a path to a valid player model."
  },
  "player_manager.AllValidModels": {
    "prefix": "player_manager.AllValidModels",
    "body": "player_manager.AllValidModels()$0",
    "description": "(Shared) Function: player_manager.AllValidModels\n\nReturns the entire list of valid player models."
  },
  "player_manager.ClearPlayerClass": {
    "prefix": "player_manager.ClearPlayerClass",
    "body": "player_manager.ClearPlayerClass(${1:Player ply})$0",
    "description": "(Shared) Function: player_manager.ClearPlayerClass\n\nClears a player's class association by setting their ClassID to 0"
  },
  "player_manager.GetPlayerClass": {
    "prefix": "player_manager.GetPlayerClass",
    "body": "player_manager.GetPlayerClass(${1:Player ply})$0",
    "description": "(Shared) Function: player_manager.GetPlayerClass\n\nGets a players class"
  },
  "player_manager.OnPlayerSpawn": {
    "prefix": "player_manager.OnPlayerSpawn",
    "body": "player_manager.OnPlayerSpawn(${1:Player ply})$0",
    "description": "(Shared) Function: player_manager.OnPlayerSpawn\n\nApplies basic class variables when the player spawns."
  },
  "player_manager.RegisterClass": {
    "prefix": "player_manager.RegisterClass",
    "body": "player_manager.RegisterClass(${1:string name}, ${2:table table}, ${3:string base})$0",
    "description": "(Shared) Function: player_manager.RegisterClass\n\nRegister a class metatable to be assigned to players later"
  },
  "player_manager.RunClass": {
    "prefix": "player_manager.RunClass",
    "body": "player_manager.RunClass(${1:Player ply}, ${2:string funcName}, ${3:vararg arguments})$0",
    "description": "(Shared) Function: player_manager.RunClass\n\nExecute a named function within the player's set class"
  },
  "player_manager.SetPlayerClass": {
    "prefix": "player_manager.SetPlayerClass",
    "body": "player_manager.SetPlayerClass(${1:Player ply}, ${2:string classname})$0",
    "description": "(Shared) Function: player_manager.SetPlayerClass\n\nSets a player's class"
  },
  "player_manager.TranslatePlayerHands": {
    "prefix": "player_manager.TranslatePlayerHands",
    "body": "player_manager.TranslatePlayerHands(${1:string name})$0",
    "description": "(Shared) Function: player_manager.TranslatePlayerHands\n\nRetrieves correct hands for given player model. By default returns citizen hands."
  },
  "player_manager.TranslatePlayerModel": {
    "prefix": "player_manager.TranslatePlayerModel",
    "body": "player_manager.TranslatePlayerModel(${1:string shortName})$0",
    "description": "(Shared) Function: player_manager.TranslatePlayerModel\n\nReturns the valid model path for a simplified name."
  },
  "player_manager.TranslateToPlayerModelName": {
    "prefix": "player_manager.TranslateToPlayerModelName",
    "body": "player_manager.TranslateToPlayerModelName(${1:string model})$0",
    "description": "(Shared) Function: player_manager.TranslateToPlayerModelName\n\nReturns the simplified name for a valid model path of a player model."
  },
  "player_manager": [],
  "player.CreateNextBot": {
    "prefix": "player.CreateNextBot",
    "body": "player.CreateNextBot(${1:string botName})$0",
    "description": "(Server) Function: player.CreateNextBot\n\nSimilar to the serverside command \"bot\", this function creates a new Player bot with the given name. This bot will not obey to the usual \"bot_*\" commands, and it's the same bot base used in TF2 and CS:S."
  },
  "player.GetAll": {
    "prefix": "player.GetAll",
    "body": "player.GetAll()$0",
    "description": "(Shared) Function: player.GetAll\n\nGets all the current players in the server (not including connecting clients)."
  },
  "player.GetBots": {
    "prefix": "player.GetBots",
    "body": "player.GetBots()$0",
    "description": "(Shared) Function: player.GetBots\n\nReturns a table of all bots on the server."
  },
  "player.GetByID": {
    "prefix": "player.GetByID",
    "body": "player.GetByID(${1:number connectionID})$0",
    "description": "(Shared) Function: player.GetByID\n\nGets the player with the specified connection ID."
  },
  "player.GetBySteamID": {
    "prefix": "player.GetBySteamID",
    "body": "player.GetBySteamID(${1:string steamID})$0",
    "description": "(Shared) Function: player.GetBySteamID\n\nGets the player with the specified SteamID."
  },
  "player.GetBySteamID64": {
    "prefix": "player.GetBySteamID64",
    "body": "player.GetBySteamID64(${1:string steamID64})$0",
    "description": "(Shared) Function: player.GetBySteamID64\n\nGets the player with the specified SteamID64."
  },
  "player.GetByUniqueID": {
    "prefix": "player.GetByUniqueID",
    "body": "player.GetByUniqueID(${1:string uniqueID})$0",
    "description": "(Shared) Function: player.GetByUniqueID\n\nGets the player with the specified uniqueID (not recommended way to identify players)."
  },
  "player.GetCount": {
    "prefix": "player.GetCount",
    "body": "player.GetCount()$0",
    "description": "(Shared) Function: player.GetCount\n\nGives you the player count."
  },
  "player.GetHumans": {
    "prefix": "player.GetHumans",
    "body": "player.GetHumans()$0",
    "description": "(Shared) Function: player.GetHumans\n\nReturns a table of all human ( non bot/AI ) players."
  },
  "player": [],
  "presets.Add": {
    "prefix": "presets.Add",
    "body": "presets.Add(${1:string groupname}, ${2:string name}, ${3:table values})$0",
    "description": "(Client) Function: presets.Add\n\nAdds preset to a preset group."
  },
  "presets.GetTable": {
    "prefix": "presets.GetTable",
    "body": "presets.GetTable(${1:string groupname})$0",
    "description": "(Client) Function: presets.GetTable\n\nReturns a table with preset names and values from a single preset group."
  },
  "presets.Remove": {
    "prefix": "presets.Remove",
    "body": "presets.Remove(${1:string groupname}, ${2:string name})$0",
    "description": "(Client) Function: presets.Remove\n\nRemoves a preset entry from a preset group."
  },
  "presets.Rename": {
    "prefix": "presets.Rename",
    "body": "presets.Rename(${1:string groupname}, ${2:string oldname}, ${3:string newname})$0",
    "description": "(Client) Function: presets.Rename\n\nRenames preset."
  },
  "presets": [],
  "properties.Add": {
    "prefix": "properties.Add",
    "body": "properties.Add(${1:string name}, ${2:table propertyData})$0",
    "description": "(Shared) Function: properties.Add\n\nAdd properties to the properties module"
  },
  "properties.GetHovered": {
    "prefix": "properties.GetHovered",
    "body": "properties.GetHovered(${1:Vector pos}, ${2:Vector aimVec})$0",
    "description": "(Client) Function: properties.GetHovered\n\nReturns an entity player is hovering over with his cursor."
  },
  "properties.OnScreenClick": {
    "prefix": "properties.OnScreenClick",
    "body": "properties.OnScreenClick(${1:Vector eyepos}, ${2:Vector eyevec})$0",
    "description": "(Shared) Function: properties.OnScreenClick\n\nChecks if player hovers over any entities and open a properties menu for it."
  },
  "properties.OpenEntityMenu": {
    "prefix": "properties.OpenEntityMenu",
    "body": "properties.OpenEntityMenu(${1:Entity ent}, ${2:table tr})$0",
    "description": "(Shared) Function: properties.OpenEntityMenu\n\nOpens properties menu for given entity."
  },
  "properties": [],
  "render.AddBeam": {
    "prefix": "render.AddBeam",
    "body": "render.AddBeam(${1:Vector startPos}, ${2:number width}, ${3:number textureEnd}, ${4:table color})$0",
    "description": "(Client) Function: render.AddBeam\n\nAdds a beam segment to the beam started by render.StartBeam."
  },
  "render.BlurRenderTarget": {
    "prefix": "render.BlurRenderTarget",
    "body": "render.BlurRenderTarget(${1:ITexture rendertarget}, ${2:number blurx}, ${3:number blury}, ${4:number passes})$0",
    "description": "(Client) Function: render.BlurRenderTarget\n\nBlurs the render target ( or a given texture )"
  },
  "render.BrushMaterialOverride": {
    "prefix": "render.BrushMaterialOverride",
    "body": "render.BrushMaterialOverride(${1:IMaterial mat=nil})$0",
    "description": "(Client) Function: render.BrushMaterialOverride\n\nWarning.This function is broken and does absolutely nothing"
  },
  "render.Capture": {
    "prefix": "render.Capture",
    "body": "render.Capture(${1:table captureData})$0",
    "description": "(Client) Function: render.Capture\n\nCaptures a part of the current render target and returns the data as a binary string in the given format."
  },
  "render.CapturePixels": {
    "prefix": "render.CapturePixels",
    "body": "render.CapturePixels()$0",
    "description": "(Client) Function: render.CapturePixels\n\nDumps the current render target and allows the pixels to be accessed by render.ReadPixel."
  },
  "render.Clear": {
    "prefix": "render.Clear",
    "body": "render.Clear(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a}, ${5:boolean clearDepth}, ${6:boolean clearStencil})$0",
    "description": "(Client) Function: render.Clear\n\nClears the current render target and the specified buffers."
  },
  "render.ClearBuffersObeyStencil": {
    "prefix": "render.ClearBuffersObeyStencil",
    "body": "render.ClearBuffersObeyStencil(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a}, ${5:boolean depth})$0",
    "description": "(Client) Function: render.ClearBuffersObeyStencil\n\nClears the current rendertarget for obeying the current stencil buffer conditions."
  },
  "render.ClearDepth": {
    "prefix": "render.ClearDepth",
    "body": "render.ClearDepth()$0",
    "description": "(Client) Function: render.ClearDepth\n\nResets the depth buffer."
  },
  "render.ClearRenderTarget": {
    "prefix": "render.ClearRenderTarget",
    "body": "render.ClearRenderTarget(${1:ITexture texture}, ${2:table color})$0",
    "description": "(Client) Function: render.ClearRenderTarget\n\nClears a render target"
  },
  "render.ClearStencil": {
    "prefix": "render.ClearStencil",
    "body": "render.ClearStencil()$0",
    "description": "(Client) Function: render.ClearStencil\n\nResets all values in the stencil buffer to zero."
  },
  "render.ClearStencilBufferRectangle": {
    "prefix": "render.ClearStencilBufferRectangle",
    "body": "render.ClearStencilBufferRectangle(${1:number originX}, ${2:number originY}, ${3:number endX}, ${4:number endY}, ${5:number stencilValue})$0",
    "description": "(Client) Function: render.ClearStencilBufferRectangle\n\nSets the stencil value in a specified rect."
  },
  "render.ComputeDynamicLighting": {
    "prefix": "render.ComputeDynamicLighting",
    "body": "render.ComputeDynamicLighting(${1:Vector position}, ${2:Vector normal})$0",
    "description": "(Client) Function: render.ComputeDynamicLighting\n\nCalculates the lighting caused by dynamic lights for the specified surface."
  },
  "render.ComputeLighting": {
    "prefix": "render.ComputeLighting",
    "body": "render.ComputeLighting(${1:Vector position}, ${2:Vector normal})$0",
    "description": "(Client) Function: render.ComputeLighting\n\nCalculates the light color of a certain surface."
  },
  "render.CopyRenderTargetToTexture": {
    "prefix": "render.CopyRenderTargetToTexture",
    "body": "render.CopyRenderTargetToTexture(${1:ITexture Target})$0",
    "description": "(Client) Function: render.CopyRenderTargetToTexture\n\nCopies the currently active Render Target to the specified texture."
  },
  "render.CopyTexture": {
    "prefix": "render.CopyTexture",
    "body": "render.CopyTexture(${1:ITexture texture_from}, ${2:ITexture texture_to})$0",
    "description": "(Client) Function: render.CopyTexture\n\nCopies the contents of one texture to another"
  },
  "render.CullMode": {
    "prefix": "render.CullMode",
    "body": "render.CullMode(${1:number cullMode})$0",
    "description": "(Client) Function: render.CullMode\n\nChanges the cull mode."
  },
  "render.DepthRange": {
    "prefix": "render.DepthRange",
    "body": "render.DepthRange(${1:number depthmin}, ${2:number depthmax})$0",
    "description": "(Client) Function: render.DepthRange\n\nSet's the depth range of the upcoming render."
  },
  "render.DrawBeam": {
    "prefix": "render.DrawBeam",
    "body": "render.DrawBeam(${1:Vector startPos}, ${2:Vector endPos}, ${3:number width}, ${4:number textureStart}, ${5:number textureEnd}, ${6:table color})$0",
    "description": "(Client) Function: render.DrawBeam\n\nDraws textured beam."
  },
  "render.DrawBox": {
    "prefix": "render.DrawBox",
    "body": "render.DrawBox(${1:Vector position}, ${2:Angle angles}, ${3:Vector mins}, ${4:Vector maxs}, ${5:table color}, ${6:boolean writeZ})$0",
    "description": "(Client) Function: render.DrawBox\n\nDraws a box in 3D space."
  },
  "render.DrawLine": {
    "prefix": "render.DrawLine",
    "body": "render.DrawLine(${1:Vector startPos}, ${2:Vector endPos}, ${3:table color}, ${4:boolean writeZ=false})$0",
    "description": "(Client) Function: render.DrawLine\n\nDraws a line in 3D space."
  },
  "render.DrawQuad": {
    "prefix": "render.DrawQuad",
    "body": "render.DrawQuad(${1:Vector vert1}, ${2:Vector vert2}, ${3:Vector vert3}, ${4:Vector vert4}, ${5:table color=Color( 255, 255, 255 )})$0",
    "description": "(Client) Function: render.DrawQuad\n\nDraws 2 connected triangles."
  },
  "render.DrawQuadEasy": {
    "prefix": "render.DrawQuadEasy",
    "body": "render.DrawQuadEasy(${1:Vector position}, ${2:Vector normal}, ${3:number width}, ${4:number height}, ${5:table color}, ${6:number rotation})$0",
    "description": "(Client) Function: render.DrawQuadEasy\n\nDraws a quad."
  },
  "render.DrawScreenQuad": {
    "prefix": "render.DrawScreenQuad",
    "body": "render.DrawScreenQuad()$0",
    "description": "(Client) Function: render.DrawScreenQuad\n\nDraws the the current material set by render.SetMaterial to the whole screen."
  },
  "render.DrawScreenQuadEx": {
    "prefix": "render.DrawScreenQuadEx",
    "body": "render.DrawScreenQuadEx(${1:number startX}, ${2:number startY}, ${3:number width}, ${4:number height})$0",
    "description": "(Client) Function: render.DrawScreenQuadEx\n\nDraws the the current material set by render.SetMaterial to the area specified."
  },
  "render.DrawSphere": {
    "prefix": "render.DrawSphere",
    "body": "render.DrawSphere(${1:Vector position}, ${2:number radius}, ${3:number longitudeSteps}, ${4:number latitudeSteps}, ${5:table color})$0",
    "description": "(Client) Function: render.DrawSphere\n\nDraws a sphere in 3D space. The material previously set with render.SetMaterial will be applied the sphere's surface."
  },
  "render.DrawSprite": {
    "prefix": "render.DrawSprite",
    "body": "render.DrawSprite(${1:Vector position}, ${2:number width}, ${3:number height}, ${4:table color})$0",
    "description": "(Client) Function: render.DrawSprite\n\nDraws a sprite in 3d space."
  },
  "render.DrawTextureToScreen": {
    "prefix": "render.DrawTextureToScreen",
    "body": "render.DrawTextureToScreen(${1:ITexture tex})$0",
    "description": "(Client) Function: render.DrawTextureToScreen\n\nDraws a texture over the whole screen."
  },
  "render.DrawTextureToScreenRect": {
    "prefix": "render.DrawTextureToScreenRect",
    "body": "render.DrawTextureToScreenRect(${1:ITexture tex}, ${2:number x}, ${3:number y}, ${4:number width}, ${5:number height})$0",
    "description": "(Client) Function: render.DrawTextureToScreenRect\n\nDraws a textured rectangle."
  },
  "render.DrawWireframeBox": {
    "prefix": "render.DrawWireframeBox",
    "body": "render.DrawWireframeBox(${1:Vector position}, ${2:Angle angle}, ${3:Vector mins}, ${4:Vector maxs}, ${5:table color}, ${6:boolean writeZ})$0",
    "description": "(Client) Function: render.DrawWireframeBox\n\nDraws a wireframe box in 3D space."
  },
  "render.DrawWireframeSphere": {
    "prefix": "render.DrawWireframeSphere",
    "body": "render.DrawWireframeSphere(${1:Vector position}, ${2:number radius}, ${3:number longitudeSteps}, ${4:number latitudeSteps}, ${5:table color}, ${6:boolean writeZ=false})$0",
    "description": "(Client) Function: render.DrawWireframeSphere\n\nDraws a wireframe sphere in 3d space."
  },
  "render.EnableClipping": {
    "prefix": "render.EnableClipping",
    "body": "render.EnableClipping(${1:boolean state})$0",
    "description": "(Client) Function: render.EnableClipping\n\nSets the status of the clip renderer, returning previous state."
  },
  "render.EndBeam": {
    "prefix": "render.EndBeam",
    "body": "render.EndBeam()$0",
    "description": "(Client) Function: render.EndBeam\n\nEnds the beam mesh of a beam started with render.StartBeam."
  },
  "render.FogColor": {
    "prefix": "render.FogColor",
    "body": "render.FogColor(${1:number red}, ${2:number green}, ${3:number blue})$0",
    "description": "(Client) Function: render.FogColor\n\nSets the color of the fog."
  },
  "render.FogEnd": {
    "prefix": "render.FogEnd",
    "body": "render.FogEnd(${1:number distance})$0",
    "description": "(Client) Function: render.FogEnd\n\nSets the at which the fog reaches its max density."
  },
  "render.FogMaxDensity": {
    "prefix": "render.FogMaxDensity",
    "body": "render.FogMaxDensity(${1:number maxDensity})$0",
    "description": "(Client) Function: render.FogMaxDensity\n\nSets the maximum density of the fog."
  },
  "render.FogMode": {
    "prefix": "render.FogMode",
    "body": "render.FogMode(${1:number fogMode})$0",
    "description": "(Client) Function: render.FogMode\n\nSets the mode of fog."
  },
  "render.FogStart": {
    "prefix": "render.FogStart",
    "body": "render.FogStart(${1:number fogStart})$0",
    "description": "(Client) Function: render.FogStart\n\nSets the distance at which the fog starts showing up."
  },
  "render.GetAmbientLightColor": {
    "prefix": "render.GetAmbientLightColor",
    "body": "render.GetAmbientLightColor()$0",
    "description": "(Client) Function: render.GetAmbientLightColor\n\nReturns the ambient color of the map."
  },
  "render.GetBlend": {
    "prefix": "render.GetBlend",
    "body": "render.GetBlend()$0",
    "description": "(Client) Function: render.GetBlend\n\nReturns the current alpha blending."
  },
  "render.GetBloomTex0": {
    "prefix": "render.GetBloomTex0",
    "body": "render.GetBloomTex0()$0",
    "description": "(Client) Function: render.GetBloomTex0\n\n"
  },
  "render.GetBloomTex1": {
    "prefix": "render.GetBloomTex1",
    "body": "render.GetBloomTex1()$0",
    "description": "(Client) Function: render.GetBloomTex1\n\n"
  },
  "render.GetColorModulation": {
    "prefix": "render.GetColorModulation",
    "body": "render.GetColorModulation()$0",
    "description": "(Client) Function: render.GetColorModulation\n\nReturns the current color modulation values as normals."
  },
  "render.GetDXLevel": {
    "prefix": "render.GetDXLevel",
    "body": "render.GetDXLevel()$0",
    "description": "(Client) Function: render.GetDXLevel\n\nReturns the maximum available directX version."
  },
  "render.GetFogColor": {
    "prefix": "render.GetFogColor",
    "body": "render.GetFogColor()$0",
    "description": "(Client) Function: render.GetFogColor\n\nReturns the current fog color."
  },
  "render.GetFogDistances": {
    "prefix": "render.GetFogDistances",
    "body": "render.GetFogDistances()$0",
    "description": "(Client) Function: render.GetFogDistances\n\nReturns the fog start and end distance."
  },
  "render.GetFogMode": {
    "prefix": "render.GetFogMode",
    "body": "render.GetFogMode()$0",
    "description": "(Client) Function: render.GetFogMode\n\nReturns the fog mode."
  },
  "render.GetFullScreenDepthTexture": {
    "prefix": "render.GetFullScreenDepthTexture",
    "body": "render.GetFullScreenDepthTexture()$0",
    "description": "(Client) Function: render.GetFullScreenDepthTexture\n\nReturns the _rt_FullFrameDepth texture. Alias of _rt_PowerOfTwoFB"
  },
  "render.GetLightColor": {
    "prefix": "render.GetLightColor",
    "body": "render.GetLightColor(${1:Vector position})$0",
    "description": "(Client) Function: render.GetLightColor\n\nGets the light exposure on the specified position."
  },
  "render.GetMoBlurTex0": {
    "prefix": "render.GetMoBlurTex0",
    "body": "render.GetMoBlurTex0()$0",
    "description": "(Client) Function: render.GetMoBlurTex0\n\n"
  },
  "render.GetMoBlurTex1": {
    "prefix": "render.GetMoBlurTex1",
    "body": "render.GetMoBlurTex1()$0",
    "description": "(Client) Function: render.GetMoBlurTex1\n\n"
  },
  "render.GetMorphTex0": {
    "prefix": "render.GetMorphTex0",
    "body": "render.GetMorphTex0()$0",
    "description": "(Client) Function: render.GetMorphTex0\n\n"
  },
  "render.GetMorphTex1": {
    "prefix": "render.GetMorphTex1",
    "body": "render.GetMorphTex1()$0",
    "description": "(Client) Function: render.GetMorphTex1\n\n"
  },
  "render.GetPowerOfTwoTexture": {
    "prefix": "render.GetPowerOfTwoTexture",
    "body": "render.GetPowerOfTwoTexture()$0",
    "description": "(Client) Function: render.GetPowerOfTwoTexture\n\nReturns the render target's power of two texture."
  },
  "render.GetRefractTexture": {
    "prefix": "render.GetRefractTexture",
    "body": "render.GetRefractTexture()$0",
    "description": "(Client) Function: render.GetRefractTexture\n\nAlias of render.GetPowerOfTwoTexture."
  },
  "render.GetRenderTarget": {
    "prefix": "render.GetRenderTarget",
    "body": "render.GetRenderTarget()$0",
    "description": "(Client) Function: render.GetRenderTarget\n\nReturns the currently active render target."
  },
  "render.GetResolvedFullFrameDepth": {
    "prefix": "render.GetResolvedFullFrameDepth",
    "body": "render.GetResolvedFullFrameDepth()$0",
    "description": "(Client) Function: render.GetResolvedFullFrameDepth\n\nReturns the _rt_ResolvedFullFrameDepth texture for SSAO depth."
  },
  "render.GetScreenEffectTexture": {
    "prefix": "render.GetScreenEffectTexture",
    "body": "render.GetScreenEffectTexture(${1:number textureIndex=0})$0",
    "description": "(Client) Function: render.GetScreenEffectTexture\n\nObtain an ITexture of the screen. You must call render.UpdateScreenEffectTexture in order to update this texture with the currently rendered scene."
  },
  "render.GetSmallTex0": {
    "prefix": "render.GetSmallTex0",
    "body": "render.GetSmallTex0()$0",
    "description": "(Client) Function: render.GetSmallTex0\n\n"
  },
  "render.GetSmallTex1": {
    "prefix": "render.GetSmallTex1",
    "body": "render.GetSmallTex1()$0",
    "description": "(Client) Function: render.GetSmallTex1\n\n"
  },
  "render.GetSuperFPTex": {
    "prefix": "render.GetSuperFPTex",
    "body": "render.GetSuperFPTex()$0",
    "description": "(Client) Function: render.GetSuperFPTex\n\nReturns a floating point texture the same resolution as the screen."
  },
  "render.GetSuperFPTex2": {
    "prefix": "render.GetSuperFPTex2",
    "body": "render.GetSuperFPTex2()$0",
    "description": "(Client) Function: render.GetSuperFPTex2\n\n:render/GetSuperFPTex"
  },
  "render.GetSurfaceColor": {
    "prefix": "render.GetSurfaceColor",
    "body": "render.GetSurfaceColor(${1:Vector startPos}, ${2:Vector endPos})$0",
    "description": "(Client) Function: render.GetSurfaceColor\n\nPerforms a render trace and returns the color of the surface hit, this uses a low res version of the texture."
  },
  "render.GetToneMappingScaleLinear": {
    "prefix": "render.GetToneMappingScaleLinear",
    "body": "render.GetToneMappingScaleLinear()$0",
    "description": "(Client) Function: render.GetToneMappingScaleLinear\n\nReturns a vector representing linear tone mapping scale."
  },
  "render.MaterialOverride": {
    "prefix": "render.MaterialOverride",
    "body": "render.MaterialOverride(${1:IMaterial material})$0",
    "description": "(Client) Function: render.MaterialOverride\n\nSets the render material override for all next calls of Entity.DrawModel. Also overrides render.MaterialOverrideByIndex."
  },
  "render.MaterialOverrideByIndex": {
    "prefix": "render.MaterialOverrideByIndex",
    "body": "render.MaterialOverrideByIndex(${1:number index}, ${2:IMaterial material})$0",
    "description": "(Client) Function: render.MaterialOverrideByIndex\n\nSimilar to render.MaterialOverride, but overrides the materials per index."
  },
  "render.MaxTextureHeight": {
    "prefix": "render.MaxTextureHeight",
    "body": "render.MaxTextureHeight()$0",
    "description": "(Client) Function: render.MaxTextureHeight\n\nReturns the maximum texture height the renderer can handle."
  },
  "render.MaxTextureWidth": {
    "prefix": "render.MaxTextureWidth",
    "body": "render.MaxTextureWidth()$0",
    "description": "(Client) Function: render.MaxTextureWidth\n\nReturns the maximum texture width the renderer can handle."
  },
  "render.Model": {
    "prefix": "render.Model",
    "body": "render.Model(${1:table settings}, ${2:CSEnt ent=nil})$0",
    "description": "(Client) Function: render.Model\n\nCreates a new _G.ClientsideModel, renders it at the specified pos/ang, and removes it. Can also be given an existing CSEnt to reuse instead."
  },
  "render.ModelMaterialOverride": {
    "prefix": "render.ModelMaterialOverride",
    "body": "render.ModelMaterialOverride(${1:IMaterial material})$0",
    "description": "(Client) Function: render.ModelMaterialOverride\n\nSets a material to override a model's default material. Similar to Entity.SetMaterial except it uses an IMaterial argument and it can be used to change materials on models which are part of the world geometry."
  },
  "render.OverrideAlphaWriteEnable": {
    "prefix": "render.OverrideAlphaWriteEnable",
    "body": "render.OverrideAlphaWriteEnable(${1:boolean enable}, ${2:boolean shouldWrite})$0",
    "description": "(Client) Function: render.OverrideAlphaWriteEnable\n\nOverrides the write behaviour of all next rendering operations towards the alpha channel of the current render target."
  },
  "render.OverrideBlendFunc": {
    "prefix": "render.OverrideBlendFunc",
    "body": "render.OverrideBlendFunc(${1:boolean enabled}, ${2:number srcBlend}, ${3:number destBlend}, ${4:number srcBlendAlpha=nil}, ${5:number destBlendAlpha=nil})$0",
    "description": "(Client) Function: render.OverrideBlendFunc\n\nOverrides the internal graphical functions used to determine the final color and alpha of a rendered texture."
  },
  "render.OverrideColorWriteEnable": {
    "prefix": "render.OverrideColorWriteEnable",
    "body": "render.OverrideColorWriteEnable(${1:boolean enable}, ${2:boolean shouldWrite})$0",
    "description": "(Client) Function: render.OverrideColorWriteEnable\n\nOverrides the write behaviour of all next rendering operations towards the color channel of the current render target."
  },
  "render.OverrideDepthEnable": {
    "prefix": "render.OverrideDepthEnable",
    "body": "render.OverrideDepthEnable(${1:boolean enable}, ${2:boolean shouldWrite})$0",
    "description": "(Client) Function: render.OverrideDepthEnable\n\nOverrides the write behaviour of all next rendering operations towards the depth buffer."
  },
  "render.PerformFullScreenStencilOperation": {
    "prefix": "render.PerformFullScreenStencilOperation",
    "body": "render.PerformFullScreenStencilOperation()$0",
    "description": "(Client) Function: render.PerformFullScreenStencilOperation\n\n"
  },
  "render.PopCustomClipPlane": {
    "prefix": "render.PopCustomClipPlane",
    "body": "render.PopCustomClipPlane()$0",
    "description": "(Client) Function: render.PopCustomClipPlane\n\nRemoves the current active clipping plane from the clip plane stack."
  },
  "render.PopFilterMag": {
    "prefix": "render.PopFilterMag",
    "body": "render.PopFilterMag()$0",
    "description": "(Client) Function: render.PopFilterMag\n\nPops the current texture magnification filter from the filter stack."
  },
  "render.PopFilterMin": {
    "prefix": "render.PopFilterMin",
    "body": "render.PopFilterMin()$0",
    "description": "(Client) Function: render.PopFilterMin\n\nPops the current texture minification filter from the filter stack."
  },
  "render.PopFlashlightMode": {
    "prefix": "render.PopFlashlightMode",
    "body": "render.PopFlashlightMode()$0",
    "description": "(Client) Function: render.PopFlashlightMode\n\nPops the current flashlight mode from the flashlight mode stack."
  },
  "render.PopRenderTarget": {
    "prefix": "render.PopRenderTarget",
    "body": "render.PopRenderTarget()$0",
    "description": "(Client) Function: render.PopRenderTarget\n\nPops the last render target and viewport from the RT stack and sets them as the current render target and viewport."
  },
  "render.PushCustomClipPlane": {
    "prefix": "render.PushCustomClipPlane",
    "body": "render.PushCustomClipPlane(${1:Vector normal}, ${2:number distance})$0",
    "description": "(Client) Function: render.PushCustomClipPlane\n\nPushes a new clipping plane of the clip plane stack and sets it as active."
  },
  "render.PushFilterMag": {
    "prefix": "render.PushFilterMag",
    "body": "render.PushFilterMag(${1:number texFilterType})$0",
    "description": "(Client) Function: render.PushFilterMag\n\nPushes a texture filter onto the magnification texture filter stack."
  },
  "render.PushFilterMin": {
    "prefix": "render.PushFilterMin",
    "body": "render.PushFilterMin(${1:number texFilterType})$0",
    "description": "(Client) Function: render.PushFilterMin\n\nPushes a texture filter onto the minification texture filter stack."
  },
  "render.PushFlashlightMode": {
    "prefix": "render.PushFlashlightMode",
    "body": "render.PushFlashlightMode(${1:boolean enable=false})$0",
    "description": "(Client) Function: render.PushFlashlightMode\n\nEnables the flashlight projection for the upcoming rendering."
  },
  "render.PushRenderTarget": {
    "prefix": "render.PushRenderTarget",
    "body": "render.PushRenderTarget(${1:ITexture texture}, ${2:number x=0}, ${3:number y=0}, ${4:number w=texture:Width()}, ${5:number h=texture:Height()})$0",
    "description": "(Client) Function: render.PushRenderTarget\n\nPushes the current render target and viewport to the RT stack then sets a new current render target and viewport. If the viewport is not specified, the dimensions of the render target are used instead."
  },
  "render.ReadPixel": {
    "prefix": "render.ReadPixel",
    "body": "render.ReadPixel(${1:number x}, ${2:number y})$0",
    "description": "(Client) Function: render.ReadPixel\n\nReads the color of the specified pixel from the RenderTarget sent by render.CapturePixels"
  },
  "render.RedownloadAllLightmaps": {
    "prefix": "render.RedownloadAllLightmaps",
    "body": "render.RedownloadAllLightmaps(${1:boolean DoStaticProps=false})$0",
    "description": "(Client) Function: render.RedownloadAllLightmaps\n\nThis applies the changes made to map lighting using engine.LightStyle."
  },
  "render.RenderHUD": {
    "prefix": "render.RenderHUD",
    "body": "render.RenderHUD(${1:number x}, ${2:number y}, ${3:number w}, ${4:number h})$0",
    "description": "(Client) Function: render.RenderHUD\n\nRenders the HUD on the screen."
  },
  "render.RenderView": {
    "prefix": "render.RenderView",
    "body": "render.RenderView(${1:table view=nil})$0",
    "description": "(Client) Function: render.RenderView\n\nRenders the scene with the specified viewData to the current active render target."
  },
  "render.ResetModelLighting": {
    "prefix": "render.ResetModelLighting",
    "body": "render.ResetModelLighting(${1:number r}, ${2:number g}, ${3:number b})$0",
    "description": "(Client) Function: render.ResetModelLighting\n\nResets the model lighting to the specified color."
  },
  "render.ResetToneMappingScale": {
    "prefix": "render.ResetToneMappingScale",
    "body": "render.ResetToneMappingScale(${1:number scale})$0",
    "description": "(Client) Function: render.ResetToneMappingScale\n\nResets the HDR tone multiplier to the specified value."
  },
  "render.SetAmbientLight": {
    "prefix": "render.SetAmbientLight",
    "body": "render.SetAmbientLight(${1:number r}, ${2:number g}, ${3:number b})$0",
    "description": "(Client) Function: render.SetAmbientLight\n\nSets the ambient lighting for any upcoming render operation."
  },
  "render.SetBlend": {
    "prefix": "render.SetBlend",
    "body": "render.SetBlend(${1:number blending})$0",
    "description": "(Client) Function: render.SetBlend\n\nSets the alpha blending for every upcoming render operation."
  },
  "render.SetColorMaterial": {
    "prefix": "render.SetColorMaterial",
    "body": "render.SetColorMaterial()$0",
    "description": "(Client) Function: render.SetColorMaterial\n\nSets the current drawing material to \"color\"."
  },
  "render.SetColorMaterialIgnoreZ": {
    "prefix": "render.SetColorMaterialIgnoreZ",
    "body": "render.SetColorMaterialIgnoreZ()$0",
    "description": "(Client) Function: render.SetColorMaterialIgnoreZ\n\nSets the current drawing material to \"color_ignorez\"."
  },
  "render.SetColorModulation": {
    "prefix": "render.SetColorModulation",
    "body": "render.SetColorModulation(${1:number r}, ${2:number g}, ${3:number b})$0",
    "description": "(Client) Function: render.SetColorModulation\n\nSets the color modulation."
  },
  "render.SetFogZ": {
    "prefix": "render.SetFogZ",
    "body": "render.SetFogZ(${1:number fogZ})$0",
    "description": "(Client) Function: render.SetFogZ\n\nIf the fog mode is set to [[Enums/MATERIAL_FOG.MATERIAL_FOG_LINEAR_BELOW_FOG_Z]], the fog will only be rendered below the specified height."
  },
  "render.SetGoalToneMappingScale": {
    "prefix": "render.SetGoalToneMappingScale",
    "body": "render.SetGoalToneMappingScale(${1:number scale})$0",
    "description": "(Client) Function: render.SetGoalToneMappingScale\n\nSets the goal HDR tone mapping scale."
  },
  "render.SetLightingMode": {
    "prefix": "render.SetLightingMode",
    "body": "render.SetLightingMode(${1:number Mode})$0",
    "description": "(Client) Function: render.SetLightingMode\n\nSets lighting mode when rendering something."
  },
  "render.SetLightingOrigin": {
    "prefix": "render.SetLightingOrigin",
    "body": "render.SetLightingOrigin(${1:Vector lightingOrigin})$0",
    "description": "(Client) Function: render.SetLightingOrigin\n\nSets the lighting origin."
  },
  "render.SetLightmapTexture": {
    "prefix": "render.SetLightmapTexture",
    "body": "render.SetLightmapTexture(${1:ITexture tex})$0",
    "description": "(Client) Function: render.SetLightmapTexture\n\nSets the texture to be used as the lightmap in upcoming rendering operations. This is required when rendering meshes using a material with a lightmapped shader such as LightmappedGeneric."
  },
  "render.SetLocalModelLights": {
    "prefix": "render.SetLocalModelLights",
    "body": "render.SetLocalModelLights(${1:table lights={}})$0",
    "description": "(Client) Function: render.SetLocalModelLights\n\nSets up the local lighting for any upcoming render operation. Up to 4 local lights can be defined, with one of three different types (point, directional, spot)."
  },
  "render.SetMaterial": {
    "prefix": "render.SetMaterial",
    "body": "render.SetMaterial(${1:IMaterial mat})$0",
    "description": "(Client) Function: render.SetMaterial\n\nSets the material to be used in any upcoming render operation using the Lib library."
  },
  "render.SetModelLighting": {
    "prefix": "render.SetModelLighting",
    "body": "render.SetModelLighting(${1:number lightDirection}, ${2:number red}, ${3:number green}, ${4:number blue})$0",
    "description": "(Client) Function: render.SetModelLighting\n\nSets up the ambient lighting for any upcoming render operation. Ambient lighting can be seen as a cube enclosing the object to be drawn, each of its faces representing a directional light source that shines towards the object. Thus, there is a total of six different light sources that can be configured separately."
  },
  "render.SetRenderTarget": {
    "prefix": "render.SetRenderTarget",
    "body": "render.SetRenderTarget(${1:ITexture texture})$0",
    "description": "(Client) Function: render.SetRenderTarget\n\nSets the render target to the specified rt."
  },
  "render.SetRenderTargetEx": {
    "prefix": "render.SetRenderTargetEx",
    "body": "render.SetRenderTargetEx(${1:number rtIndex}, ${2:ITexture texture})$0",
    "description": "(Client) Function: render.SetRenderTargetEx\n\nSets the render target with the specified index to the specified rt."
  },
  "render.SetScissorRect": {
    "prefix": "render.SetScissorRect",
    "body": "render.SetScissorRect(${1:number startX}, ${2:number startY}, ${3:number endX}, ${4:number endY}, ${5:boolean enable})$0",
    "description": "(Client) Function: render.SetScissorRect\n\nSets a scissoring rect which limits the drawing area."
  },
  "render.SetShadowColor": {
    "prefix": "render.SetShadowColor",
    "body": "render.SetShadowColor(${1:number red}, ${2:number green}, ${3:number blue})$0",
    "description": "(Client) Function: render.SetShadowColor\n\nSets the shadow color."
  },
  "render.SetShadowDirection": {
    "prefix": "render.SetShadowDirection",
    "body": "render.SetShadowDirection(${1:Vector shadowDirections})$0",
    "description": "(Client) Function: render.SetShadowDirection\n\nSets the shadow projection direction."
  },
  "render.SetShadowDistance": {
    "prefix": "render.SetShadowDistance",
    "body": "render.SetShadowDistance(${1:number shadowDistance})$0",
    "description": "(Client) Function: render.SetShadowDistance\n\nSets the maximum shadow projection range."
  },
  "render.SetShadowsDisabled": {
    "prefix": "render.SetShadowsDisabled",
    "body": "render.SetShadowsDisabled(${1:boolean })$0",
    "description": "(Client) Function: render.SetShadowsDisabled\n\nSets whether any future render operations will ignore shadow drawing."
  },
  "render.SetStencilCompareFunction": {
    "prefix": "render.SetStencilCompareFunction",
    "body": "render.SetStencilCompareFunction(${1:number compareFunction})$0",
    "description": "(Client) Function: render.SetStencilCompareFunction\n\nSets the compare function of the stencil."
  },
  "render.SetStencilEnable": {
    "prefix": "render.SetStencilEnable",
    "body": "render.SetStencilEnable(${1:boolean newState})$0",
    "description": "(Client) Function: render.SetStencilEnable\n\nSets whether stencil tests are carried out for each rendered pixel."
  },
  "render.SetStencilFailOperation": {
    "prefix": "render.SetStencilFailOperation",
    "body": "render.SetStencilFailOperation(${1:number failOperation})$0",
    "description": "(Client) Function: render.SetStencilFailOperation\n\nSets the operation to be performed on the stencil buffer values if the compare function was not successful."
  },
  "render.SetStencilPassOperation": {
    "prefix": "render.SetStencilPassOperation",
    "body": "render.SetStencilPassOperation(${1:number passOperation})$0",
    "description": "(Client) Function: render.SetStencilPassOperation\n\nSets the operation to be performed on the stencil buffer values if the compare function was successful."
  },
  "render.SetStencilReferenceValue": {
    "prefix": "render.SetStencilReferenceValue",
    "body": "render.SetStencilReferenceValue(${1:number referenceValue})$0",
    "description": "(Client) Function: render.SetStencilReferenceValue\n\nSets the reference value which will be used for all stencil operations. This is an unsigned integer."
  },
  "render.SetStencilTestMask": {
    "prefix": "render.SetStencilTestMask",
    "body": "render.SetStencilTestMask(${1:number mask})$0",
    "description": "(Client) Function: render.SetStencilTestMask\n\nSets the unsigned 8-bit test bitflag mask to be used for any stencil testing."
  },
  "render.SetStencilWriteMask": {
    "prefix": "render.SetStencilWriteMask",
    "body": "render.SetStencilWriteMask(${1:number mask})$0",
    "description": "(Client) Function: render.SetStencilWriteMask\n\nSets the unsigned 8-bit write bitflag mask to be used for any writes to the stencil buffer."
  },
  "render.SetStencilZFailOperation": {
    "prefix": "render.SetStencilZFailOperation",
    "body": "render.SetStencilZFailOperation(${1:number zFailOperation})$0",
    "description": "(Client) Function: render.SetStencilZFailOperation\n\nSets the operation to be performed on the stencil buffer values if the stencil test is passed but the depth buffer test fails."
  },
  "render.SetToneMappingScaleLinear": {
    "prefix": "render.SetToneMappingScaleLinear",
    "body": "render.SetToneMappingScaleLinear(${1:Vector vec})$0",
    "description": "(Client) Function: render.SetToneMappingScaleLinear\n\n"
  },
  "render.SetViewPort": {
    "prefix": "render.SetViewPort",
    "body": "render.SetViewPort(${1:number x}, ${2:number y}, ${3:number w}, ${4:number h})$0",
    "description": "(Client) Function: render.SetViewPort\n\nChanges the view port position and size."
  },
  "render.SetWriteDepthToDestAlpha": {
    "prefix": "render.SetWriteDepthToDestAlpha",
    "body": "render.SetWriteDepthToDestAlpha(${1:boolean enable})$0",
    "description": "(Client) Function: render.SetWriteDepthToDestAlpha\n\n"
  },
  "render.Spin": {
    "prefix": "render.Spin",
    "body": "render.Spin()$0",
    "description": "(Client) Function: render.Spin\n\nSwaps the frame buffers/cycles the frame. In other words, this updates the screen."
  },
  "render.StartBeam": {
    "prefix": "render.StartBeam",
    "body": "render.StartBeam(${1:number segmentCount})$0",
    "description": "(Client) Function: render.StartBeam\n\nStart a new beam draw operation."
  },
  "render.SupportsHDR": {
    "prefix": "render.SupportsHDR",
    "body": "render.SupportsHDR()$0",
    "description": "(Client) Function: render.SupportsHDR\n\nReturns whether the game supports HDR, i.e. if the DirectX level is higher than or equal to 8."
  },
  "render.SupportsPixelShaders_1_4": {
    "prefix": "render.SupportsPixelShaders_1_4",
    "body": "render.SupportsPixelShaders_1_4()$0",
    "description": "(Client) Function: render.SupportsPixelShaders_1_4\n\nReturns if the current settings and the system allow the usage of pixel shaders 1.4."
  },
  "render.SupportsPixelShaders_2_0": {
    "prefix": "render.SupportsPixelShaders_2_0",
    "body": "render.SupportsPixelShaders_2_0()$0",
    "description": "(Client) Function: render.SupportsPixelShaders_2_0\n\nReturns if the current settings and the system allow the usage of pixel shaders 2.0."
  },
  "render.SupportsVertexShaders_2_0": {
    "prefix": "render.SupportsVertexShaders_2_0",
    "body": "render.SupportsVertexShaders_2_0()$0",
    "description": "(Client) Function: render.SupportsVertexShaders_2_0\n\nReturns if the current settings and the system allow the usage of vertex shaders 2.0."
  },
  "render.SuppressEngineLighting": {
    "prefix": "render.SuppressEngineLighting",
    "body": "render.SuppressEngineLighting(${1:boolean suppressLighting})$0",
    "description": "(Client) Function: render.SuppressEngineLighting\n\nSuppresses or enables any engine lighting for any upcoming render operation."
  },
  "render.TurnOnToneMapping": {
    "prefix": "render.TurnOnToneMapping",
    "body": "render.TurnOnToneMapping()$0",
    "description": "(Client) Function: render.TurnOnToneMapping\n\nEnables HDR tone mapping which influences the brightness."
  },
  "render.UpdateFullScreenDepthTexture": {
    "prefix": "render.UpdateFullScreenDepthTexture",
    "body": "render.UpdateFullScreenDepthTexture()$0",
    "description": "(Client) Function: render.UpdateFullScreenDepthTexture\n\nUpdates the texture returned by render.GetFullScreenDepthTexture."
  },
  "render.UpdatePowerOfTwoTexture": {
    "prefix": "render.UpdatePowerOfTwoTexture",
    "body": "render.UpdatePowerOfTwoTexture()$0",
    "description": "(Client) Function: render.UpdatePowerOfTwoTexture\n\nUpdates the power of two texture."
  },
  "render.UpdateRefractTexture": {
    "prefix": "render.UpdateRefractTexture",
    "body": "render.UpdateRefractTexture()$0",
    "description": "(Client) Function: render.UpdateRefractTexture\n\nPretty much alias of render.UpdatePowerOfTwoTexture but does not return the texture."
  },
  "render.UpdateScreenEffectTexture": {
    "prefix": "render.UpdateScreenEffectTexture",
    "body": "render.UpdateScreenEffectTexture()$0",
    "description": "(Client) Function: render.UpdateScreenEffectTexture\n\nCopies the entire screen to the screen effect texture, which can be acquired via render.GetScreenEffectTexture. This function is mainly intended to be used in GM.RenderScreenspaceEffects"
  },
  "render": [],
  "resource.AddFile": {
    "prefix": "resource.AddFile",
    "body": "resource.AddFile(${1:string path})$0",
    "description": "(Server) Function: resource.AddFile\n\nAdds the specified and all related files to the files the client should download."
  },
  "resource.AddSingleFile": {
    "prefix": "resource.AddSingleFile",
    "body": "resource.AddSingleFile(${1:string path})$0",
    "description": "(Server) Function: resource.AddSingleFile\n\nAdds the specified file to the files the client should download."
  },
  "resource.AddWorkshop": {
    "prefix": "resource.AddWorkshop",
    "body": "resource.AddWorkshop(${1:string workshopid})$0",
    "description": "(Server) Function: resource.AddWorkshop\n\nAdds a workshop addon for the client to download before entering the server."
  },
  "resource": [],
  "saverestore.AddRestoreHook": {
    "prefix": "saverestore.AddRestoreHook",
    "body": "saverestore.AddRestoreHook(${1:string identifier}, ${2:function callback})$0",
    "description": "(Shared) Function: saverestore.AddRestoreHook\n\nAdds a restore/load hook for the Half-Life 2 save system."
  },
  "saverestore.AddSaveHook": {
    "prefix": "saverestore.AddSaveHook",
    "body": "saverestore.AddSaveHook(${1:string identifier}, ${2:function callback})$0",
    "description": "(Shared) Function: saverestore.AddSaveHook\n\nAdds a save hook for the Half-Life 2 save system. You can this to carry data through level transitions in Half-Life 2."
  },
  "saverestore.LoadEntity": {
    "prefix": "saverestore.LoadEntity",
    "body": "saverestore.LoadEntity(${1:Entity ent}, ${2:IRestore save})$0",
    "description": "(Shared) Function: saverestore.LoadEntity\n\nLoads Entity.GetTable from the save game file that is being loaded and merges it with the given entitys Entity.GetTable."
  },
  "saverestore.LoadGlobal": {
    "prefix": "saverestore.LoadGlobal",
    "body": "saverestore.LoadGlobal(${1:IRestore save})$0",
    "description": "(Shared) Function: saverestore.LoadGlobal\n\n[Internal] "
  },
  "saverestore.PreRestore": {
    "prefix": "saverestore.PreRestore",
    "body": "saverestore.PreRestore()$0",
    "description": "(Shared) Function: saverestore.PreRestore\n\n[Internal] "
  },
  "saverestore.PreSave": {
    "prefix": "saverestore.PreSave",
    "body": "saverestore.PreSave()$0",
    "description": "(Shared) Function: saverestore.PreSave\n\n[Internal] "
  },
  "saverestore.ReadTable": {
    "prefix": "saverestore.ReadTable",
    "body": "saverestore.ReadTable(${1:IRestore save})$0",
    "description": "(Shared) Function: saverestore.ReadTable\n\nReads a table from the save game file that is being loaded."
  },
  "saverestore.ReadVar": {
    "prefix": "saverestore.ReadVar",
    "body": "saverestore.ReadVar(${1:IRestore save})$0",
    "description": "(Shared) Function: saverestore.ReadVar\n\nLoads a variable from the save game file that is being loaded."
  },
  "saverestore.SaveEntity": {
    "prefix": "saverestore.SaveEntity",
    "body": "saverestore.SaveEntity(${1:Entity ent}, ${2:ISave save})$0",
    "description": "(Shared) Function: saverestore.SaveEntity\n\nSaves entitys Entity.GetTable to the save game file that is being saved."
  },
  "saverestore.SaveGlobal": {
    "prefix": "saverestore.SaveGlobal",
    "body": "saverestore.SaveGlobal(${1:ISave save})$0",
    "description": "(Shared) Function: saverestore.SaveGlobal\n\n[Internal] "
  },
  "saverestore.WritableKeysInTable": {
    "prefix": "saverestore.WritableKeysInTable",
    "body": "saverestore.WritableKeysInTable(${1:table table})$0",
    "description": "(Shared) Function: saverestore.WritableKeysInTable\n\nReturns how many writable keys are in the given table."
  },
  "saverestore.WriteTable": {
    "prefix": "saverestore.WriteTable",
    "body": "saverestore.WriteTable(${1:table table}, ${2:ISave save})$0",
    "description": "(Shared) Function: saverestore.WriteTable\n\nWrite a table to a save game file that is being saved."
  },
  "saverestore.WriteVar": {
    "prefix": "saverestore.WriteVar",
    "body": "saverestore.WriteVar(${1:any value}, ${2:ISave save})$0",
    "description": "(Shared) Function: saverestore.WriteVar\n\nWrites a variable to the save game file that is being saved."
  },
  "saverestore": [],
  "scripted_ents.Alias": {
    "prefix": "scripted_ents.Alias",
    "body": "scripted_ents.Alias(${1:string alias}, ${2:string classname})$0",
    "description": "(Shared) Function: scripted_ents.Alias\n\nDefines an alias string that can be used to refer to another classname"
  },
  "scripted_ents.Get": {
    "prefix": "scripted_ents.Get",
    "body": "scripted_ents.Get(${1:string classname})$0",
    "description": "(Shared) Function: scripted_ents.Get\n\nReturns a copy of the ENT table for a class, including functions defined by the base class"
  },
  "scripted_ents.GetList": {
    "prefix": "scripted_ents.GetList",
    "body": "scripted_ents.GetList()$0",
    "description": "(Shared) Function: scripted_ents.GetList\n\nReturns a copy of the list of all ENT tables registered"
  },
  "scripted_ents.GetMember": {
    "prefix": "scripted_ents.GetMember",
    "body": "scripted_ents.GetMember(${1:string class}, ${2:string name})$0",
    "description": "(Shared) Function: scripted_ents.GetMember\n\nRetrieves a member of entity's table."
  },
  "scripted_ents.GetSpawnable": {
    "prefix": "scripted_ents.GetSpawnable",
    "body": "scripted_ents.GetSpawnable()$0",
    "description": "(Shared) Function: scripted_ents.GetSpawnable\n\nReturns a list of all ENT tables which contain either ENT.Spawnable or ENT.AdminSpawnable"
  },
  "scripted_ents.GetStored": {
    "prefix": "scripted_ents.GetStored",
    "body": "scripted_ents.GetStored(${1:string classname})$0",
    "description": "(Shared) Function: scripted_ents.GetStored\n\nReturns the actual ENT table for a class. Modifying functions/variables in this table will change newly spawned entities"
  },
  "scripted_ents.GetType": {
    "prefix": "scripted_ents.GetType",
    "body": "scripted_ents.GetType(${1:string classname})$0",
    "description": "(Shared) Function: scripted_ents.GetType\n\nReturns the 'type' of a class, this will one of the following: 'anim', 'ai', 'brush', 'point'."
  },
  "scripted_ents.IsBasedOn": {
    "prefix": "scripted_ents.IsBasedOn",
    "body": "scripted_ents.IsBasedOn(${1:string name}, ${2:string base})$0",
    "description": "(Shared) Function: scripted_ents.IsBasedOn\n\nChecks if name is based on base"
  },
  "scripted_ents.OnLoaded": {
    "prefix": "scripted_ents.OnLoaded",
    "body": "scripted_ents.OnLoaded()$0",
    "description": "(Shared) Function: scripted_ents.OnLoaded\n\n[Internal] "
  },
  "scripted_ents.Register": {
    "prefix": "scripted_ents.Register",
    "body": "scripted_ents.Register(${1:table ENT}, ${2:string classname})$0",
    "description": "(Shared) Function: scripted_ents.Register\n\nRegisters an ENT table with a classname. Reregistering an existing classname will automatically update the functions of all existing entities of that class."
  },
  "scripted_ents": [],
  "search.AddProvider": {
    "prefix": "search.AddProvider",
    "body": "search.AddProvider(${1:function provider}, ${2:string id=nil})$0",
    "description": "(Client) Function: search.AddProvider\n\nAdds a search result provider. For examples, see gamemodes/sandbox/gamemode/cl_search_models.lua"
  },
  "search.GetResults": {
    "prefix": "search.GetResults",
    "body": "search.GetResults(${1:string query})$0",
    "description": "(Client) Function: search.GetResults\n\nRetrieves search results."
  },
  "search": [],
  "serverlist.PlayerList": {
    "prefix": "serverlist.PlayerList",
    "body": "serverlist.PlayerList(${1:string ip}, ${2:function callback})$0",
    "description": "(Menu) Function: serverlist.PlayerList\n\nQueries a server for its player list."
  },
  "serverlist.Query": {
    "prefix": "serverlist.Query",
    "body": "serverlist.Query(${1:table data})$0",
    "description": "(Menu) Function: serverlist.Query\n\nQueries the master server for server list."
  },
  "serverlist": [],
  "sound.Add": {
    "prefix": "sound.Add",
    "body": "sound.Add(${1:table soundData})$0",
    "description": "(Shared) Function: sound.Add\n\nCreates a sound script. It can also override sounds, which seems to only work when set on the server."
  },
  "sound.AddSoundOverrides": {
    "prefix": "sound.AddSoundOverrides",
    "body": "sound.AddSoundOverrides(${1:string filepath})$0",
    "description": "(Shared) Function: sound.AddSoundOverrides\n\nOverrides sounds defined inside of a txt file; typically used for adding map-specific sounds."
  },
  "sound.Generate": {
    "prefix": "sound.Generate",
    "body": "sound.Generate(${1:string indentifier}, ${2:number samplerate}, ${3:number length}, ${4:function callback})$0",
    "description": "(Client) Function: sound.Generate\n\nCreates a sound from a function."
  },
  "sound.GetProperties": {
    "prefix": "sound.GetProperties",
    "body": "sound.GetProperties(${1:string name})$0",
    "description": "(Shared) Function: sound.GetProperties\n\nReturns properties of the soundscript."
  },
  "sound.GetTable": {
    "prefix": "sound.GetTable",
    "body": "sound.GetTable()$0",
    "description": "(Shared) Function: sound.GetTable\n\nReturns a list of all registered sound scripts."
  },
  "sound.Play": {
    "prefix": "sound.Play",
    "body": "sound.Play(${1:string Name}, ${2:Vector Pos}, ${3:number Level}, ${4:number Pitch}, ${5:number Volume})$0",
    "description": "(Shared) Function: sound.Play\n\nPlays a sound from the specified position in the world."
  },
  "sound.PlayFile": {
    "prefix": "sound.PlayFile",
    "body": "sound.PlayFile(${1:string path}, ${2:string flags}, ${3:function callback})$0",
    "description": "(Client) Function: sound.PlayFile\n\nPlays a file from GMod directory. You can find a list of all error codes [http://www.un4seen.com/doc/#bass/BASS_ErrorGetCode.html here]"
  },
  "sound.PlayURL": {
    "prefix": "sound.PlayURL",
    "body": "sound.PlayURL(${1:string url}, ${2:string flags}, ${3:function callback})$0",
    "description": "(Client) Function: sound.PlayURL\n\nAllows you to play external sound files, as well as online radio streams."
  },
  "sound": [],
  "spawnmenu.ActivateTool": {
    "prefix": "spawnmenu.ActivateTool",
    "body": "spawnmenu.ActivateTool(${1:string tool})$0",
    "description": "(Client) Function: spawnmenu.ActivateTool\n\nActivates a tool, opens context menu and brings up the tool gun."
  },
  "spawnmenu.ActivateToolPanel": {
    "prefix": "spawnmenu.ActivateToolPanel",
    "body": "spawnmenu.ActivateToolPanel(${1:number tab}, ${2:Panel cp})$0",
    "description": "(Client) Function: spawnmenu.ActivateToolPanel\n\nActivates tools context menu in specified tool tab."
  },
  "spawnmenu.ActiveControlPanel": {
    "prefix": "spawnmenu.ActiveControlPanel",
    "body": "spawnmenu.ActiveControlPanel()$0",
    "description": "(Client) Function: spawnmenu.ActiveControlPanel\n\nReturns currently opened control panel of a tool, post process effect or some other menu in spawnmenu."
  },
  "spawnmenu.AddContentType": {
    "prefix": "spawnmenu.AddContentType",
    "body": "spawnmenu.AddContentType(${1:string name}, ${2:function constructor})$0",
    "description": "(Client) Function: spawnmenu.AddContentType\n\nRegisters a new content type that is saveable into spawnlists."
  },
  "spawnmenu.AddCreationTab": {
    "prefix": "spawnmenu.AddCreationTab",
    "body": "spawnmenu.AddCreationTab(${1:string name}, ${2:function function}, ${3:string material=\"icon16/exclamation.png\"}, ${4:number order=1000}, ${5:string tooltip=nil})$0",
    "description": "(Client) Function: spawnmenu.AddCreationTab\n\nInserts a new tab into the CreationMenus table, which will be used by the creation menu to generate its tabs (Spawnlists, Weapons, Entities, etc.)"
  },
  "spawnmenu.AddPropCategory": {
    "prefix": "spawnmenu.AddPropCategory",
    "body": "spawnmenu.AddPropCategory(${1:string filename}, ${2:string name}, ${3:table contents}, ${4:string icon}, ${5:number id=1000}, ${6:number parentID=0}, ${7:string needsApp=\"\"})$0",
    "description": "(Client) Function: spawnmenu.AddPropCategory\n\n[Internal] .You should never try to modify player's customized spawnlists. [Deprecated] .You should never try to modify player's customized spawnlists.Used to populate prop categories in the spawnmenu tree. This function should generally be called within SANDBOX.PopulatePropMenu."
  },
  "spawnmenu.AddToolCategory": {
    "prefix": "spawnmenu.AddToolCategory",
    "body": "spawnmenu.AddToolCategory(${1:string tab}, ${2:string RealName}, ${3:string PrintName})$0",
    "description": "(Client) Function: spawnmenu.AddToolCategory\n\nUsed to create a new category in the list inside of a spawnmenu ToolTab."
  },
  "spawnmenu.AddToolMenuOption": {
    "prefix": "spawnmenu.AddToolMenuOption",
    "body": "spawnmenu.AddToolMenuOption(${1:string tab}, ${2:string category}, ${3:string class}, ${4:string name}, ${5:string cmd}, ${6:string config}, ${7:function cpanel}, ${8:table table={}})$0",
    "description": "(Client) Function: spawnmenu.AddToolMenuOption\n\nAdds an option to the right side of the spawnmenu"
  },
  "spawnmenu.AddToolTab": {
    "prefix": "spawnmenu.AddToolTab",
    "body": "spawnmenu.AddToolTab(${1:string name}, ${2:string label=name}, ${3:string icon=\"icon16/wrench.png\"})$0",
    "description": "(Client) Function: spawnmenu.AddToolTab\n\nAdds a new tool tab to the right side of the spawnmenu via the SANDBOX.AddToolMenuTabs hook."
  },
  "spawnmenu.ClearToolMenus": {
    "prefix": "spawnmenu.ClearToolMenus",
    "body": "spawnmenu.ClearToolMenus()$0",
    "description": "(Client) Function: spawnmenu.ClearToolMenus\n\n"
  },
  "spawnmenu.CreateContentIcon": {
    "prefix": "spawnmenu.CreateContentIcon",
    "body": "spawnmenu.CreateContentIcon(${1:string type}, ${2:Panel parent}, ${3:table data})$0",
    "description": "(Client) Function: spawnmenu.CreateContentIcon\n\nCreates a new content icon."
  },
  "spawnmenu.DoSaveToTextFiles": {
    "prefix": "spawnmenu.DoSaveToTextFiles",
    "body": "spawnmenu.DoSaveToTextFiles(${1:table spawnlists})$0",
    "description": "(Client) Function: spawnmenu.DoSaveToTextFiles\n\n[Internal] "
  },
  "spawnmenu.GetContentType": {
    "prefix": "spawnmenu.GetContentType",
    "body": "spawnmenu.GetContentType(${1:string contentType})$0",
    "description": "(Client) Function: spawnmenu.GetContentType\n\nReturns the function to create an vgui element for a specified content type"
  },
  "spawnmenu.GetCreationTabs": {
    "prefix": "spawnmenu.GetCreationTabs",
    "body": "spawnmenu.GetCreationTabs()$0",
    "description": "(Client) Function: spawnmenu.GetCreationTabs\n\nGets the CreationMenus table, which was filled with creation menu tabs from spawnmenu.AddCreationTab."
  },
  "spawnmenu.GetPropTable": {
    "prefix": "spawnmenu.GetPropTable",
    "body": "spawnmenu.GetPropTable()$0",
    "description": "(Client) Function: spawnmenu.GetPropTable\n\nReturns a table of all prop categories and their props in the spawnmenu. Note that if the spawnmenu has not been populated, this will return an empty table."
  },
  "spawnmenu.GetToolMenu": {
    "prefix": "spawnmenu.GetToolMenu",
    "body": "spawnmenu.GetToolMenu(${1:string name}, ${2:string label=name}, ${3:string icon=\"icon16/wrench.png\"})$0",
    "description": "(Client) Function: spawnmenu.GetToolMenu\n\nAdds a new tool tab (or returns an existing one by name) to the right side of the spawnmenu via the SANDBOX.AddToolMenuTabs hook."
  },
  "spawnmenu.GetTools": {
    "prefix": "spawnmenu.GetTools",
    "body": "spawnmenu.GetTools()$0",
    "description": "(Client) Function: spawnmenu.GetTools\n\nGets a table of tools on the client."
  },
  "spawnmenu.PopulateFromEngineTextFiles": {
    "prefix": "spawnmenu.PopulateFromEngineTextFiles",
    "body": "spawnmenu.PopulateFromEngineTextFiles()$0",
    "description": "(Client) Function: spawnmenu.PopulateFromEngineTextFiles\n\n[Internal] "
  },
  "spawnmenu.PopulateFromTextFiles": {
    "prefix": "spawnmenu.PopulateFromTextFiles",
    "body": "spawnmenu.PopulateFromTextFiles(${1:function callback})$0",
    "description": "(Client) Function: spawnmenu.PopulateFromTextFiles\n\nLoads spawnlists from text files."
  },
  "spawnmenu.SaveToTextFiles": {
    "prefix": "spawnmenu.SaveToTextFiles",
    "body": "spawnmenu.SaveToTextFiles(${1:table spawnlists})$0",
    "description": "(Client) Function: spawnmenu.SaveToTextFiles\n\n[Internal] "
  },
  "spawnmenu.SetActiveControlPanel": {
    "prefix": "spawnmenu.SetActiveControlPanel",
    "body": "spawnmenu.SetActiveControlPanel(${1:Panel pnl})$0",
    "description": "(Client) Function: spawnmenu.SetActiveControlPanel\n\nSets currently active control panel to be returned by spawnmenu.ActiveControlPanel."
  },
  "spawnmenu.SwitchToolTab": {
    "prefix": "spawnmenu.SwitchToolTab",
    "body": "spawnmenu.SwitchToolTab(${1:number id})$0",
    "description": "(Client) Function: spawnmenu.SwitchToolTab\n\n[Deprecated] "
  },
  "spawnmenu": [],
  "sql.Begin": {
    "prefix": "sql.Begin",
    "body": "sql.Begin()$0",
    "description": "(All) Function: sql.Begin\n\nTells the engine a set of queries is coming. Will wait until sql.Commit is called to run them."
  },
  "sql.Commit": {
    "prefix": "sql.Commit",
    "body": "sql.Commit()$0",
    "description": "(All) Function: sql.Commit\n\nTells the engine to execute a series of queries queued for execution, must be preceded by sql.Begin"
  },
  "sql.LastError": {
    "prefix": "sql.LastError",
    "body": "sql.LastError()$0",
    "description": "(All) Function: sql.LastError\n\nReturns the last error from a SQLite query."
  },
  "sql.Query": {
    "prefix": "sql.Query",
    "body": "sql.Query(${1:string query})$0",
    "description": "(All) Function: sql.Query\n\nPerforms a query on the local SQLite database, returns a table as result set, nil if result is empty and false on error."
  },
  "sql.QueryRow": {
    "prefix": "sql.QueryRow",
    "body": "sql.QueryRow(${1:string query}, ${2:number row=1})$0",
    "description": "(All) Function: sql.QueryRow\n\nPerforms the query like sql.Query, but returns the first row found."
  },
  "sql.QueryValue": {
    "prefix": "sql.QueryValue",
    "body": "sql.QueryValue(${1:string query})$0",
    "description": "(All) Function: sql.QueryValue\n\nPerforms the query like sql.Query, but returns the first value found."
  },
  "sql.SQLStr": {
    "prefix": "sql.SQLStr",
    "body": "sql.SQLStr(${1:string string}, ${2:boolean bNoQuotes=false})$0",
    "description": "(All) Function: sql.SQLStr\n\nEscapes dangerous characters and symbols from user input used in an SQLite SQL Query."
  },
  "sql.TableExists": {
    "prefix": "sql.TableExists",
    "body": "sql.TableExists(${1:string tableName})$0",
    "description": "(All) Function: sql.TableExists\n\nReturns if the table with the specified name exists."
  },
  "sql": [],
  "steamworks.ApplyAddons": {
    "prefix": "steamworks.ApplyAddons",
    "body": "steamworks.ApplyAddons()$0",
    "description": "(Menu) Function: steamworks.ApplyAddons\n\nRefreshes clients addons."
  },
  "steamworks.Download": {
    "prefix": "steamworks.Download",
    "body": "steamworks.Download(${1:string workshopPreviewID}, ${2:boolean uncompress}, ${3:function resultCallback})$0",
    "description": "(Client and Menu) Function: steamworks.Download\n\nDownloads a file from the supplied addon and saves it as a .cache file in garrysmod/cache folder."
  },
  "steamworks.FileInfo": {
    "prefix": "steamworks.FileInfo",
    "body": "steamworks.FileInfo(${1:string workshopItemID}, ${2:function resultCallback})$0",
    "description": "(Client and Menu) Function: steamworks.FileInfo\n\nRetrieves info about supplied Steam Workshop addon."
  },
  "steamworks.GetList": {
    "prefix": "steamworks.GetList",
    "body": "steamworks.GetList(${1:string type}, ${2:table tags}, ${3:number offset}, ${4:number numRetrieve}, ${5:number days}, ${6:string userID}, ${7:function resultCallback})$0",
    "description": "(Client and Menu) Function: steamworks.GetList\n\nRetrieves a customized list of Steam Workshop addons."
  },
  "steamworks.GetPlayerName": {
    "prefix": "steamworks.GetPlayerName",
    "body": "steamworks.GetPlayerName(${1:string steamID64})$0",
    "description": "(Client and Menu) Function: steamworks.GetPlayerName\n\n[Deprecated] .You should use the callback of steamworks.RequestPlayerInfo instead."
  },
  "steamworks.IsSubscribed": {
    "prefix": "steamworks.IsSubscribed",
    "body": "steamworks.IsSubscribed(${1:string workshopItemID})$0",
    "description": "(Client and Menu) Function: steamworks.IsSubscribed\n\nReturns whenever the client is subscribed to the specified Steam Workshop item."
  },
  "steamworks.OpenWorkshop": {
    "prefix": "steamworks.OpenWorkshop",
    "body": "steamworks.OpenWorkshop()$0",
    "description": "(Client and Menu) Function: steamworks.OpenWorkshop\n\nOpens the workshop website in the steam overlay browser."
  },
  "steamworks.Publish": {
    "prefix": "steamworks.Publish",
    "body": "steamworks.Publish(${1:table tags}, ${2:string filename}, ${3:string image}, ${4:string name}, ${5:string desc})$0",
    "description": "(Menu) Function: steamworks.Publish\n\n[Internal] "
  },
  "steamworks.RequestPlayerInfo": {
    "prefix": "steamworks.RequestPlayerInfo",
    "body": "steamworks.RequestPlayerInfo(${1:string steamID64}, ${2:function callback})$0",
    "description": "(Client and Menu) Function: steamworks.RequestPlayerInfo\n\nRequests information of the player with SteamID64 for later use with steamworks.GetPlayerName."
  },
  "steamworks.SetFileCompleted": {
    "prefix": "steamworks.SetFileCompleted",
    "body": "steamworks.SetFileCompleted(${1:string workshopid})$0",
    "description": "(Menu) Function: steamworks.SetFileCompleted\n\n"
  },
  "steamworks.SetFilePlayed": {
    "prefix": "steamworks.SetFilePlayed",
    "body": "steamworks.SetFilePlayed(${1:string workshopid})$0",
    "description": "(Menu) Function: steamworks.SetFilePlayed\n\nSets whether you have played this addon or not. This will be shown to the user in the Steam Workshop itself:"
  },
  "steamworks.SetShouldMountAddon": {
    "prefix": "steamworks.SetShouldMountAddon",
    "body": "steamworks.SetShouldMountAddon(${1:string workshopItemID}, ${2:boolean shouldMount})$0",
    "description": "(Menu) Function: steamworks.SetShouldMountAddon\n\nSets if an addon should be enabled or disabled. Call steamworks.ApplyAddons afterwards to update."
  },
  "steamworks.ShouldMountAddon": {
    "prefix": "steamworks.ShouldMountAddon",
    "body": "steamworks.ShouldMountAddon(${1:string workshopItemID})$0",
    "description": "(Client and Menu) Function: steamworks.ShouldMountAddon\n\nReturns whenever the specified Steam Workshop addon will be mounted or not."
  },
  "steamworks.Subscribe": {
    "prefix": "steamworks.Subscribe",
    "body": "steamworks.Subscribe(${1:string workshopItemID})$0",
    "description": "(Menu) Function: steamworks.Subscribe\n\n[Internal] "
  },
  "steamworks.Unsubscribe": {
    "prefix": "steamworks.Unsubscribe",
    "body": "steamworks.Unsubscribe(${1:string workshopItemID})$0",
    "description": "(Menu) Function: steamworks.Unsubscribe\n\n[Internal]  Unsubscribes to the specified workshop addon. Call steamworks.ApplyAddons afterwards to update."
  },
  "steamworks.ViewFile": {
    "prefix": "steamworks.ViewFile",
    "body": "steamworks.ViewFile(${1:string workshopItemID})$0",
    "description": "(Client and Menu) Function: steamworks.ViewFile\n\nOpens the workshop website for specified Steam Workshop item in the Steam overlay browser."
  },
  "steamworks.Vote": {
    "prefix": "steamworks.Vote",
    "body": "steamworks.Vote(${1:string workshopItemID}, ${2:boolean upOrDown})$0",
    "description": "(Menu) Function: steamworks.Vote\n\n[Internal]  Makes the user vote for the specified addon"
  },
  "steamworks.VoteInfo": {
    "prefix": "steamworks.VoteInfo",
    "body": "steamworks.VoteInfo(${1:string workshopItemID}, ${2:function resultCallback})$0",
    "description": "(Client and Menu) Function: steamworks.VoteInfo\n\nRetrieves vote info of supplied addon."
  },
  "steamworks": [],
  "string.byte": {
    "prefix": "string.byte",
    "body": "string.byte(${1:string string}, ${2:number startPos=1}, ${3:number endPos=startPos})$0",
    "description": "(All) Function: string.byte\n\nReturns the given string's characters in their numeric ASCII representation."
  },
  "string.char": {
    "prefix": "string.char",
    "body": "string.char(${1:vararg bytes})$0",
    "description": "(All) Function: string.char\n\nTakes the given numerical bytes and converts them to a string."
  },
  "string.Comma": {
    "prefix": "string.Comma",
    "body": "string.Comma(${1:number InputNumber})$0",
    "description": "(All) Function: string.Comma\n\nInserts commas for every third digit."
  },
  "string.dump": {
    "prefix": "string.dump",
    "body": "string.dump(${1:function func}, ${2:boolean stripDebugInfo=false})$0",
    "description": "(All) Function: string.dump\n\nReturns the binary bytecode of the given function."
  },
  "string.EndsWith": {
    "prefix": "string.EndsWith",
    "body": "string.EndsWith(${1:string str}, ${2:string end})$0",
    "description": "(All) Function: string.EndsWith\n\nReturns whether or not the second passed string matches the end of the first."
  },
  "string.Explode": {
    "prefix": "string.Explode",
    "body": "string.Explode(${1:string separator}, ${2:string str}, ${3:boolean use_patterns})$0",
    "description": "(All) Function: string.Explode\n\nSplits a string up wherever it finds the given separator."
  },
  "string.find": {
    "prefix": "string.find",
    "body": "string.find(${1:string haystack}, ${2:string needle}, ${3:number startPos=1}, ${4:boolean noPatterns=false})$0",
    "description": "(All) Function: string.find\n\nAttempts to find the specified substring in a string, uses [[Patterns]] by default."
  },
  "string.format": {
    "prefix": "string.format",
    "body": "string.format(${1:string format}, ${2:vararg formatParameters})$0",
    "description": "(All) Function: string.format\n\nFormats the specified values into the string given."
  },
  "string.FormattedTime": {
    "prefix": "string.FormattedTime",
    "body": "string.FormattedTime(${1:number float}, ${2:string format=nil})$0",
    "description": "(All) Function: string.FormattedTime\n\nReturns the time as a formatted string or as a table if no format is given."
  },
  "string.FromColor": {
    "prefix": "string.FromColor",
    "body": "string.FromColor(${1:table color})$0",
    "description": "(All) Function: string.FromColor\n\nCreates a string from a Color variable."
  },
  "string.GetChar": {
    "prefix": "string.GetChar",
    "body": "string.GetChar(${1:string str}, ${2:number index})$0",
    "description": "(All) Function: string.GetChar\n\n[Deprecated] .Use either string.sub(str, index, index) or str[index]. Returns char value from the specified index in the supplied string."
  },
  "string.GetExtensionFromFilename": {
    "prefix": "string.GetExtensionFromFilename",
    "body": "string.GetExtensionFromFilename(${1:string file})$0",
    "description": "(All) Function: string.GetExtensionFromFilename\n\nReturns extension of the file."
  },
  "string.GetFileFromFilename": {
    "prefix": "string.GetFileFromFilename",
    "body": "string.GetFileFromFilename(${1:string pathString})$0",
    "description": "(All) Function: string.GetFileFromFilename\n\nReturns file name and extension."
  },
  "string.GetPathFromFilename": {
    "prefix": "string.GetPathFromFilename",
    "body": "string.GetPathFromFilename(${1:string Inputstring})$0",
    "description": "(All) Function: string.GetPathFromFilename\n\nReturns the path only from a file's path."
  },
  "string.gfind": {
    "prefix": "string.gfind",
    "body": "string.gfind(${1:string data}, ${2:string pattern})$0",
    "description": "(All) Function: string.gfind\n\n[Deprecated] .This function is removed in Lua versions later than what GMod is currently using. Use string.gmatch instead.Returns an iterator function that is called for every complete match of the pattern, all sub matches will be passed as to the loop."
  },
  "string.gmatch": {
    "prefix": "string.gmatch",
    "body": "string.gmatch(${1:string data}, ${2:string pattern})$0",
    "description": "(All) Function: string.gmatch\n\nUsing [[Patterns]], returns an iterator which will return either one value if no capture groups are defined, or any capture group matches."
  },
  "string.gsub": {
    "prefix": "string.gsub",
    "body": "string.gsub(${1:string string}, ${2:string pattern}, ${3:string replacement}, ${4:number maxReplaces=nil})$0",
    "description": "(All) Function: string.gsub\n\nThis functions main purpose is to replace certain character sequences in a string using [[Patterns]]."
  },
  "string.Implode": {
    "prefix": "string.Implode",
    "body": "string.Implode(${1:string separator=\"\"}, ${2:table pieces})$0",
    "description": "(All) Function: string.Implode\n\nJoins the values of a table together to form a string."
  },
  "string.JavascriptSafe": {
    "prefix": "string.JavascriptSafe",
    "body": "string.JavascriptSafe(${1:string str})$0",
    "description": "(All) Function: string.JavascriptSafe\n\nEscapes special characters for JavaScript in a string, making the string safe for inclusion in to JavaScript strings."
  },
  "string.Left": {
    "prefix": "string.Left",
    "body": "string.Left(${1:string str}, ${2:number num})$0",
    "description": "(All) Function: string.Left\n\nReturns everything left of supplied place of that string."
  },
  "string.len": {
    "prefix": "string.len",
    "body": "string.len(${1:string str})$0",
    "description": "(All) Function: string.len\n\nCounts the number of characters in the string (length). This is equivalent to using the length operator (#)."
  },
  "string.lower": {
    "prefix": "string.lower",
    "body": "string.lower(${1:string str})$0",
    "description": "(All) Function: string.lower\n\nChanges any upper-case letters in a string to lower-case letters."
  },
  "string.match": {
    "prefix": "string.match",
    "body": "string.match(${1:string string}, ${2:string pattern}, ${3:number startPosition=1})$0",
    "description": "(All) Function: string.match\n\nFinds a [[Patterns.Pattern]] in a string."
  },
  "string.NiceSize": {
    "prefix": "string.NiceSize",
    "body": "string.NiceSize(${1:number bytes})$0",
    "description": "(All) Function: string.NiceSize\n\nConverts a digital filesize to human-readable text."
  },
  "string.NiceTime": {
    "prefix": "string.NiceTime",
    "body": "string.NiceTime(${1:number num})$0",
    "description": "(All) Function: string.NiceTime\n\nFormats the supplied number (in seconds) to the highest possible time unit."
  },
  "string.PatternSafe": {
    "prefix": "string.PatternSafe",
    "body": "string.PatternSafe(${1:string str})$0",
    "description": "(All) Function: string.PatternSafe\n\nEscapes all special characters within a string, making the string safe for inclusion in a Lua pattern."
  },
  "string.rep": {
    "prefix": "string.rep",
    "body": "string.rep(${1:string str}, ${2:number repetitions}, ${3:string separator=\"\"})$0",
    "description": "(All) Function: string.rep\n\nRepeats a string by the provided number, with an optional separator."
  },
  "string.Replace": {
    "prefix": "string.Replace",
    "body": "string.Replace(${1:string str}, ${2:string find}, ${3:string replace})$0",
    "description": "(All) Function: string.Replace\n\nReplaces all occurrences of the supplied second string."
  },
  "string.reverse": {
    "prefix": "string.reverse",
    "body": "string.reverse(${1:string str})$0",
    "description": "(All) Function: string.reverse\n\nReverses a string."
  },
  "string.Right": {
    "prefix": "string.Right",
    "body": "string.Right(${1:string str}, ${2:number num})$0",
    "description": "(All) Function: string.Right\n\nReturns the last n-th characters of the string."
  },
  "string.SetChar": {
    "prefix": "string.SetChar",
    "body": "string.SetChar(${1:string InputString}, ${2:number Index}, ${3:string ReplacementChar})$0",
    "description": "(All) Function: string.SetChar\n\nSets the character at the specific index of the string."
  },
  "string.Split": {
    "prefix": "string.Split",
    "body": "string.Split(${1:string Inputstring}, ${2:string Separator})$0",
    "description": "(All) Function: string.Split\n\nSplits the string into a table of strings, separated by the second argument."
  },
  "string.StartWith": {
    "prefix": "string.StartWith",
    "body": "string.StartWith(${1:string inputStr}, ${2:string start})$0",
    "description": "(All) Function: string.StartWith\n\nReturns whether or not the first string starts with the second."
  },
  "string.StripExtension": {
    "prefix": "string.StripExtension",
    "body": "string.StripExtension(${1:string Inputstring})$0",
    "description": "(All) Function: string.StripExtension\n\nRemoves the extension of a path."
  },
  "string.sub": {
    "prefix": "string.sub",
    "body": "string.sub(${1:string string}, ${2:number StartPos}, ${3:number EndPos=nil})$0",
    "description": "(All) Function: string.sub\n\nReturns a sub-string, starting from the character at position ''StartPos'' of the string (inclusive), and optionally ending at the character at position ''EndPos'' of the string (also inclusive). If EndPos is not given, the rest of the string is returned."
  },
  "string.ToColor": {
    "prefix": "string.ToColor",
    "body": "string.ToColor(${1:string Inputstring})$0",
    "description": "(All) Function: string.ToColor\n\nFetches a Color type from a string."
  },
  "string.ToMinutesSeconds": {
    "prefix": "string.ToMinutesSeconds",
    "body": "string.ToMinutesSeconds(${1:number time})$0",
    "description": "(All) Function: string.ToMinutesSeconds\n\nReturns given time in \"MM:SS\" format."
  },
  "string.ToMinutesSecondsMilliseconds": {
    "prefix": "string.ToMinutesSecondsMilliseconds",
    "body": "string.ToMinutesSecondsMilliseconds(${1:number time})$0",
    "description": "(All) Function: string.ToMinutesSecondsMilliseconds\n\nReturns given time in \"MM:SS:MS\" format."
  },
  "string.ToTable": {
    "prefix": "string.ToTable",
    "body": "string.ToTable(${1:string string})$0",
    "description": "(All) Function: string.ToTable\n\nSplits the string into characters and creates a sequential table."
  },
  "string.Trim": {
    "prefix": "string.Trim",
    "body": "string.Trim(${1:string Inputstring}, ${2:string Char=\" \"})$0",
    "description": "(All) Function: string.Trim\n\nRemoves leading and trailing matches of a string."
  },
  "string.TrimLeft": {
    "prefix": "string.TrimLeft",
    "body": "string.TrimLeft(${1:string str}, ${2:string char=\" \"})$0",
    "description": "(All) Function: string.TrimLeft\n\nRemoves leading spaces/characters from a string."
  },
  "string.TrimRight": {
    "prefix": "string.TrimRight",
    "body": "string.TrimRight(${1:string str}, ${2:string char=\" \"})$0",
    "description": "(All) Function: string.TrimRight\n\nRemoves trailing spaces/passed character from a string."
  },
  "string.upper": {
    "prefix": "string.upper",
    "body": "string.upper(${1:string str})$0",
    "description": "(All) Function: string.upper\n\nChanges any lower-case letters in a string to upper-case letters."
  },
  "string": [],
  "surface.CreateFont": {
    "prefix": "surface.CreateFont",
    "body": "surface.CreateFont(${1:string fontName}, ${2:table fontData})$0",
    "description": "(Client and Menu) Function: surface.CreateFont\n\nCreates a new font."
  },
  "surface.DisableClipping": {
    "prefix": "surface.DisableClipping",
    "body": "surface.DisableClipping(${1:boolean disable})$0",
    "description": "(Client and Menu) Function: surface.DisableClipping\n\nEnables or disables the clipping used by the VGUI that limits the drawing operations to a panels bounds."
  },
  "surface.DrawCircle": {
    "prefix": "surface.DrawCircle",
    "body": "surface.DrawCircle(${1:number originX}, ${2:number originY}, ${3:number radius}, ${4:number r}, ${5:number g}, ${6:number b}, ${7:number a=255})$0",
    "description": "(Client and Menu) Function: surface.DrawCircle\n\nDraws a hollow circle, made of dots. For a filled circle, see examples for surface.DrawPoly."
  },
  "surface.DrawLine": {
    "prefix": "surface.DrawLine",
    "body": "surface.DrawLine(${1:number startX}, ${2:number startY}, ${3:number endX}, ${4:number endY})$0",
    "description": "(Client and Menu) Function: surface.DrawLine\n\nDraws a line from one point to another."
  },
  "surface.DrawOutlinedRect": {
    "prefix": "surface.DrawOutlinedRect",
    "body": "surface.DrawOutlinedRect(${1:number x}, ${2:number y}, ${3:number w}, ${4:number h})$0",
    "description": "(Client and Menu) Function: surface.DrawOutlinedRect\n\nDraws a hollow box with a border width of 1 px."
  },
  "surface.DrawPoly": {
    "prefix": "surface.DrawPoly",
    "body": "surface.DrawPoly(${1:table vertices})$0",
    "description": "(Client and Menu) Function: surface.DrawPoly\n\nDraws a textured polygon (secretly a triangle fan) with a maximum of 256 vertices."
  },
  "surface.DrawRect": {
    "prefix": "surface.DrawRect",
    "body": "surface.DrawRect(${1:number x}, ${2:number y}, ${3:number width}, ${4:number height})$0",
    "description": "(Client and Menu) Function: surface.DrawRect\n\nDraws a solid rectangle on the screen."
  },
  "surface.DrawText": {
    "prefix": "surface.DrawText",
    "body": "surface.DrawText(${1:string text})$0",
    "description": "(Client and Menu) Function: surface.DrawText\n\nDraw the specified text on the screen, using the previously set position, font and color."
  },
  "surface.DrawTexturedRect": {
    "prefix": "surface.DrawTexturedRect",
    "body": "surface.DrawTexturedRect(${1:number x}, ${2:number y}, ${3:number width}, ${4:number height})$0",
    "description": "(Client and Menu) Function: surface.DrawTexturedRect\n\nDraw a textured rectangle with the given position and dimensions on the screen, using the current active texture set with surface.SetMaterial. It is also affected by surface.SetDrawColor."
  },
  "surface.DrawTexturedRectRotated": {
    "prefix": "surface.DrawTexturedRectRotated",
    "body": "surface.DrawTexturedRectRotated(${1:number x}, ${2:number y}, ${3:number width}, ${4:number height}, ${5:number rotation})$0",
    "description": "(Client and Menu) Function: surface.DrawTexturedRectRotated\n\nDraw a textured rotated rectangle with the given position and dimensions and angle on the screen, using the current active texture."
  },
  "surface.DrawTexturedRectUV": {
    "prefix": "surface.DrawTexturedRectUV",
    "body": "surface.DrawTexturedRectUV(${1:number x}, ${2:number y}, ${3:number width}, ${4:number height}, ${5:number startU}, ${6:number startV}, ${7:number endU}, ${8:number endV})$0",
    "description": "() Function: surface.DrawTexturedRectUV\n\nDraws a textured rectangle with a repeated or partial texture."
  },
  "surface.GetHUDTexture": {
    "prefix": "surface.GetHUDTexture",
    "body": "surface.GetHUDTexture(${1:string name})$0",
    "description": "(Client) Function: surface.GetHUDTexture\n\nGets the HUD texture with the specified name."
  },
  "surface.GetTextSize": {
    "prefix": "surface.GetTextSize",
    "body": "surface.GetTextSize(${1:string text})$0",
    "description": "(Client and Menu) Function: surface.GetTextSize\n\nReturns the width and height (in pixels) of the given text, but only if the font has been set with surface.SetFont."
  },
  "surface.GetTextureID": {
    "prefix": "surface.GetTextureID",
    "body": "surface.GetTextureID(${1:string name/path})$0",
    "description": "(Client and Menu) Function: surface.GetTextureID\n\nReturns the texture id of the material with the given name/path."
  },
  "surface.GetTextureSize": {
    "prefix": "surface.GetTextureSize",
    "body": "surface.GetTextureSize(${1:number textureID})$0",
    "description": "(Client and Menu) Function: surface.GetTextureSize\n\nReturns the size of the texture with the associated texture ID."
  },
  "surface.PlaySound": {
    "prefix": "surface.PlaySound",
    "body": "surface.PlaySound(${1:string soundfile})$0",
    "description": "(Client and Menu) Function: surface.PlaySound\n\nPlay a sound file directly on the client (such as UI sounds, etc)."
  },
  "surface.ScreenHeight": {
    "prefix": "surface.ScreenHeight",
    "body": "surface.ScreenHeight()$0",
    "description": "(Client and Menu) Function: surface.ScreenHeight\n\n[Deprecated] .You should use _G.ScrH instead."
  },
  "surface.ScreenWidth": {
    "prefix": "surface.ScreenWidth",
    "body": "surface.ScreenWidth()$0",
    "description": "(Client and Menu) Function: surface.ScreenWidth\n\n[Deprecated] .You should use _G.ScrW instead."
  },
  "surface.SetAlphaMultiplier": {
    "prefix": "surface.SetAlphaMultiplier",
    "body": "surface.SetAlphaMultiplier(${1:number multiplier})$0",
    "description": "(Client and Menu) Function: surface.SetAlphaMultiplier\n\nSets a multiplier that will influence all upcoming drawing operations."
  },
  "surface.SetDrawColor": {
    "prefix": "surface.SetDrawColor",
    "body": "surface.SetDrawColor(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a=255})$0",
    "description": "(Client and Menu) Function: surface.SetDrawColor\n\nSet the color of any future shapes to be drawn, can be set by either using r, g, b, a as separate values or by a Color. Using a color structure is not recommended to be created procedurally."
  },
  "surface.SetFont": {
    "prefix": "surface.SetFont",
    "body": "surface.SetFont(${1:string fontName})$0",
    "description": "(Client and Menu) Function: surface.SetFont\n\nSet the current font to be used for text operations later."
  },
  "surface.SetMaterial": {
    "prefix": "surface.SetMaterial",
    "body": "surface.SetMaterial(${1:IMaterial material})$0",
    "description": "(Client and Menu) Function: surface.SetMaterial\n\nSets the material to be used in all upcoming draw operations using the surface library."
  },
  "surface.SetTextColor": {
    "prefix": "surface.SetTextColor",
    "body": "surface.SetTextColor(${1:number r}, ${2:number g}, ${3:number b}, ${4:number a=255})$0",
    "description": "(Client and Menu) Function: surface.SetTextColor\n\nSet the color of any future text to be drawn, can be set by either using r, g, b, a as separate values or by a Color. Using a color structure is not recommended to be created procedurally."
  },
  "surface.SetTextPos": {
    "prefix": "surface.SetTextPos",
    "body": "surface.SetTextPos(${1:number x}, ${2:number y})$0",
    "description": "(Client and Menu) Function: surface.SetTextPos\n\nSet the position to draw any future text."
  },
  "surface.SetTexture": {
    "prefix": "surface.SetTexture",
    "body": "surface.SetTexture(${1:number textureID})$0",
    "description": "(Client and Menu) Function: surface.SetTexture\n\nSets the texture to be used in all upcoming draw operations using the surface library."
  },
  "surface": [],
  "system.AppTime": {
    "prefix": "system.AppTime",
    "body": "system.AppTime()$0",
    "description": "(All) Function: system.AppTime\n\nReturns the total uptime of the current application as reported by Steam."
  },
  "system.BatteryPower": {
    "prefix": "system.BatteryPower",
    "body": "system.BatteryPower()$0",
    "description": "(All) Function: system.BatteryPower\n\nReturns the current battery power."
  },
  "system.FlashWindow": {
    "prefix": "system.FlashWindow",
    "body": "system.FlashWindow()$0",
    "description": "(Client and Menu) Function: system.FlashWindow\n\nFlashes the window. Currently works only on Windows."
  },
  "system.GetCountry": {
    "prefix": "system.GetCountry",
    "body": "system.GetCountry()$0",
    "description": "(All) Function: system.GetCountry\n\nReturns the country code of this computer, determined by the localisation settings of the OS."
  },
  "system.HasFocus": {
    "prefix": "system.HasFocus",
    "body": "system.HasFocus()$0",
    "description": "(All) Function: system.HasFocus\n\nReturns whether or not the game window has focus."
  },
  "system.IsLinux": {
    "prefix": "system.IsLinux",
    "body": "system.IsLinux()$0",
    "description": "(All) Function: system.IsLinux\n\nReturns whether the current OS is Linux."
  },
  "system.IsOSX": {
    "prefix": "system.IsOSX",
    "body": "system.IsOSX()$0",
    "description": "(All) Function: system.IsOSX\n\nReturns whether the current OS is OSX."
  },
  "system.IsWindowed": {
    "prefix": "system.IsWindowed",
    "body": "system.IsWindowed()$0",
    "description": "(Client and Menu) Function: system.IsWindowed\n\nReturns whether the game is being run in a window or in fullscreen (you can change this by opening the menu, clicking 'Options', then clicking the 'Video' tab, and changing the Display Mode using the dropdown menu):"
  },
  "system.IsWindows": {
    "prefix": "system.IsWindows",
    "body": "system.IsWindows()$0",
    "description": "(All) Function: system.IsWindows\n\nReturns whether the current OS is Windows."
  },
  "system.SteamTime": {
    "prefix": "system.SteamTime",
    "body": "system.SteamTime()$0",
    "description": "(All) Function: system.SteamTime\n\nReturns the synchronized Steam time. This is the number of seconds since the [http://en.wikipedia.org/wiki/Unix_time Unix epoch]."
  },
  "system.UpTime": {
    "prefix": "system.UpTime",
    "body": "system.UpTime()$0",
    "description": "(All) Function: system.UpTime\n\nReturns the amount of seconds since the Steam user last moved their mouse."
  },
  "system": [],
  "table.Add": {
    "prefix": "table.Add",
    "body": "table.Add(${1:table target}, ${2:table source})$0",
    "description": "(All) Function: table.Add\n\nAdds the contents from one table into another."
  },
  "table.ClearKeys": {
    "prefix": "table.ClearKeys",
    "body": "table.ClearKeys(${1:table table}, ${2:boolean saveKeys=false})$0",
    "description": "(All) Function: table.ClearKeys\n\nChanges all keys to sequential integers. This creates a new table object and does not affect the original."
  },
  "table.CollapseKeyValue": {
    "prefix": "table.CollapseKeyValue",
    "body": "table.CollapseKeyValue(${1:table input})$0",
    "description": "(All) Function: table.CollapseKeyValue\n\nCollapses a table with keyvalue structure"
  },
  "table.concat": {
    "prefix": "table.concat",
    "body": "table.concat(${1:table tbl}, ${2:string concatenator=\"\"}, ${3:number startPos=1}, ${4:number endPos=#tbl})$0",
    "description": "(All) Function: table.concat\n\nConcatenates the contents of a table to a string."
  },
  "table.Copy": {
    "prefix": "table.Copy",
    "body": "table.Copy(${1:table originalTable})$0",
    "description": "(All) Function: table.Copy\n\nCreates a deep copy and returns that copy."
  },
  "table.CopyFromTo": {
    "prefix": "table.CopyFromTo",
    "body": "table.CopyFromTo(${1:table source}, ${2:table target})$0",
    "description": "(All) Function: table.CopyFromTo\n\nEmpties the target table, and merges all values from the source table into it."
  },
  "table.Count": {
    "prefix": "table.Count",
    "body": "table.Count(${1:table tbl})$0",
    "description": "(All) Function: table.Count\n\nCounts the amount of keys in a table. This should only be used when a table is not numerically and sequentially indexed. For those tables, consider the length operator."
  },
  "table.DeSanitise": {
    "prefix": "table.DeSanitise",
    "body": "table.DeSanitise(${1:table tbl})$0",
    "description": "(All) Function: table.DeSanitise\n\nConverts a table that has been sanitised with table.Sanitise back to its original form"
  },
  "table.Empty": {
    "prefix": "table.Empty",
    "body": "table.Empty(${1:table tbl})$0",
    "description": "(All) Function: table.Empty\n\nRemoves all values from a table."
  },
  "table.FindNext": {
    "prefix": "table.FindNext",
    "body": "table.FindNext(${1:table tbl}, ${2:any value})$0",
    "description": "(All) Function: table.FindNext\n\n[Deprecated] .Instead, iterate the table using ipairs or increment from the previous index. Non-numerically indexed tables are not ordered."
  },
  "table.FindPrev": {
    "prefix": "table.FindPrev",
    "body": "table.FindPrev(${1:table tbl}, ${2:any value})$0",
    "description": "(All) Function: table.FindPrev\n\n[Deprecated] .Instead, iterate your table with ipairs, storing the previous value and checking for the target. Non-numerically indexed tables are not ordered."
  },
  "table.ForceInsert": {
    "prefix": "table.ForceInsert",
    "body": "table.ForceInsert(${1:table tab={}}, ${2:any value})$0",
    "description": "(All) Function: table.ForceInsert\n\nInserts a value in to the given table even if the table is non-existent"
  },
  "table.foreach": {
    "prefix": "table.foreach",
    "body": "table.foreach(${1:table tbl}, ${2:function callback})$0",
    "description": "(All) Function: table.foreach\n\n[Deprecated] .This was deprecated in Lua 5.1 and removed in 5.2. You should use _G.pairs() instead. Iterates for each key-value pair in the table, calling the function with the key and value of the pair. If the function returns anything, the loop is broken."
  },
  "table.ForEach": {
    "prefix": "table.ForEach",
    "body": "table.ForEach(${1:table tab}, ${2:function callback})$0",
    "description": "(All) Function: table.ForEach\n\n[Deprecated] .You should use _G.pairs() instead. Iterates over a table and calls the given function for each key and value found. Unlike table.foreach, this ignores the value returned by the function."
  },
  "table.foreachi": {
    "prefix": "table.foreachi",
    "body": "table.foreachi(${1:table table}, ${2:function func})$0",
    "description": "(All) Function: table.foreachi\n\n[Deprecated] .This was deprecated in Lua 5.1 and removed in 5.2. You should use _G.ipairs() instead. Iterates for each numeric index in the table in order."
  },
  "table.GetFirstKey": {
    "prefix": "table.GetFirstKey",
    "body": "table.GetFirstKey(${1:table tab})$0",
    "description": "(All) Function: table.GetFirstKey\n\n[Deprecated] .Instead, expect the first key to be 1."
  },
  "table.GetFirstValue": {
    "prefix": "table.GetFirstValue",
    "body": "table.GetFirstValue(${1:table tab})$0",
    "description": "(All) Function: table.GetFirstValue\n\n[Deprecated] .Instead, index the table with a key of 1."
  },
  "table.GetKeys": {
    "prefix": "table.GetKeys",
    "body": "table.GetKeys(${1:table tabl})$0",
    "description": "(All) Function: table.GetKeys\n\nReturns all keys of a table."
  },
  "table.GetLastKey": {
    "prefix": "table.GetLastKey",
    "body": "table.GetLastKey(${1:table tab})$0",
    "description": "(All) Function: table.GetLastKey\n\n[Deprecated] .Instead, use the result of the length (#) operator, ensuring it is not zero. Non-numerically indexed tables are not ordered and do not have a last key."
  },
  "table.GetLastValue": {
    "prefix": "table.GetLastValue",
    "body": "table.GetLastValue(${1:table tab})$0",
    "description": "(All) Function: table.GetLastValue\n\n[Deprecated] .Instead, index the table with the result of the length (#) operator, ensuring it is not zero. Non-numerically indexed tables are not ordered and do not have a last key."
  },
  "table.getn": {
    "prefix": "table.getn",
    "body": "table.getn(${1:table tbl})$0",
    "description": "(All) Function: table.getn\n\n[Deprecated] .This function was deprecated in Lua 5.1 and is removed in 5.2. Use the length (#) operator instead. Returns the length of the table."
  },
  "table.GetWinningKey": {
    "prefix": "table.GetWinningKey",
    "body": "table.GetWinningKey(${1:table inputTable})$0",
    "description": "(All) Function: table.GetWinningKey\n\nReturns a key of the supplied table with the highest number value."
  },
  "table.HasValue": {
    "prefix": "table.HasValue",
    "body": "table.HasValue(${1:table tbl}, ${2:any value})$0",
    "description": "(All) Function: table.HasValue\n\nChecks if a table has a value."
  },
  "table.Inherit": {
    "prefix": "table.Inherit",
    "body": "table.Inherit(${1:table target}, ${2:table base})$0",
    "description": "(All) Function: table.Inherit\n\nCopies any missing data from base to target, and sets the target's ''BaseClass'' member to the base table's pointer."
  },
  "table.insert": {
    "prefix": "table.insert",
    "body": "table.insert(${1:table tbl}, ${2:number position=nil}, ${3:any value})$0",
    "description": "(All) Function: table.insert\n\nInserts a value into a table at the end of the table or at the given position."
  },
  "table.IsSequential": {
    "prefix": "table.IsSequential",
    "body": "table.IsSequential(${1:table tab})$0",
    "description": "(All) Function: table.IsSequential\n\nReturns whether or not the table's keys are sequential"
  },
  "table.KeyFromValue": {
    "prefix": "table.KeyFromValue",
    "body": "table.KeyFromValue(${1:table tab}, ${2:any value})$0",
    "description": "(All) Function: table.KeyFromValue\n\nReturns the first key found to be containing the supplied value"
  },
  "table.KeysFromValue": {
    "prefix": "table.KeysFromValue",
    "body": "table.KeysFromValue(${1:table tab}, ${2:any value})$0",
    "description": "(All) Function: table.KeysFromValue\n\nReturns a table of keys containing the supplied value"
  },
  "table.LowerKeyNames": {
    "prefix": "table.LowerKeyNames",
    "body": "table.LowerKeyNames(${1:table tbl})$0",
    "description": "(All) Function: table.LowerKeyNames\n\nReturns a copy of the input table with all string keys converted to be lowercase recursively"
  },
  "table.maxn": {
    "prefix": "table.maxn",
    "body": "table.maxn(${1:table tbl})$0",
    "description": "(All) Function: table.maxn\n\nReturns the highest numerical key."
  },
  "table.Merge": {
    "prefix": "table.Merge",
    "body": "table.Merge(${1:table destination}, ${2:table source})$0",
    "description": "(All) Function: table.Merge\n\nMerges the content of the second table with the content in the first one"
  },
  "table.Random": {
    "prefix": "table.Random",
    "body": "table.Random(${1:table haystack})$0",
    "description": "(All) Function: table.Random\n\nReturns a random value from the supplied table."
  },
  "table.remove": {
    "prefix": "table.remove",
    "body": "table.remove(${1:table tbl}, ${2:number index=#tbl})$0",
    "description": "(All) Function: table.remove\n\nRemoves a value from a table and shifts any other values down to fill the gap."
  },
  "table.RemoveByValue": {
    "prefix": "table.RemoveByValue",
    "body": "table.RemoveByValue(${1:table tbl}, ${2:any val})$0",
    "description": "(All) Function: table.RemoveByValue\n\nRemoves the first instance of a given value from the specified table with table.remove, then returns the key that the value was found at."
  },
  "table.Reverse": {
    "prefix": "table.Reverse",
    "body": "table.Reverse(${1:table tbl})$0",
    "description": "(All) Function: table.Reverse\n\nReturns a reversed copy of a sequential table. Any non-sequential and non-numeric keyvalue pairs will not be copied."
  },
  "table.Sanitise": {
    "prefix": "table.Sanitise",
    "body": "table.Sanitise(${1:table tab})$0",
    "description": "(All) Function: table.Sanitise\n\nConverts Vectors, Type.Angles and Type.booleans to be able to be converted to and from key-values. table.DeSanitise does the opposite"
  },
  "table.sort": {
    "prefix": "table.sort",
    "body": "table.sort(${1:table tbl}, ${2:function sorter})$0",
    "description": "(All) Function: table.sort\n\nSorts a table either ascending or by the given sort function."
  },
  "table.SortByKey": {
    "prefix": "table.SortByKey",
    "body": "table.SortByKey(${1:table tab}, ${2:boolean descending=false})$0",
    "description": "(All) Function: table.SortByKey\n\nReturns a list of keys sorted based on values of those keys."
  },
  "table.SortByMember": {
    "prefix": "table.SortByMember",
    "body": "table.SortByMember(${1:table tab}, ${2:any memberKey}, ${3:boolean ascending=false})$0",
    "description": "(All) Function: table.SortByMember\n\nSorts a table by a named member"
  },
  "table.SortDesc": {
    "prefix": "table.SortDesc",
    "body": "table.SortDesc(${1:table tbl})$0",
    "description": "(All) Function: table.SortDesc\n\nSorts a table in reverse order from table.sort"
  },
  "table.ToString": {
    "prefix": "table.ToString",
    "body": "table.ToString(${1:table tbl}, ${2:string displayName}, ${3:boolean niceFormatting})$0",
    "description": "(All) Function: table.ToString\n\nConverts a table into a string"
  },
  "table": [],
  "team.AddScore": {
    "prefix": "team.AddScore",
    "body": "team.AddScore(${1:number index}, ${2:number increment})$0",
    "description": "(Shared) Function: team.AddScore\n\nIncreases the score of the given team"
  },
  "team.BestAutoJoinTeam": {
    "prefix": "team.BestAutoJoinTeam",
    "body": "team.BestAutoJoinTeam()$0",
    "description": "(Shared) Function: team.BestAutoJoinTeam\n\nReturns the team index of the team with the least players. Falls back to TEAM_UNASSIGNED"
  },
  "team.GetAllTeams": {
    "prefix": "team.GetAllTeams",
    "body": "team.GetAllTeams()$0",
    "description": "(Shared) Function: team.GetAllTeams\n\nReturns a table consisting of information on every defined team"
  },
  "team.GetClass": {
    "prefix": "team.GetClass",
    "body": "team.GetClass(${1:number index})$0",
    "description": "(Shared) Function: team.GetClass\n\nReturns the selectable classes for the given team. This can be added to with [[team/SetClass]]"
  },
  "team.GetColor": {
    "prefix": "team.GetColor",
    "body": "team.GetColor(${1:number teamIndex})$0",
    "description": "(Shared) Function: team.GetColor\n\nReturns the team's color."
  },
  "team.GetName": {
    "prefix": "team.GetName",
    "body": "team.GetName(${1:number teamIndex})$0",
    "description": "(Shared) Function: team.GetName\n\nReturns the name of the team."
  },
  "team.GetPlayers": {
    "prefix": "team.GetPlayers",
    "body": "team.GetPlayers(${1:number teamIndex})$0",
    "description": "(Shared) Function: team.GetPlayers\n\nReturns a table with all player of the specified team."
  },
  "team.GetScore": {
    "prefix": "team.GetScore",
    "body": "team.GetScore(${1:number teamIndex})$0",
    "description": "(Shared) Function: team.GetScore\n\nReturns the score of the team."
  },
  "team.GetSpawnPoint": {
    "prefix": "team.GetSpawnPoint",
    "body": "team.GetSpawnPoint(${1:number index})$0",
    "description": "(Shared) Function: team.GetSpawnPoint\n\nReturns a table of valid spawnpoint classes the team can use. These are set with team.SetSpawnPoint."
  },
  "team.GetSpawnPoints": {
    "prefix": "team.GetSpawnPoints",
    "body": "team.GetSpawnPoints(${1:number index})$0",
    "description": "(Shared) Function: team.GetSpawnPoints\n\nReturns a table of valid spawnpoint entities the team can use. These are set with  team.SetSpawnPoint."
  },
  "team.Joinable": {
    "prefix": "team.Joinable",
    "body": "team.Joinable(${1:number index})$0",
    "description": "(Shared) Function: team.Joinable\n\nReturns if a team is joinable or not. This is set in team.SetUp."
  },
  "team.NumPlayers": {
    "prefix": "team.NumPlayers",
    "body": "team.NumPlayers(${1:number teamIndex})$0",
    "description": "(Shared) Function: team.NumPlayers\n\nReturns the amount of players in a team."
  },
  "team.SetClass": {
    "prefix": "team.SetClass",
    "body": "team.SetClass(${1:number index}, ${2:any classes})$0",
    "description": "(Shared) Function: team.SetClass\n\nSets valid classes for use by a team. Classes can be created using player_manager.RegisterClass"
  },
  "team.SetColor": {
    "prefix": "team.SetColor",
    "body": "team.SetColor(${1:number teamIndex}, ${2:table color})$0",
    "description": "(Shared) Function: team.SetColor\n\nSets the team's color."
  },
  "team.SetScore": {
    "prefix": "team.SetScore",
    "body": "team.SetScore(${1:number index}, ${2:number score})$0",
    "description": "(Shared) Function: team.SetScore\n\nSets the score of the given team"
  },
  "team.SetSpawnPoint": {
    "prefix": "team.SetSpawnPoint",
    "body": "team.SetSpawnPoint(${1:number index}, ${2:any classes})$0",
    "description": "(Shared) Function: team.SetSpawnPoint\n\nSets valid spawnpoint classes for use by a team."
  },
  "team.SetUp": {
    "prefix": "team.SetUp",
    "body": "team.SetUp(${1:number teamIndex}, ${2:string teamName}, ${3:table teamColor}, ${4:boolean isJoinable=true})$0",
    "description": "(Shared) Function: team.SetUp\n\nCreates a new team."
  },
  "team.TotalDeaths": {
    "prefix": "team.TotalDeaths",
    "body": "team.TotalDeaths(${1:number teamIndex})$0",
    "description": "(Shared) Function: team.TotalDeaths\n\nReturns the sum of deaths of all players of the team."
  },
  "team.TotalFrags": {
    "prefix": "team.TotalFrags",
    "body": "team.TotalFrags(${1:Entity Entity or number})$0",
    "description": "(Shared) Function: team.TotalFrags\n\nGet's the total frags in a team."
  },
  "team.Valid": {
    "prefix": "team.Valid",
    "body": "team.Valid(${1:number index})$0",
    "description": "(Shared) Function: team.Valid\n\nReturns true if the given team index is valid"
  },
  "team": [],
  "timer.Adjust": {
    "prefix": "timer.Adjust",
    "body": "timer.Adjust(${1:any identifier}, ${2:number delay}, ${3:number repetitions}, ${4:function func})$0",
    "description": "(All) Function: timer.Adjust\n\nAdjusts the timer if the timer with the given identifier exists."
  },
  "timer.Check": {
    "prefix": "timer.Check",
    "body": "timer.Check()$0",
    "description": "(All) Function: timer.Check\n\n[Deprecated]  This function does nothing."
  },
  "timer.Create": {
    "prefix": "timer.Create",
    "body": "timer.Create(${1:string identifier}, ${2:number delay}, ${3:number repetitions}, ${4:function func})$0",
    "description": "(All) Function: timer.Create\n\nCreates a new timer that will repeat its function given amount of times."
  },
  "timer.Destroy": {
    "prefix": "timer.Destroy",
    "body": "timer.Destroy(${1:string identifier})$0",
    "description": "(All) Function: timer.Destroy\n\n[Deprecated] .You should be using timer.Remove instead. Stops and destroys the given timer. Alias of timer.Remove."
  },
  "timer.Exists": {
    "prefix": "timer.Exists",
    "body": "timer.Exists(${1:string identifier})$0",
    "description": "(All) Function: timer.Exists\n\nReturns whenever the given timer exists or not."
  },
  "timer.Pause": {
    "prefix": "timer.Pause",
    "body": "timer.Pause(${1:any identifier})$0",
    "description": "(All) Function: timer.Pause\n\nPauses the given timer."
  },
  "timer.Remove": {
    "prefix": "timer.Remove",
    "body": "timer.Remove(${1:string identifier})$0",
    "description": "(All) Function: timer.Remove\n\nStops and removes a timer created by timer.Create."
  },
  "timer.RepsLeft": {
    "prefix": "timer.RepsLeft",
    "body": "timer.RepsLeft(${1:any identifier})$0",
    "description": "(All) Function: timer.RepsLeft\n\nReturns amount of repetitions/executions left before the timer destroys itself."
  },
  "timer.Simple": {
    "prefix": "timer.Simple",
    "body": "timer.Simple(${1:number delay}, ${2:function func})$0",
    "description": "(All) Function: timer.Simple\n\nCreates a simple timer that runs the given function after a specified delay."
  },
  "timer.Start": {
    "prefix": "timer.Start",
    "body": "timer.Start(${1:any identifier})$0",
    "description": "(All) Function: timer.Start\n\nRestarts the given timer."
  },
  "timer.Stop": {
    "prefix": "timer.Stop",
    "body": "timer.Stop(${1:any identifier})$0",
    "description": "(All) Function: timer.Stop\n\nStops the given timer and rewinds it."
  },
  "timer.TimeLeft": {
    "prefix": "timer.TimeLeft",
    "body": "timer.TimeLeft(${1:any identifier})$0",
    "description": "(All) Function: timer.TimeLeft\n\nReturns amount of time left (in seconds) before the timer executes its function."
  },
  "timer.Toggle": {
    "prefix": "timer.Toggle",
    "body": "timer.Toggle(${1:any identifier})$0",
    "description": "(All) Function: timer.Toggle\n\nRuns either timer.Pause or timer.UnPause based on the timer's current status."
  },
  "timer.UnPause": {
    "prefix": "timer.UnPause",
    "body": "timer.UnPause(${1:any identifier})$0",
    "description": "(All) Function: timer.UnPause\n\nUnpauses the timer."
  },
  "timer": [],
  "umsg.Angle": {
    "prefix": "umsg.Angle",
    "body": "umsg.Angle(${1:Angle angle})$0",
    "description": "(Server) Function: umsg.Angle\n\nWrites an angle to the usermessage."
  },
  "umsg.Bool": {
    "prefix": "umsg.Bool",
    "body": "umsg.Bool(${1:boolean bool})$0",
    "description": "(Server) Function: umsg.Bool\n\nWrites a bool to the usermessage."
  },
  "umsg.Char": {
    "prefix": "umsg.Char",
    "body": "umsg.Char(${1:number char})$0",
    "description": "(Server) Function: umsg.Char\n\nWrites a signed char to the usermessage."
  },
  "umsg.End": {
    "prefix": "umsg.End",
    "body": "umsg.End()$0",
    "description": "(Server) Function: umsg.End\n\nDispatches the usermessage to the client(s)."
  },
  "umsg.Entity": {
    "prefix": "umsg.Entity",
    "body": "umsg.Entity(${1:Entity entity})$0",
    "description": "(Server) Function: umsg.Entity\n\nWrites an entity object to the usermessage."
  },
  "umsg.Float": {
    "prefix": "umsg.Float",
    "body": "umsg.Float(${1:number float})$0",
    "description": "(Server) Function: umsg.Float\n\nWrites a float to the usermessage."
  },
  "umsg.Long": {
    "prefix": "umsg.Long",
    "body": "umsg.Long(${1:number int})$0",
    "description": "(Server) Function: umsg.Long\n\nWrites a signed int (32 bit) to the usermessage."
  },
  "umsg.PoolString": {
    "prefix": "umsg.PoolString",
    "body": "umsg.PoolString(${1:string string})$0",
    "description": "(Server) Function: umsg.PoolString\n\n[Deprecated] .Inferior version of util.AddNetworkString"
  },
  "umsg.Short": {
    "prefix": "umsg.Short",
    "body": "umsg.Short(${1:number short})$0",
    "description": "(Server) Function: umsg.Short\n\nWrites a signed short (16 bit) to the usermessage."
  },
  "umsg.Start": {
    "prefix": "umsg.Start",
    "body": "umsg.Start(${1:string name}, ${2:Player filter})$0",
    "description": "(Server) Function: umsg.Start\n\n[Deprecated] .You should be using net instead"
  },
  "umsg.String": {
    "prefix": "umsg.String",
    "body": "umsg.String(${1:string string})$0",
    "description": "(Server) Function: umsg.String\n\nWrites a null terminated string to the usermessage."
  },
  "umsg.Vector": {
    "prefix": "umsg.Vector",
    "body": "umsg.Vector(${1:Vector vector})$0",
    "description": "(Server) Function: umsg.Vector\n\nWrites a Vector to the usermessage."
  },
  "umsg.VectorNormal": {
    "prefix": "umsg.VectorNormal",
    "body": "umsg.VectorNormal(${1:Vector normal})$0",
    "description": "(Server) Function: umsg.VectorNormal\n\nWrites a vector normal to the usermessage."
  },
  "umsg": [],
  "undo.AddEntity": {
    "prefix": "undo.AddEntity",
    "body": "undo.AddEntity(${1:Entity ent})$0",
    "description": "(Server) Function: undo.AddEntity\n\nAdds an entity to the current undo block"
  },
  "undo.AddFunction": {
    "prefix": "undo.AddFunction",
    "body": "undo.AddFunction(${1:function func}, ${2:any arg2, ...})$0",
    "description": "(Server) Function: undo.AddFunction\n\nAdds a function to call when the current undo block is undone"
  },
  "undo.Create": {
    "prefix": "undo.Create",
    "body": "undo.Create(${1:string name})$0",
    "description": "(Server) Function: undo.Create\n\nBegins a new undo entry"
  },
  "undo.Do_Undo": {
    "prefix": "undo.Do_Undo",
    "body": "undo.Do_Undo(${1:table tab})$0",
    "description": "(Server) Function: undo.Do_Undo\n\nProcesses an undo block (in table form). This is used internally by the undo manager when a player presses Z."
  },
  "undo.Finish": {
    "prefix": "undo.Finish",
    "body": "undo.Finish()$0",
    "description": "(Shared) Function: undo.Finish\n\nCompletes an undo entry, and registers it with the player's client"
  },
  "undo.GetTable": {
    "prefix": "undo.GetTable",
    "body": "undo.GetTable()$0",
    "description": "(Shared) Function: undo.GetTable\n\nServerside, returns a table containing all undo blocks of all players. Clientside, returns a table of the local player's undo blocks."
  },
  "undo.MakeUIDirty": {
    "prefix": "undo.MakeUIDirty",
    "body": "undo.MakeUIDirty()$0",
    "description": "(Client) Function: undo.MakeUIDirty\n\n[Internal] "
  },
  "undo.ReplaceEntity": {
    "prefix": "undo.ReplaceEntity",
    "body": "undo.ReplaceEntity(${1:Entity from}, ${2:Entity to})$0",
    "description": "(Server) Function: undo.ReplaceEntity\n\nReplaces any instance of the \"from\" reference with the \"to\" reference, in any existing undo block. Returns true if something was replaced"
  },
  "undo.SetCustomUndoText": {
    "prefix": "undo.SetCustomUndoText",
    "body": "undo.SetCustomUndoText(${1:string customText})$0",
    "description": "(Server) Function: undo.SetCustomUndoText\n\nSets a custom undo text for the current undo block"
  },
  "undo.SetPlayer": {
    "prefix": "undo.SetPlayer",
    "body": "undo.SetPlayer(${1:Player ply})$0",
    "description": "(Server) Function: undo.SetPlayer\n\nSets the player which the current undo block belongs to"
  },
  "undo.SetupUI": {
    "prefix": "undo.SetupUI",
    "body": "undo.SetupUI()$0",
    "description": "(Client) Function: undo.SetupUI\n\n[Internal] "
  },
  "undo": [],
  "usermessage.GetTable": {
    "prefix": "usermessage.GetTable",
    "body": "usermessage.GetTable()$0",
    "description": "(Shared) Function: usermessage.GetTable\n\nReturns a table of every usermessage hook"
  },
  "usermessage.Hook": {
    "prefix": "usermessage.Hook",
    "body": "usermessage.Hook(${1:string name}, ${2:function callback}, ${3:vararg preArgs=nil})$0",
    "description": "(Shared) Function: usermessage.Hook\n\n[Deprecated] .You should be using net instead"
  },
  "usermessage.IncomingMessage": {
    "prefix": "usermessage.IncomingMessage",
    "body": "usermessage.IncomingMessage(${1:string name}, ${2:bf_read msg})$0",
    "description": "(Shared) Function: usermessage.IncomingMessage\n\nCalled by the engine when a usermessage arrives, this method calls the hook function specified by usermessage.Hook if any."
  },
  "usermessage": [],
  "utf8.char": {
    "prefix": "utf8.char",
    "body": "utf8.char(${1:vararg codepoints})$0",
    "description": "(Shared) Function: utf8.char\n\nReceives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences."
  },
  "utf8.codepoint": {
    "prefix": "utf8.codepoint",
    "body": "utf8.codepoint(${1:string string}, ${2:number startPos=1}, ${3:number endPos=1})$0",
    "description": "(Shared) Function: utf8.codepoint\n\nReturns the codepoints (as numbers) from all characters in the given string that start between byte position startPos and endPos. It raises an error if it meets any invalid byte sequence. This functions similarly to string.byte."
  },
  "utf8.codes": {
    "prefix": "utf8.codes",
    "body": "utf8.codes(${1:string string})$0",
    "description": "(Shared) Function: utf8.codes\n\nReturns an iterator (like string.gmatch) which returns both the position and codepoint of each utf8 character in the string. It raises an error if it meets any invalid byte sequence. "
  },
  "utf8.force": {
    "prefix": "utf8.force",
    "body": "utf8.force(${1:string string})$0",
    "description": "(Shared) Function: utf8.force\n\nForces a string to contain only valid UTF-8 data. Invalid sequences are replaced with U FFFD (the Unicode replacement character)."
  },
  "utf8.len": {
    "prefix": "utf8.len",
    "body": "utf8.len(${1:string string}, ${2:number startPos=1}, ${3:number endPos=-1})$0",
    "description": "(Shared) Function: utf8.len\n\nReturns the number of UTF-8 sequences in the given string between positions startPos and endPos (both inclusive). If it finds any invalid UTF-8 byte sequence, returns false as well as the position of the first invalid byte."
  },
  "utf8.offset": {
    "prefix": "utf8.offset",
    "body": "utf8.offset(${1:string string}, ${2:number n}, ${3:number startPos=1 when n>=0, -1 otherwise})$0",
    "description": "(Shared) Function: utf8.offset\n\nReturns the byte-index of the n'th UTF-8-character after the given startPos (nil if none). startPos defaults to 1 when n is positive and -1 when n is negative. If n is zero, this function instead returns the byte-index of the UTF-8-character startPos lies within."
  },
  "utf8": [],
  "util.worldpicker.Active": {
    "prefix": "util.worldpicker.Active",
    "body": "util.worldpicker.Active()$0",
    "description": "(Client) Function: util.worldpicker.Active\n\nReturns if the user is currently picking an entity."
  },
  "util.worldpicker.Finish": {
    "prefix": "util.worldpicker.Finish",
    "body": "util.worldpicker.Finish(${1:table tr})$0",
    "description": "(Client) Function: util.worldpicker.Finish\n\n[Internal] "
  },
  "util.worldpicker.Start": {
    "prefix": "util.worldpicker.Start",
    "body": "util.worldpicker.Start(${1:function callback})$0",
    "description": "(Client) Function: util.worldpicker.Start\n\nStarts picking an entity in the world. This will suppress the next mouse click, and instead use it as a direction in the trace sent to the callback."
  },
  "util.worldpicker": [],
  "util.AddNetworkString": {
    "prefix": "util.AddNetworkString",
    "body": "util.AddNetworkString(${1:string str})$0",
    "description": "(Server) Function: util.AddNetworkString\n\nAdds the specified string to a string table, which will cache it and network it to all clients automatically."
  },
  "util.AimVector": {
    "prefix": "util.AimVector",
    "body": "util.AimVector(${1:Angle ViewAngles}, ${2:number ViewFOV}, ${3:number x}, ${4:number y}, ${5:number scrWidth}, ${6:number scrHeight})$0",
    "description": "(All) Function: util.AimVector\n\nFunction used to calculate aim vector from 2D screen position. It is used in SuperDOF calculate Distance."
  },
  "util.Base64Encode": {
    "prefix": "util.Base64Encode",
    "body": "util.Base64Encode(${1:string str})$0",
    "description": "(All) Function: util.Base64Encode\n\nEncodes the specified string to base64."
  },
  "util.BlastDamage": {
    "prefix": "util.BlastDamage",
    "body": "util.BlastDamage(${1:Entity inflictor}, ${2:Entity attacker}, ${3:Vector damageOrigin}, ${4:number damageRadius}, ${5:number damage})$0",
    "description": "(Server) Function: util.BlastDamage\n\nApplies explosion damage to all entities in the specified radius."
  },
  "util.BlastDamageInfo": {
    "prefix": "util.BlastDamageInfo",
    "body": "util.BlastDamageInfo(${1:CTakeDamageInfo dmg}, ${2:Vector damageOrigin}, ${3:number damageRadius})$0",
    "description": "(Server) Function: util.BlastDamageInfo\n\nApplies spherical damage based on damage info to all entities in the specified radius."
  },
  "util.Compress": {
    "prefix": "util.Compress",
    "body": "util.Compress(${1:string str})$0",
    "description": "(All) Function: util.Compress\n\nCompresses the given string using the [[wikipedia:LZMA.LZMA]] algorithm."
  },
  "util.CRC": {
    "prefix": "util.CRC",
    "body": "util.CRC(${1:string stringToHash})$0",
    "description": "(Shared) Function: util.CRC\n\nGenerates the [[wikipedia:Cyclic redundancy check.CRC checksum]] of the specified string."
  },
  "util.DateStamp": {
    "prefix": "util.DateStamp",
    "body": "util.DateStamp()$0",
    "description": "(All) Function: util.DateStamp\n\nReturns the current date formatted like '2012-10-31 18-00-00'"
  },
  "util.Decal": {
    "prefix": "util.Decal",
    "body": "util.Decal(${1:string name}, ${2:Vector start}, ${3:Vector end}, ${4:Entity filter=NULL})$0",
    "description": "(Shared) Function: util.Decal\n\nPerforms a trace and paints a decal to the surface hit."
  },
  "util.DecalEx": {
    "prefix": "util.DecalEx",
    "body": "util.DecalEx(${1:IMaterial material}, ${2:Entity ent}, ${3:Vector position}, ${4:Vector normal}, ${5:table color}, ${6:number w}, ${7:number h})$0",
    "description": "(Client) Function: util.DecalEx\n\nPerforms a trace and paints a decal to the surface hit."
  },
  "util.DecalMaterial": {
    "prefix": "util.DecalMaterial",
    "body": "util.DecalMaterial(${1:string decalName})$0",
    "description": "(Shared) Function: util.DecalMaterial\n\nGets the full material path by the decal name. Used with util.DecalEx."
  },
  "util.Decompress": {
    "prefix": "util.Decompress",
    "body": "util.Decompress(${1:string compressedString})$0",
    "description": "(All) Function: util.Decompress\n\nDecompresses the given string using [[wikipedia:LZMA.LZMA]] algorithm. Used to decompress strings previously compressed with util.Compress."
  },
  "util.DistanceToLine": {
    "prefix": "util.DistanceToLine",
    "body": "util.DistanceToLine(${1:Vector lineStart}, ${2:Vector lineEnd}, ${3:Vector pointPos})$0",
    "description": "(Shared) Function: util.DistanceToLine\n\nGets the distance between a line and a point in 3d space."
  },
  "util.Effect": {
    "prefix": "util.Effect",
    "body": "util.Effect(${1:string effectName}, ${2:CEffectData effectData}, ${3:boolean allowOverride=true}, ${4:any ignorePredictionOrRecipientFilter=nil})$0",
    "description": "(Shared) Function: util.Effect\n\nCreates a effect with the specified data."
  },
  "util.GetModelInfo": {
    "prefix": "util.GetModelInfo",
    "body": "util.GetModelInfo(${1:string mdl})$0",
    "description": "(Shared) Function: util.GetModelInfo\n\nReturns a table containing the info about the model. It seems to be not working serverside, but still exists serverside."
  },
  "util.GetPData": {
    "prefix": "util.GetPData",
    "body": "util.GetPData(${1:string steamID}, ${2:string name}, ${3:string default})$0",
    "description": "(All) Function: util.GetPData\n\nGets PData of an offline player using their SteamID"
  },
  "util.GetPixelVisibleHandle": {
    "prefix": "util.GetPixelVisibleHandle",
    "body": "util.GetPixelVisibleHandle()$0",
    "description": "(Client) Function: util.GetPixelVisibleHandle\n\nCreates a new PixVis handle. See util.PixelVisible."
  },
  "util.GetPlayerTrace": {
    "prefix": "util.GetPlayerTrace",
    "body": "util.GetPlayerTrace(${1:Player ply}, ${2:Vector dir=ply:GetAimVector()})$0",
    "description": "(All) Function: util.GetPlayerTrace\n\nUtility function to quickly generate a trace table that starts at the players view position, and ends 16384 units along a specified direction."
  },
  "util.GetSunInfo": {
    "prefix": "util.GetSunInfo",
    "body": "util.GetSunInfo()$0",
    "description": "(Client) Function: util.GetSunInfo\n\nGets information about the sun position and obstruction or nil if there is no sun."
  },
  "util.GetSurfaceIndex": {
    "prefix": "util.GetSurfaceIndex",
    "body": "util.GetSurfaceIndex(${1:string surfaceName})$0",
    "description": "(Shared) Function: util.GetSurfaceIndex\n\nReturns the matching surface index for the surface name."
  },
  "util.GetSurfacePropName": {
    "prefix": "util.GetSurfacePropName",
    "body": "util.GetSurfacePropName(${1:number id})$0",
    "description": "(Shared) Function: util.GetSurfacePropName\n\nReturns a name of surfaceproperties ID."
  },
  "util.GetUserGroups": {
    "prefix": "util.GetUserGroups",
    "body": "util.GetUserGroups()$0",
    "description": "(Server) Function: util.GetUserGroups\n\nReturns a table of all SteamIDs that have a usergroup."
  },
  "util.IntersectRayWithOBB": {
    "prefix": "util.IntersectRayWithOBB",
    "body": "util.IntersectRayWithOBB(${1:Vector rayStart}, ${2:Vector rayDirection}, ${3:Vector boxOrigin}, ${4:Angle boxAngles}, ${5:Vector boxMins}, ${6:Vector boxMaxs})$0",
    "description": "(Shared) Function: util.IntersectRayWithOBB\n\nPerforms a ray box intersection and returns position, normal and the fraction."
  },
  "util.IntersectRayWithPlane": {
    "prefix": "util.IntersectRayWithPlane",
    "body": "util.IntersectRayWithPlane(${1:Vector rayOrigin}, ${2:Vector rayDirection}, ${3:Vector planePosition}, ${4:Vector planeNormal})$0",
    "description": "(Shared) Function: util.IntersectRayWithPlane\n\nPerforms a [https://en.wikipedia.org/wiki/Lineplane_intersection ray-plane intersection] and returns the hit position or nil."
  },
  "util.IsInWorld": {
    "prefix": "util.IsInWorld",
    "body": "util.IsInWorld(${1:Vector position})$0",
    "description": "(Server) Function: util.IsInWorld\n\nChecks if a certain position in within the world bounds."
  },
  "util.IsModelLoaded": {
    "prefix": "util.IsModelLoaded",
    "body": "util.IsModelLoaded(${1:string modelName})$0",
    "description": "(Shared) Function: util.IsModelLoaded\n\nChecks if the model is loaded in the game."
  },
  "util.IsSkyboxVisibleFromPoint": {
    "prefix": "util.IsSkyboxVisibleFromPoint",
    "body": "util.IsSkyboxVisibleFromPoint(${1:Vector position})$0",
    "description": "(Client) Function: util.IsSkyboxVisibleFromPoint\n\nCheck whether the skybox is visibile from the point specified."
  },
  "util.IsValidModel": {
    "prefix": "util.IsValidModel",
    "body": "util.IsValidModel(${1:string modelName})$0",
    "description": "(Shared) Function: util.IsValidModel\n\nChecks if the specified model is valid."
  },
  "util.IsValidPhysicsObject": {
    "prefix": "util.IsValidPhysicsObject",
    "body": "util.IsValidPhysicsObject(${1:Entity ent}, ${2:number physobj})$0",
    "description": "(All) Function: util.IsValidPhysicsObject\n\nChecks if given numbered physics object of given entity is valid or not. Most useful for ragdolls."
  },
  "util.IsValidProp": {
    "prefix": "util.IsValidProp",
    "body": "util.IsValidProp(${1:string modelName})$0",
    "description": "(Shared) Function: util.IsValidProp\n\nChecks if the specified prop is valid."
  },
  "util.IsValidRagdoll": {
    "prefix": "util.IsValidRagdoll",
    "body": "util.IsValidRagdoll(${1:string ragdollName})$0",
    "description": "(Shared) Function: util.IsValidRagdoll\n\nChecks if the specified model name points to a valid ragdoll."
  },
  "util.JSONToTable": {
    "prefix": "util.JSONToTable",
    "body": "util.JSONToTable(${1:string json})$0",
    "description": "(All) Function: util.JSONToTable\n\nConverts a JSON string to a Lua table."
  },
  "util.KeyValuesToTable": {
    "prefix": "util.KeyValuesToTable",
    "body": "util.KeyValuesToTable(${1:string KeyValuestring}, ${2:boolean usesEscapeSequences=false}, ${3:boolean preserveKeyCase=false})$0",
    "description": "(All) Function: util.KeyValuesToTable\n\nConverts a KeyValue string to a Lua table."
  },
  "util.KeyValuesToTablePreserveOrder": {
    "prefix": "util.KeyValuesToTablePreserveOrder",
    "body": "util.KeyValuesToTablePreserveOrder(${1:string keyvals}, ${2:boolean usesEscapeSequences=false}, ${3:boolean preserveKeyCase=false})$0",
    "description": "(All) Function: util.KeyValuesToTablePreserveOrder\n\nSimilar to util.KeyValuesToTable but it also preserves order of keys."
  },
  "util.LocalToWorld": {
    "prefix": "util.LocalToWorld",
    "body": "util.LocalToWorld(${1:Entity ent}, ${2:Vector lpos}, ${3:number bonenum})$0",
    "description": "(All) Function: util.LocalToWorld\n\nReturns a vector in world coordinates based on an entity and local coordinates"
  },
  "util.NetworkIDToString": {
    "prefix": "util.NetworkIDToString",
    "body": "util.NetworkIDToString(${1:number stringTableID})$0",
    "description": "(Shared) Function: util.NetworkIDToString\n\nReturns the networked string associated with the given ID from the string table."
  },
  "util.NetworkStringToID": {
    "prefix": "util.NetworkStringToID",
    "body": "util.NetworkStringToID(${1:string networkString})$0",
    "description": "(Shared) Function: util.NetworkStringToID\n\nReturns the networked ID associated with the given string from the string table."
  },
  "util.NiceFloat": {
    "prefix": "util.NiceFloat",
    "body": "util.NiceFloat(${1:number float})$0",
    "description": "(All) Function: util.NiceFloat\n\nFormats a float by stripping off extra 0's and .'s"
  },
  "util.ParticleTracer": {
    "prefix": "util.ParticleTracer",
    "body": "util.ParticleTracer(${1:string name}, ${2:Vector startPos}, ${3:Vector endPos}, ${4:boolean doWhiz})$0",
    "description": "(Shared) Function: util.ParticleTracer\n\nCreates a tracer effect with the given parameters."
  },
  "util.ParticleTracerEx": {
    "prefix": "util.ParticleTracerEx",
    "body": "util.ParticleTracerEx(${1:string name}, ${2:Vector startPos}, ${3:Vector endPos}, ${4:boolean doWhiz}, ${5:number entityIndex}, ${6:number attachmentIndex})$0",
    "description": "(Shared) Function: util.ParticleTracerEx\n\nCreates a tracer effect with the given parameters."
  },
  "util.PixelVisible": {
    "prefix": "util.PixelVisible",
    "body": "util.PixelVisible(${1:Vector position}, ${2:number radius}, ${3:pixelvis handle t PixVis})$0",
    "description": "(Client) Function: util.PixelVisible\n\nReturns the visibility of a sphere in the world."
  },
  "util.PointContents": {
    "prefix": "util.PointContents",
    "body": "util.PointContents(${1:Vector position})$0",
    "description": "(Shared) Function: util.PointContents\n\nReturns the contents of the position specified."
  },
  "util.PrecacheModel": {
    "prefix": "util.PrecacheModel",
    "body": "util.PrecacheModel(${1:string modelName})$0",
    "description": "(Shared) Function: util.PrecacheModel\n\nPrecaches a model for later use. Model is cached after being loaded once."
  },
  "util.PrecacheSound": {
    "prefix": "util.PrecacheSound",
    "body": "util.PrecacheSound(${1:string soundName})$0",
    "description": "(Shared) Function: util.PrecacheSound\n\nPrecaches a sound for later use. Sound is cached after being loaded once."
  },
  "util.QuickTrace": {
    "prefix": "util.QuickTrace",
    "body": "util.QuickTrace(${1:Vector origin}, ${2:Vector direction}, ${3:Entity filter=nil})$0",
    "description": "(All) Function: util.QuickTrace\n\nPerforms a trace with the given origin, direction and filter."
  },
  "util.RelativePathToFull": {
    "prefix": "util.RelativePathToFull",
    "body": "util.RelativePathToFull(${1:string file})$0",
    "description": "(Shared) Function: util.RelativePathToFull\n\nReturns the absolute system path the file relative to /garrysmod/."
  },
  "util.RemovePData": {
    "prefix": "util.RemovePData",
    "body": "util.RemovePData(${1:string steamID}, ${2:string name})$0",
    "description": "(All) Function: util.RemovePData\n\nRemoves PData of offline player using his SteamID"
  },
  "util.ScreenShake": {
    "prefix": "util.ScreenShake",
    "body": "util.ScreenShake(${1:Vector pos}, ${2:number amplitude}, ${3:number frequency}, ${4:number duration}, ${5:number radius})$0",
    "description": "(Shared) Function: util.ScreenShake\n\nMakes the screen shake"
  },
  "util.SetPData": {
    "prefix": "util.SetPData",
    "body": "util.SetPData(${1:string steamID}, ${2:string name}, ${3:any value})$0",
    "description": "(All) Function: util.SetPData\n\nSets PData for offline player using his SteamID"
  },
  "util.SharedRandom": {
    "prefix": "util.SharedRandom",
    "body": "util.SharedRandom(${1:string uniqueName}, ${2:number min}, ${3:number max}, ${4:number additionalSeed=0})$0",
    "description": "(Shared) Function: util.SharedRandom\n\nGenerates a random float value that should be the same on client and server."
  },
  "util.SpriteTrail": {
    "prefix": "util.SpriteTrail",
    "body": "util.SpriteTrail(${1:Entity ent}, ${2:number attachmentID}, ${3:table color}, ${4:boolean additive}, ${5:number startWidth}, ${6:number endWidth}, ${7:number lifetime}, ${8:number textureRes}, ${9:string texture})$0",
    "description": "(Server) Function: util.SpriteTrail\n\nAdds a trail to the specified entity."
  },
  "util.Stack": {
    "prefix": "util.Stack",
    "body": "util.Stack()$0",
    "description": "(All) Function: util.Stack\n\nReturns a new Stack object"
  },
  "util.SteamIDFrom64": {
    "prefix": "util.SteamIDFrom64",
    "body": "util.SteamIDFrom64(${1:string id})$0",
    "description": "(Shared) Function: util.SteamIDFrom64\n\nGiven a 64bit SteamID will return a STEAM_0: style Steam ID"
  },
  "util.SteamIDTo64": {
    "prefix": "util.SteamIDTo64",
    "body": "util.SteamIDTo64(${1:string id})$0",
    "description": "(Shared) Function: util.SteamIDTo64\n\nGiven a STEAM_0 style Steam ID will return a 64bit Steam ID"
  },
  "util.StringToType": {
    "prefix": "util.StringToType",
    "body": "util.StringToType(${1:string str}, ${2:string typename})$0",
    "description": "(All) Function: util.StringToType\n\nConverts a string to the specified type."
  },
  "util.TableToJSON": {
    "prefix": "util.TableToJSON",
    "body": "util.TableToJSON(${1:table table}, ${2:boolean prettyPrint=false})$0",
    "description": "(All) Function: util.TableToJSON\n\nConverts a table to a JSON string."
  },
  "util.TableToKeyValues": {
    "prefix": "util.TableToKeyValues",
    "body": "util.TableToKeyValues(${1:table table})$0",
    "description": "(All) Function: util.TableToKeyValues\n\nConverts the given table into a key value string."
  },
  "util.Timer": {
    "prefix": "util.Timer",
    "body": "util.Timer(${1:number startdelay=0})$0",
    "description": "(All) Function: util.Timer\n\nCreates a timer object."
  },
  "util.TimerCycle": {
    "prefix": "util.TimerCycle",
    "body": "util.TimerCycle()$0",
    "description": "(All) Function: util.TimerCycle\n\nReturns the time since this function has been last called"
  },
  "util.tobool": {
    "prefix": "util.tobool",
    "body": "util.tobool(${1:any input})$0",
    "description": "(All) Function: util.tobool\n\n[Deprecated] .You should use _G.tobool instead."
  },
  "util.TraceEntity": {
    "prefix": "util.TraceEntity",
    "body": "util.TraceEntity(${1:table tracedata}, ${2:Entity ent})$0",
    "description": "(Shared) Function: util.TraceEntity\n\nRuns a trace using the ent's collisionmodel between two points."
  },
  "util.TraceEntityHull": {
    "prefix": "util.TraceEntityHull",
    "body": "util.TraceEntityHull(${1:Entity ent1}, ${2:Entity ent2})$0",
    "description": "(Shared) Function: util.TraceEntityHull\n\n[Deprecated] .This function is broken and returns the same values all the time"
  },
  "util.TraceHull": {
    "prefix": "util.TraceHull",
    "body": "util.TraceHull(${1:table TraceData})$0",
    "description": "(Shared) Function: util.TraceHull\n\nPerforms a hull trace with the given trace data. This function is shared but will not give the desired results on the client; you should only use this serverside as the function utilizes certain physics mechanisms that do not exist on the client."
  },
  "util.TraceLine": {
    "prefix": "util.TraceLine",
    "body": "util.TraceLine(${1:table TraceData})$0",
    "description": "(Shared) Function: util.TraceLine\n\nPerforms a trace with the given trace data."
  },
  "util.TypeToString": {
    "prefix": "util.TypeToString",
    "body": "util.TypeToString(${1:any input})$0",
    "description": "(All) Function: util.TypeToString\n\nConverts a type to a (nice, but still parsable) string"
  },
  "util": [],
  "vgui.Create": {
    "prefix": "vgui.Create",
    "body": "vgui.Create(${1:string classname}, ${2:Panel parent=nil}, ${3:string name=nil})$0",
    "description": "(Client and Menu) Function: vgui.Create\n\nCreates a panel by the specified classname."
  },
  "vgui.CreateFromTable": {
    "prefix": "vgui.CreateFromTable",
    "body": "vgui.CreateFromTable(${1:table metatable}, ${2:Panel parent=nil}, ${3:string name=nil})$0",
    "description": "(Client and Menu) Function: vgui.CreateFromTable\n\nCreates a panel from table."
  },
  "vgui.CreateX": {
    "prefix": "vgui.CreateX",
    "body": "vgui.CreateX(${1:string class}, ${2:Panel parent=nil}, ${3:string name=nil})$0",
    "description": "(Client and Menu) Function: vgui.CreateX\n\n[Internal]  Creates a engine panel."
  },
  "vgui.CursorVisible": {
    "prefix": "vgui.CursorVisible",
    "body": "vgui.CursorVisible()$0",
    "description": "(Client and Menu) Function: vgui.CursorVisible\n\nReturns whenever the cursor is currently active and visible."
  },
  "vgui.FocusedHasParent": {
    "prefix": "vgui.FocusedHasParent",
    "body": "vgui.FocusedHasParent(${1:Panel parent})$0",
    "description": "(Client and Menu) Function: vgui.FocusedHasParent\n\nReturns whether the currently focused panel is a child of the given one."
  },
  "vgui.GetControlTable": {
    "prefix": "vgui.GetControlTable",
    "body": "vgui.GetControlTable(${1:string Panelname})$0",
    "description": "(Client and Menu) Function: vgui.GetControlTable\n\nGets the method table of this panel. Does not return parent methods!"
  },
  "vgui.GetHoveredPanel": {
    "prefix": "vgui.GetHoveredPanel",
    "body": "vgui.GetHoveredPanel()$0",
    "description": "(Client and Menu) Function: vgui.GetHoveredPanel\n\nReturns the panel the cursor is hovering above."
  },
  "vgui.GetKeyboardFocus": {
    "prefix": "vgui.GetKeyboardFocus",
    "body": "vgui.GetKeyboardFocus()$0",
    "description": "(Client and Menu) Function: vgui.GetKeyboardFocus\n\nReturns the panel which is currently receiving keyboard input."
  },
  "vgui.GetWorldPanel": {
    "prefix": "vgui.GetWorldPanel",
    "body": "vgui.GetWorldPanel()$0",
    "description": "(Client and Menu) Function: vgui.GetWorldPanel\n\nReturns the global world panel which is the parent to all others."
  },
  "vgui.IsHoveringWorld": {
    "prefix": "vgui.IsHoveringWorld",
    "body": "vgui.IsHoveringWorld()$0",
    "description": "(Client and Menu) Function: vgui.IsHoveringWorld\n\nReturns whenever the cursor is hovering the world panel."
  },
  "vgui.Register": {
    "prefix": "vgui.Register",
    "body": "vgui.Register(${1:string classname}, ${2:table panelTable}, ${3:string baseName})$0",
    "description": "(Client and Menu) Function: vgui.Register\n\nRegisters a panel for later creation."
  },
  "vgui.RegisterFile": {
    "prefix": "vgui.RegisterFile",
    "body": "vgui.RegisterFile(${1:string file})$0",
    "description": "(Client and Menu) Function: vgui.RegisterFile\n\nRegisters a new VGUI panel from a file."
  },
  "vgui.RegisterTable": {
    "prefix": "vgui.RegisterTable",
    "body": "vgui.RegisterTable(${1:table panel}, ${2:string base=Panel})$0",
    "description": "(Client and Menu) Function: vgui.RegisterTable\n\nRegisters a table to use as a panel. All this function does is assigns Base key to your table and returns the table."
  },
  "vgui": [],
  "video.Record": {
    "prefix": "video.Record",
    "body": "video.Record(${1:table config})$0",
    "description": "(Client and Menu) Function: video.Record\n\nAttempts to create an IVideoWriter."
  },
  "video": [],
  "weapons.Get": {
    "prefix": "weapons.Get",
    "body": "weapons.Get(${1:string classname})$0",
    "description": "(Shared) Function: weapons.Get\n\nGet copy of weapon table by name. If all you need to do is access a variable from the weapon table, use weapons.GetStored instead."
  },
  "weapons.GetList": {
    "prefix": "weapons.GetList",
    "body": "weapons.GetList()$0",
    "description": "(Shared) Function: weapons.GetList\n\nGet a list of all the registered SWEPs. This does not include weapons added to spawnmenu manually."
  },
  "weapons.GetStored": {
    "prefix": "weapons.GetStored",
    "body": "weapons.GetStored(${1:string weapon_class})$0",
    "description": "(Shared) Function: weapons.GetStored\n\nGets the REAL weapon table, not a copy."
  },
  "weapons.IsBasedOn": {
    "prefix": "weapons.IsBasedOn",
    "body": "weapons.IsBasedOn(${1:string name}, ${2:string base})$0",
    "description": "(Shared) Function: weapons.IsBasedOn\n\nChecks if name is based on base"
  },
  "weapons.OnLoaded": {
    "prefix": "weapons.OnLoaded",
    "body": "weapons.OnLoaded()$0",
    "description": "(Shared) Function: weapons.OnLoaded\n\n[Internal] "
  },
  "weapons.Register": {
    "prefix": "weapons.Register",
    "body": "weapons.Register(${1:table swep_table}, ${2:string classname})$0",
    "description": "(Shared) Function: weapons.Register\n\nUsed to register your SWEP with the engine."
  },
  "weapons": [],
  "widgets.PlayerTick": {
    "prefix": "widgets.PlayerTick",
    "body": "widgets.PlayerTick(${1:Player ply}, ${2:CMoveData mv})$0",
    "description": "(Shared) Function: widgets.PlayerTick\n\n[Internal]  Automatically called to update all widgets."
  },
  "widgets": []
}